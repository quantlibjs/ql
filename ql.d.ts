/**
 * ql.d.ts v0.3.3 https://quantlib.js.org
 *
 * Copyright 2019 - 2020 Jin Yang. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
declare namespace std {
  export function max_element(a: number[]): number;
  export function min_element(a: number[]): number;
  export function random_shuffle(array: any[]): void;
  export function is_sorted(array: any[]): number;
  export function unique(a: number[]): number[];
  export function unique1(a: any[], f: BinaryFunction<any, any, any>): number[];
  export function find_if(a: any[], f: UnaryFunction<number, boolean>): number;
  export function remove(a: any[], v: any): any[];
  export function distance(first: number, last: number): number;
  export function reverse(array: number[], start?: number, stop?: number): void;
  export function inner_product(
      v1: number[], v2: number[], value: number): number;
  export function adjacent_difference(a: number[]): number[];
}

declare class Complex {
  constructor(r?: Real, i?: Real);
  real(): Real;
  imag(): Real;
  norm(): Real;
  abs(): Real;
  clone(): Complex;
  add(c: Complex): Complex;
  addScalar(s: Real): Complex;
  sub(c: Complex): Complex;
  subScalar(s: Real): Complex;
  mul(c: Complex): Complex;
  mulScalar(r: Real): Complex;
  div(c: Complex): Complex;
  divScalar(r: Real): Complex;
  toString(): string;
  _real: Real;
  _imag: Real;
}
declare namespace Complex {
  function newArray(n: Size): Complex[];
  function cloneArray(c: Complex[]): Complex[];
  function abs(c: Complex): Real;
  function add(c1: Complex, c2: Complex): Complex;
  function addScalar(c: Complex, s: Real): Complex;
  function sub(c1: Complex, c2: Complex): Complex;
  function subScalar(c: Complex, s: Real): Complex;
  function mul(c1: Complex, c2: Complex): Complex;
  function mulScalar(c: Complex, s: Real): Complex;
  function div(c1: Complex, c2: Complex): Complex;
  function pow(c: Complex, n: Size): Complex;
  function sqrt(c: Complex): Complex;
  function exp(c: Complex): Complex;
  function log(c: Complex): Complex;
  function equal(c1: Complex, c2: Complex): boolean;
  function notEqual(c1: Complex, c2: Complex): boolean;
}

interface NullaryFunction<T> {
  f(): T;
}
interface UnaryFunction<X, Y> {
  f(x: X): Y;
  d?(x: X): Y;
  d2?(x: X): Y;
}
interface BinaryFunction<X, Y, Z> {
  f(x: X, y: Y): Z;
}
interface TernaryFunction<X, Y, Z, T> {
  f(x: X, y: Y, z: Z): T;
}

declare const first = 0;
declare const second = 1;
declare const third = 2;
declare const begin = 0;

export declare type Leg = CashFlow[];
export declare class CashFlow extends Event {
  amount1(): Real;
  exCouponDate(): Date;
  tradingExCoupon(refDate?: Date): boolean;
  hasOccurred(refDate?: Date, includeRefDate?: boolean): boolean;
  accept(v: AcyclicVisitor): void;
}
export declare function earlier_than(c1: CashFlow, c2: CashFlow): number;

export declare enum Compounding {
  Simple = 0,
  Compounded = 1,
  Continuous = 2,
  SimpleThenCompounded = 3,
  CompoundedThenSimple = 4
}

export declare class Currency {
  name(): string;
  code(): string;
  numericCode(): Integer;
  symbol(): string;
  fractionSymbol(): string;
  fractionsPerUnit(): Integer;
  rounding(): Rounding;
  format(): string;
  empty(): boolean;
  triangulationCurrency(): Currency;
  readonly isDisposed: boolean;
  dispose(): void;
  protected _data: Currency.Data;
  private _isDisposed;
}
export declare namespace Currency {
  class Data {
    constructor(
        name: string, code: string, numeric: Integer, symbol: string,
        fractionSymbol: string, fractionsPerUnit: Integer, rounding: Rounding,
        formatString: string, triangulated?: Currency);
    name: string;
    code: string;
    numeric: Integer;
    symbol: string;
    fractionSymbol: string;
    fractionsPerUnit: Integer;
    rounding: Rounding;
    triangulated: Currency;
    formatString: string;
  }
  function equal(c1: Currency, c2: Currency): boolean;
}

export declare namespace Protection {
  enum Side { Buyer = 0, Seller = 1 }
}

export declare class DiscretizedAsset {
  init(...args: any[]): DiscretizedAsset;
  time: Time;
  values: Real[];
  method(): Lattice;
  initialize(method: Lattice, t: Time): void;
  rollback(to: Time): void;
  partialRollback(to: Time): void;
  presentValue(): Real;
  mandatoryTimes(): Time[];
  reset(size: Size): void;
  preAdjustValuesImpl(): void;
  postAdjustValuesImpl(): void;
  adjustValues(): void;
  protected isOnTime(t: Time): boolean;
  preAdjustValues(): void;
  postAdjustValues(): void;
  protected _time: Time;
  protected _latestPreAdjustment: Time;
  protected _latestPostAdjustment: Time;
  protected _values: Real[];
  readonly isDisposed: boolean;
  dispose(): void;
  _isDisposed: boolean;
  private _method;
}
export declare class DiscretizedDiscountBond extends DiscretizedAsset {
  reset(size: Size): void;
  mandatoryTimes(): Time[];
}
export declare class DiscretizedOption extends DiscretizedAsset {
  constructor(
      underlying: DiscretizedAsset, exerciseType: Exercise.Type,
      exerciseTimes: Time[]);
  reset(size: Size): void;
  mandatoryTimes(): Time[];
  applyExerciseCondition(): void;
  postAdjustValuesImpl(): void;
  protected _underlying: DiscretizedAsset;
  protected _exerciseType: Exercise.Type;
  protected _exerciseTimes: Time[];
}

export declare class VirtualMethod extends Error {
  constructor();
}

export declare class Event extends Observable {
  date(): Date;
  hasOccurred(d?: Date, includeRefDate?: boolean): boolean;
  accept(v: AcyclicVisitor): void;
}
export declare class simple_event extends Event {
  constructor(date: Date);
  date(): Date;
  private _date;
}

export declare class ExchangeRate {
  init(source: Currency, target: Currency, rate: Decimal): ExchangeRate;
  source(): Currency;
  target(): Currency;
  type(): ExchangeRate.Type;
  rate(): Decimal;
  exchange(amount: Money): Money;
  static chain(r1: ExchangeRate, r2: ExchangeRate): ExchangeRate;
  readonly isDisposed: boolean;
  dispose(): void;
  private _source;
  private _target;
  private _rate;
  private _type;
  private _rateChain;
  private _isDisposed;
}
export declare namespace ExchangeRate {
  enum Type { Direct = 0, Derived = 1 }
}

export declare class Exercise {
  init(type: Exercise.Type): Exercise;
  type(): Exercise.Type;
  date(index: Size): Date;
  dates(): Date[];
  lastDate(): Date;
  readonly isDisposed: boolean;
  dispose(): void;
  protected _dates: Date[];
  protected _type: Exercise.Type;
  private _isDisposed;
}
export declare class EarlyExercise extends Exercise {
  eeInit(type: Exercise.Type, payoffAtExpiry?: boolean): EarlyExercise;
  payoffAtExpiry(): boolean;
  private _payoffAtExpiry;
}
export declare class AmericanExercise extends EarlyExercise {
  aeInit1(earliestDate: Date, latestDate: Date, payoffAtExpiry?: boolean):
      AmericanExercise;
  aeInit2(latestDate: Date, payoffAtExpiry?: boolean): AmericanExercise;
}
export declare class BermudanExercise extends EarlyExercise {
  beInit(dates: Date[], payoffAtExpiry?: boolean): BermudanExercise;
}
export declare class EuropeanExercise extends Exercise {
  constructor(date: Date);
}
export declare namespace Exercise {
  enum Type { American = 0, Bermudan = 1, European = 2 }
}

export declare let AltPrimitivePolynomials: number[][];
export declare let SLinitializers: number[][];
export declare let Linitializers: number[][];
export declare let initializers: number[][];
export declare let JoeKuoD5initializers: number[][];
export declare let JoeKuoD6initializers: number[][];
export declare let JoeKuoD7initializers: number[][];
export declare let Kuo2initializers: number[][];
export declare let Kuo3initializers: number[][];
export declare let Kuoinitializers: number[][];
export declare let PrimitivePolynomials: number[][];
export declare let latticeA: number[];
export declare let latticeB: number[];
export declare let latticeC: number[];
export declare let latticeD: number[];
export declare let sabrabsprob: number[];

export declare class GenericEngine<
    ArgumentsType extends PricingEngine.Arguments, ResultsType extends
        PricingEngine.Results> extends PricingEngineObserver {
  getArguments(): ArgumentsType;
  getResults(): ResultsType;
  reset(): void;
  update(): void;
  _arguments: ArgumentsType;
  _results: ResultsType;
}

export declare function CenteredGrid(
    center: Real, dx: Real, steps: Size): Real[];
export declare function BoundedGrid(
    xMin: Real, xMax: Real, steps: Size): Real[];
export declare function BoundedLogGrid(
    xMin: Real, xMax: Real, steps: Size): Real[];

export declare class Handle<T extends Observable> implements
    NullaryFunction<Handle.Link<T>> {
  constructor(p?: T, registerAsObserver?: boolean);
  empty(): boolean;
  currentLink(): T;
  f(): Handle.Link<T>;
  protected _link: Handle.Link<T>;
}
export declare class RelinkableHandle<T extends Observable> extends Handle<T> {
  constructor(p?: T, registerAsObserver?: boolean);
  linkTo(h: T, registerAsObserver?: boolean): void;
}
export declare namespace Handle {
  class Link<T extends Observable> extends ObserverObservable {
    constructor(h: T, registerAsObserver: boolean);
    empty(): boolean;
    linkTo(h: T, registerAsObserver: boolean): void;
    currentLink(): T;
    update(): void;
    private _h;
    private _isObserver;
  }
}

export declare class Index extends Observable {
  name(): string;
  fixingCalendar(): Calendar;
  isValidFixingDate(fixingDate: Date): boolean;
  fixing(fixingDate: Date, forecastTodaysFixing?: boolean): Real;
  timeSeries(): TimeSeries<Real>;
  allowsNativeFixings(): boolean;
  addFixing(fixingDate: Date, fixing: Real, forceOverwrite?: boolean): void;
  addFixings1(t: TimeSeries<Real>, forceOverwrite?: boolean): void;
  addFixings2(
      d: Date[], dBegin: Size, dEnd: Size, v: Real[], vBegin: Size,
      forceOverwrite?: boolean): void;
  clearFixings(): void;
  checkNativeFixingsAllowed(): void;
}

export declare class Instrument extends LazyObject {
  init(): Instrument;
  setPricingEngine(e: PricingEngine): void;
  setupArguments(a: PricingEngine.Arguments): void;
  setupExpired(): void;
  calculate(): void;
  performCalculations(): void;
  fetchResults(r: PricingEngine.Results): void;
  NPV(): Real;
  errorEstimate(): Real;
  valuationDate(): Date;
  result(tag: string): any;
  additionalResults(): Map<string, any>;
  isExpired(): boolean;
  protected _NPV: Real;
  protected _errorEstimate: Real;
  protected _valuationDate: Date;
  protected _additionalResults: Map<string, any>;
  _engine: PricingEngine;
}
export declare namespace Instrument {
  class Results extends PricingEngine.Results {
    reset(): void;
    value: Real;
    errorEstimate: Real;
    valuationDate: Date;
    additionalResults: Map<string, any>;
  }
}

export declare class InterestRate implements NullaryFunction<Rate> {
  constructor(r: Rate, dc: DayCounter, comp: Compounding, freq: Frequency);
  f(): Rate;
  rate(): Rate;
  dayCounter(): DayCounter;
  compounding(): Compounding;
  toString(): string;
  frequency(): Frequency;
  discountFactor1(t: Time): Real;
  discountFactor2(d1: Date, d2: Date, refStart?: Date, refEnd?: Date):
      DiscountFactor;
  compoundFactor1(t: Time): Real;
  compoundFactor2(d1: Date, d2: Date, refStart?: Date, refEnd?: Date): Real;
  static impliedRate1(
      compound: Real, resultDC: DayCounter, comp: Compounding, freq: Frequency,
      t: Time): InterestRate;
  static impliedRate2(
      compound: Real, resultDC: DayCounter, comp: Compounding, freq: Frequency,
      d1: Date, d2: Date, refStart?: Date, refEnd?: Date): InterestRate;
  equivalentRate1(comp: Compounding, freq: Frequency, t: Time): InterestRate;
  equivalentRate2(
      resultDC: DayCounter, comp: Compounding, freq: Frequency, d1: Date,
      d2: Date, refStart?: Date, refEnd?: Date): InterestRate;
  private _r;
  private _dc;
  private _comp;
  private _freqMakesSense;
  private _freq;
}

export declare const M_E = 2.718281828459045;
export declare const M_LOG2E = 1.4426950408889634;
export declare const M_LOG10E = 0.4342944819032518;
export declare const M_IVLN10 = 0.4342944819032518;
export declare const M_LN2 = 0.6931471805599453;
export declare const M_LOG2_E = 0.6931471805599453;
export declare const M_LN10 = 2.302585092994046;
export declare const M_PI = 3.141592653589793;
export declare const M_TWOPI: number;
export declare const M_PI_2 = 1.5707963267948966;
export declare const M_PI_4 = 0.7853981633974483;
export declare const M_3PI_4 = 2.356194490192345;
export declare const M_SQRTPI = 1.772453850905516;
export declare const M_1_PI = 0.3183098861837907;
export declare const M_2_PI = 0.6366197723675814;
export declare const M_1_SQRTPI = 0.5641895835477563;
export declare const M_2_SQRTPI = 1.1283791670955126;
export declare const M_SQRT2 = 1.4142135623730951;
export declare const M_SQRT_2 = 0.7071067811865476;
export declare const M_SQRT1_2 = 0.7071067811865476;
export declare const M_LN2LO = 1.9082149292705877e-10;
export declare const M_LN2HI = 0.6931471803691238;
export declare const M_SQRT3 = 1.7320508075688772;
export declare const M_INVLN2 = 1.4426950408889634;

export declare function applyMixins(derivedCtor: any, baseCtors: any[]): void;

export declare class Money {
  init1(): Money;
  init2(currency: Currency, value: Decimal): Money;
  init3(value: Decimal, currency: Currency): Money;
  currency(): Currency;
  value(): Decimal;
  rounded(): Money;
  minus(): Money;
  mula(x: Decimal): Money;
  diva(x: Decimal): Money;
  adda(m: Money): Money;
  suba(m: Money): Money;
  readonly isDisposed: boolean;
  dispose(): void;
  toString(): string;
  static baseCurrency: Currency;
  static conversionType: Money.ConversionType;
  private _value;
  private _currency;
  private _isDisposed;
}
export declare namespace Money {
  enum ConversionType {
    NoConversion = 0,
    BaseCurrencyConversion = 1,
    AutomatedConversion = 2
  }
  function add(m1: Money, m2: Money): Money;
  function sub(m1: Money, m2: Money): Money;
  function mul(m: Money, x: Decimal): Money;
  function divx(m: Money, x: Decimal): Money;
  function div(m1: Money, m2: Money): Decimal;
  function equal(m1: Money, m2: Money): boolean;
  function notEqual(m1: Money, m2: Money): boolean;
  function lessThan(m1: Money, m2: Money): boolean;
  function greaterThan(m1: Money, m2: Money): boolean;
  function lessEqual(m1: Money, m2: Money): boolean;
  function greaterEqual(m1: Money, m2: Money): boolean;
  function close(m1: Money, m2: Money, n?: Size): boolean;
  function close_enough(m1: Money, m2: Money, n?: Size): boolean;
}

export declare class Lattice {
  constructor(timeGrid: TimeGrid);
  timeGrid(): TimeGrid;
  initialize(asset: DiscretizedAsset, time: Time): void;
  rollback(asset: DiscretizedAsset, to: Time): void;
  partialRollback(asset: DiscretizedAsset, to: Time): void;
  presentValue(asset: DiscretizedAsset): Real;
  grid(t: Time): Real[];
  _t: TimeGrid;
}

export interface UnaryOperator<X, Y> {
  minus?(x: X): Y;
  adda?(x: X): Y;
  suba?(x: X): Y;
  mula?(x: X): Y;
  diva?(x: X): Y;
}
export interface BinaryOperator<X, Y, Z> {
  add?(x: X, y: Y): Z;
  sub?(x: X, y: Y): Z;
  mul?(x: X, y: Y): Z;
  div?(x: X, y: Y): Z;
}

export declare class Option extends Instrument {
  oInit(payoff: Payoff, exercise: Exercise): Option;
  setupArguments(args: PricingEngine.Arguments): void;
  payoff(): Payoff;
  exercise(): Exercise;
  protected _payoff: Payoff;
  protected _exercise: Exercise;
}
export declare namespace Option {
  enum Type { Put = -1, Call = 1 }
  class Arguments extends PricingEngine.Arguments {
    validate(): void;
    payoff: Payoff;
    exercise: Exercise;
  }
  class Greeks extends PricingEngine.Results {
    reset(): void;
    delta: Real;
    gamma: Real;
    theta: Real;
    vega: Real;
    rho: Real;
    dividendRho: Real;
  }
  class MoreGreeks extends PricingEngine.Results {
    reset(): void;
    itmCashProbability: Real;
    deltaForward: Real;
    elasticity: Real;
    thetaPerDay: Real;
    strikeSensitivity: Real;
  }
}

export declare class Payoff implements UnaryFunction<Real, Real> {
  name(): string;
  description(): string;
  f(x: Real): Real;
  accept(v: AcyclicVisitor): void;
}

export declare namespace Position {
  enum Type { Long = 0, Short = 1 }
}

export declare enum PriceType {
  Bid = 0,
  Ask = 1,
  Last = 2,
  Close = 3,
  Mid = 4,
  MidEquivalent = 5,
  MidSafe = 6
}
export declare function midEquivalent(
    bid: Real, ask: Real, last: Real, close: Real): Real;
export declare function midSafe(bid: Real, ask: Real): Real;
export declare class IntervalPrice {
  constructor(open?: Real, close?: Real, high?: Real, low?: Real);
  open(): Real;
  close(): Real;
  high(): Real;
  low(): Real;
  value(t: IntervalPrice.Type): Real;
  setValue(value: Real, t: IntervalPrice.Type): void;
  setValues(open: Real, close: Real, high: Real, low: Real): void;
  static makeSeries(
      d: Date[], open: Real[], close: Real[], high: Real[],
      low: Real[]): TimeSeries<IntervalPrice>;
  static extractValues(ts: TimeSeries<IntervalPrice>, t: IntervalPrice.Type):
      Real[];
  static extractComponent(ts: TimeSeries<IntervalPrice>, t: IntervalPrice.Type):
      TimeSeries<Real>;
  private _open;
  private _close;
  private _high;
  private _low;
}
export declare namespace IntervalPrice {
  enum Type { Open = 0, Close = 1, High = 2, Low = 3 }
}

export declare class PricingEngine extends Observable {
  getArguments(): PricingEngine.Arguments;
  getResults(): PricingEngine.Results;
  reset(): void;
  calculate(): void;
}
export declare namespace PricingEngine {
  class Arguments {
    validate(): void;
    readonly isDisposed: boolean;
    dispose(): void;
    _isDisposed: boolean;
  }
  class Results {
    reset(): void;
    readonly isDisposed: boolean;
    dispose(): void;
    _isDisposed: boolean;
  }
}

export interface Prototype {
  prototype: any;
}

export declare const QL_MIN_INTEGER: number;
export declare const QL_MAX_INTEGER: number;
export declare const QL_MIN_REAL: number;
export declare const QL_MAX_REAL: number;
export declare const QL_MIN_POSITIVE_REAL: number;
export declare const DBL_MIN: number;
export declare const QL_EPSILON: number;
export declare const QL_NULL_INTEGER: number;
export declare const QL_NULL_REAL: number;
export declare const QL_NULL_DATE: Date;

export declare class Quote extends Observable {
  value(): Real;
  isValid(): boolean;
}

export declare class RebatedExercise extends Exercise {
  reInit1(
      exercise: Exercise, rebate?: Real, rebateSettlementDays?: Natural,
      rebatePaymentCalendar?: Calendar,
      rebatePaymentConvention?: BusinessDayConvention): RebatedExercise;
  reInit2(
      exercise: Exercise, rebates: Real[], rebateSettlementDays?: Natural,
      rebatePaymentCalendar?: Calendar,
      rebatePaymentConvention?: BusinessDayConvention): RebatedExercise;
  rebate1(index: Size): Real;
  rebatePaymentDate(index: Size): Date;
  rebate2(): Real[];
  private _rebates;
  private _rebateSettlementDays;
  private _rebatePaymentCalendar;
  private _rebatePaymentConvention;
}

export declare namespace Settings {
  class DateProxy extends ObservableValue<Date> implements
      NullaryFunction<Date> {
    constructor();
    f(): Date;
  }
  let evaluationDate: DateProxy;
  function anchorEvaluationDate(): void;
  function resetEvaluationDate(): void;
  let includeReferenceDateEvents: boolean;
  let includeTodaysCashFlows: boolean;
  let enforcesTodaysHistoricFixings: boolean;
  let QL_USE_INDEXED_COUPON: boolean;
  let QL_EXTRA_SAFETY_CHECKS: boolean;
  let QL_ARRAY_EXPRESSIONS: boolean;
  let QL_NEGATIVE_RATES: boolean;
}
export declare class SavedSettings {
  constructor();
  evaluationDate(): Date;
  includeReferenceDateEvents(): boolean;
  includeTodaysCashFlows(): boolean;
  enforcesTodaysHistoricFixings(): boolean;
  readonly isDisposed: boolean;
  dispose(): void;
  private _evaluationDate;
  private _includeReferenceDateEvents;
  private _includeTodaysCashFlows;
  private _enforcesTodaysHistoricFixings;
  private _QL_USE_INDEXED_COUPON;
  private _QL_EXTRA_SAFETY_CHECKS;
  private _QL_ARRAY_EXPRESSIONS;
  private _QL_NEGATIVE_RATES;
  private _isDisposed;
}

export declare class StochasticProcess extends ObserverObservable {
  init(disc: StochasticProcess.discretization): StochasticProcess;
  size(): Size;
  factors(): Size;
  initialValues(): Real[];
  drift1(t: Time, x: Real[]): Real[];
  diffusion1(t: Time, x: Real[]): Matrix;
  expectation1(t0: Time, x0: Real[], dt: Time): Real[];
  stdDeviation1(t0: Time, x0: Real[], dt: Time): Matrix;
  covariance(t0: Time, x0: Real[], dt: Time): Matrix;
  evolve1(t0: Time, x0: Real[], dt: Time, dw: Real[]): Real[];
  apply1(x0: Real[], dx: Real[]): Real[];
  time(d: Date): Time;
  update(): void;
  _discretization: StochasticProcess.discretization;
}
export declare namespace StochasticProcess {
  class discretization {
    drift1(p: StochasticProcess, t0: Time, x0: Real[], dt: Time): Real[];
    drift2(p: StochasticProcess1D, t0: Time, x0: Real, dt: Time): Real;
    diffusion1(p: StochasticProcess, t0: Time, x0: Real[], dt: Time): Matrix;
    diffusion2(p: StochasticProcess1D, t0: Time, x0: Real, dt: Time): Real;
    covariance(p: StochasticProcess, t0: Time, x0: Real[], dt: Time): Matrix;
    variance(p: StochasticProcess1D, t0: Time, x0: Real, dt: Time): Real;
  }
}
export declare class StochasticProcess1D extends StochasticProcess {
  init(disc: StochasticProcess.discretization): StochasticProcess1D;
  x0(): Real;
  drift2(t: Time, x: Real): Real;
  diffusion2(t: Time, x: Real): Real;
  expectation2(t0: Time, x0: Real, dt: Time): Real;
  stdDeviation2(t0: Time, x0: Real, dt: Time): Real;
  variance(t0: Time, x0: Real, dt: Time): Real;
  evolve2(t0: Time, x0: Real, dt: Time, dw: Real): Real;
  apply2(x0: Real, dx: Real): Real;
  size(): Size;
  initialValues(): Real[];
  drift1(t: Time, x: Real[]): Real[];
  diffusion1(t: Time, x: Real[]): Matrix;
  expectation1(t0: Time, x0: Real[], dt: Time): Real[];
  stdDeviation1(t0: Time, x0: Real[], dt: Time): Matrix;
  covariance(t0: Time, x0: Real[], dt: Time): Matrix;
  evolve1(t0: Time, x0: Real[], dt: Time, dw: Real[]): Real[];
  apply1(x0: Real[], dx: Real[]): Real[];
}

export declare class TermStructure extends ObserverObservableExtrapolator {
  constructor();
  tsInit1(dc?: DayCounter): TermStructure;
  tsInit2(referenceDate: Date, calendar?: Calendar, dc?: DayCounter):
      TermStructure;
  tsInit3(settlementDays: Natural, calendar: Calendar, dc?: DayCounter):
      TermStructure;
  dayCounter(): DayCounter;
  timeFromReference(d: Date): Time;
  maxDate(): Date;
  maxTime(): Time;
  referenceDate(): Date;
  calendar(): Calendar;
  settlementDays(): Natural;
  update(): void;
  checkRange1(d: Date, extrapolate: boolean): void;
  checkRange2(t: Time, extrapolate: boolean): void;
  _moving: boolean;
  _updated: boolean;
  _calendar: Calendar;
  _referenceDate: Date;
  _settlementDays: Natural;
  _dayCounter: DayCounter;
}

export declare class TimeGrid {
  init1(end: Time, steps: Size): TimeGrid;
  init2(times: Time[], begin: Size, end: Size): TimeGrid;
  init3(times: Time[], begin: Size, end: Size, steps: Size): TimeGrid;
  index(t: Time): Size;
  closestIndex(t: Time): Size;
  closestTime(t: Time): Time;
  mandatoryTimes(): Time[];
  dt(i: Size): Time;
  at(i: Size): Time;
  size(): Size;
  empty(): boolean;
  front(): Time;
  back(): Time;
  times(): Time[];
  readonly isDisposed: boolean;
  dispose(): void;
  private _times;
  private _dt;
  private _mandatoryTimes;
  private _isDisposed;
}

export declare class TimeSeries<T> {
  init1(d: Date[], v: T[]): TimeSeries<T>;
  init2(firstDate: Date, v: T[]): TimeSeries<T>;
  get(d: Date): T;
  set(d: Date, v: T): void;
  at(i: Size): [Date, T];
  sort(asc?: boolean): void;
  reverse(): void;
  firstDate(): Date;
  lastDate(): Date;
  first(): [Date, T];
  last(): [Date, T];
  size(): Size;
  empty(): boolean;
  dates(): Date[];
  values(): T[];
  private _values;
  private _reverse;
}

export declare type Real = number;
export declare type Reals = Float64Array;
export declare type Natural = number;
export declare type Naturals = Uint16Array;
export declare type BigNatural = number;
export declare type BigNaturals = Uint32Array;
export declare type BigInteger = number;
export declare type BigIntegers = Int32Array;
export declare type Decimal = number;
export declare type Decimals = Float32Array;
export declare type Size = number;
export declare type Sizes = Uint16Array;
export declare type Time = number;
export declare type Times = Float64Array;
export declare type DiscountFactor = number;
export declare type DiscountFactors = Float32Array;
export declare type Rate = number;
export declare type Rates = Float32Array;
export declare type Spread = number;
export declare type Spreads = Float32Array;
export declare type Volatility = number;
export declare type Volatilities = Float32Array;
export declare type Probability = number;
export declare type Probabilities = Float32Array;
export declare type Integer = number;
export declare type Integers = Int32Array;

declare const version = '1.0.0';
export {version};

export declare class LocalVolatilityEstimator<T> {
  calculate1(quoteSeries: TimeSeries<T>): void;
  readonly isDisposed: boolean;
  dispose(): void;
  private _isDisposed;
}
export declare class VolatilityCompositor {
  calculate1(quoteSeries: TimeSeries<Volatility>): void;
  calibrate1(volatilitySeries: TimeSeries<Volatility>): void;
  readonly isDisposed: boolean;
  dispose(): void;
  private _isDisposed;
}

export declare class AverageBMACoupon extends FloatingRateCoupon {
  constructor(
      paymentDate: Date, nominal: Real, startDate: Date, endDate: Date,
      index: BMAIndex, gearing?: Real, spread?: Spread, refPeriodStart?: Date,
      refPeriodEnd?: Date, dayCounter?: DayCounter);
  fixingDate(): Date;
  fixingDates(): Date[];
  indexFixing(): Rate;
  indexFixings(): Rate[];
  convexityAdjustment(): Rate;
  accept(v: AcyclicVisitor): void;
  private _fixingSchedule;
}
export declare class AverageBMACouponPricer extends FloatingRateCouponPricer {
  initialize(coupon: FloatingRateCoupon): void;
  swapletRate(): Rate;
  swapletPrice(): Real;
  capletPrice(r: Rate): Real;
  capletRate(r: Rate): Real;
  floorletPrice(r: Rate): Real;
  floorletRate(r: Rate): Real;
  private _coupon;
}
export declare class AverageBMALeg implements NullaryFunction<Leg> {
  constructor(schedule: Schedule, index: BMAIndex);
  withNotionals1(notional: Real): AverageBMALeg;
  withNotionals2(notionals: Real[]): AverageBMALeg;
  withPaymentDayCounter(dayCounter: DayCounter): AverageBMALeg;
  withPaymentAdjustment(convention: BusinessDayConvention): AverageBMALeg;
  withGearings1(gearing: Real): AverageBMALeg;
  withGearings2(gearings: Real[]): AverageBMALeg;
  withSpreads1(spread: Spread): AverageBMALeg;
  withSpreads2(spreads: Spread[]): AverageBMALeg;
  f(): Leg;
  private _schedule;
  private _index;
  private _notionals;
  private _paymentDayCounter;
  private _paymentAdjustment;
  private _gearings;
  private _spreads;
}

export declare class CappedFlooredCoupon extends FloatingRateCoupon {
  constructor(underlying: FloatingRateCoupon, cap?: Rate, floor?: Rate);
  rate(): Rate;
  convexityAdjustment(): Rate;
  cap(): Rate;
  floor(): Rate;
  effectiveCap(): Rate;
  effectiveFloor(): Rate;
  isCapped(): boolean;
  isFloored(): boolean;
  setPricer(pricer: FloatingRateCouponPricer): void;
  underlying(): FloatingRateCoupon;
  update(): void;
  accept(v: AcyclicVisitor): void;
  protected _underlying: FloatingRateCoupon;
  protected _isCapped: boolean;
  protected _isFloored: boolean;
  protected _cap: Rate;
  protected _floor: Rate;
}
export declare class CappedFlooredIborCoupon extends CappedFlooredCoupon {
  constructor(
      paymentDate: Date, nominal: Real, startDate: Date, endDate: Date,
      fixingDays: Natural, index: IborIndex, gearing?: Real, spread?: Spread,
      cap?: Rate, floor?: Rate, refPeriodStart?: Date, refPeriodEnd?: Date,
      dayCounter?: DayCounter, isInArrears?: boolean);
  accept(v: AcyclicVisitor): void;
}
export declare class CappedFlooredCmsCoupon extends CappedFlooredCoupon {
  constructor(
      paymentDate: Date, nominal: Real, startDate: Date, endDate: Date,
      fixingDays: Natural, index: SwapIndex, gearing?: Real, spread?: Spread,
      cap?: Rate, floor?: Rate, refPeriodStart?: Date, refPeriodEnd?: Date,
      dayCounter?: DayCounter, isInArrears?: boolean);
  accept(v: AcyclicVisitor): void;
}

export declare class CappedFlooredYoYInflationCoupon extends
    YoYInflationCoupon {
  cfyoyicInit1(underlying: YoYInflationCoupon, cap?: Rate, floor?: Rate):
      CappedFlooredYoYInflationCoupon;
  cfyoyicInit2(
      paymentDate: Date, nominal: Real, startDate: Date, endDate: Date,
      fixingDays: Natural, index: YoYInflationIndex, observationLag: Period,
      dayCounter: DayCounter, gearing?: Real, spread?: Spread, cap?: Rate,
      floor?: Rate, refPeriodStart?: Date,
      refPeriodEnd?: Date): CappedFlooredYoYInflationCoupon;
  rate(): Rate;
  cap(): Rate;
  floor(): Rate;
  effectiveCap(): Rate;
  effectiveFloor(): Rate;
  isCapped(): boolean;
  isFloored(): boolean;
  setPricer(pricer: YoYInflationCouponPricer): void;
  update(): void;
  accept(v: AcyclicVisitor): void;
  protected setCommon(cap: Rate, floor: Rate): void;
  protected _underlying: YoYInflationCoupon;
  protected _isFloored: boolean;
  protected _isCapped: boolean;
  protected _cap: Rate;
  protected _floor: Rate;
}

export declare class CashFlows {
  static startDate(leg: Leg): Date;
  static maturityDate(leg: Leg): Date;
  static isExpired(
      leg: Leg, includeSettlementDateFlows: boolean,
      settlementDate: Date): boolean;
  static previousCashFlow1(
      leg: Leg, includeSettlementDateFlows: boolean,
      settlementDate?: Date): CashFlow;
  static previousCashFlow2(
      leg: Leg, includeSettlementDateFlows: boolean,
      settlementDate?: Date): Size;
  static nextCashFlow1(
      leg: Leg, includeSettlementDateFlows: boolean,
      settlementDate?: Date): CashFlow;
  static nextCashFlow2(
      leg: Leg, includeSettlementDateFlows: boolean,
      settlementDate?: Date): Size;
  static previousCashFlowDate(
      leg: Leg, includeSettlementDateFlows: boolean,
      settlementDate?: Date): Date;
  static nextCashFlowDate(
      leg: Leg, includeSettlementDateFlows: boolean,
      settlementDate?: Date): Date;
  static previousCashFlowAmount(
      leg: Leg, includeSettlementDateFlows: boolean,
      settlementDate?: Date): Real;
  static nextCashFlowAmount(
      leg: Leg, includeSettlementDateFlows: boolean,
      settlementDate?: Date): Real;
  static previousCouponRate(
      leg: Leg, includeSettlementDateFlows: boolean,
      settlementDate?: Date): Rate;
  static nextCouponRate(
      leg: Leg, includeSettlementDateFlows: boolean,
      settlementDate?: Date): Rate;
  static nominal(
      leg: Leg, includeSettlementDateFlows: boolean,
      settlementDate?: Date): Real;
  static accrualStartDate(
      leg: Leg, includeSettlementDateFlows: boolean,
      settlementDate?: Date): Date;
  static accrualEndDate(
      leg: Leg, includeSettlementDateFlows: boolean,
      settlementDate?: Date): Date;
  static referencePeriodStart(
      leg: Leg, includeSettlementDateFlows: boolean,
      settlementDate?: Date): Date;
  static referencePeriodEnd(
      leg: Leg, includeSettlementDateFlows: boolean,
      settlementDate?: Date): Date;
  static accrualPeriod(
      leg: Leg, includeSettlementDateFlows: boolean,
      settlementDate?: Date): Time;
  static accrualDays(
      leg: Leg, includeSettlementDateFlows: boolean,
      settlementDate?: Date): Integer;
  static accruedPeriod(
      leg: Leg, includeSettlementDateFlows: boolean,
      settlementDate?: Date): Time;
  static accruedDays(
      leg: Leg, includeSettlementDateFlows: boolean,
      settlementDate?: Date): Integer;
  static accruedAmount(
      leg: Leg, includeSettlementDateFlows: boolean,
      settlementDate?: Date): Real;
  static bps1(
      leg: Leg, discountCurve: YieldTermStructure,
      includeSettlementDateFlows: boolean, settlementDate?: Date,
      npvDate?: Date): Real;
  static bps2(
      leg: Leg, y: InterestRate, includeSettlementDateFlows: boolean,
      settlementDate?: Date, npvDate?: Date): Real;
  static bps3(
      leg: Leg, y: Rate, dc: DayCounter, comp: Compounding, freq: Frequency,
      includeSettlementDateFlows: boolean, settlementDate?: Date,
      npvDate?: Date): Real;
  static npv1(
      leg: Leg, discountCurve: YieldTermStructure,
      includeSettlementDateFlows: boolean, settlementDate?: Date,
      npvDate?: Date): number;
  static npv2(
      leg: Leg, y: InterestRate, includeSettlementDateFlows: boolean,
      settlementDate?: Date, npvDate?: Date): Real;
  static npv3(
      leg: Leg, y: Rate, dc: DayCounter, comp: Compounding, freq: Frequency,
      includeSettlementDateFlows: boolean, settlementDate?: Date,
      npvDate?: Date): Real;
  static npv4(
      leg: Leg, discountCurve: YieldTermStructure, zSpread: Spread,
      dc: DayCounter, comp: Compounding, freq: Frequency,
      includeSettlementDateFlows: boolean, settlementDate?: Date,
      npvDate?: Date): number;
  static npvbps(
      leg: Leg, discountCurve: YieldTermStructure,
      includeSettlementDateFlows: boolean, settlementDate: Date, npvDate: Date,
      ref: CashFlows.byRef): void;
  static atmRate(
      leg: Leg, discountCurve: YieldTermStructure,
      includeSettlementDateFlows: boolean, settlementDate?: Date,
      npvDate?: Date, targetNpv?: Real): Rate;
  static yield1(
      leg: Leg, npv: Real, dc: DayCounter, comp: Compounding, freq: Frequency,
      includeSettlementDateFlows: boolean, settlementDate?: Date,
      npvDate?: Date, accuracy?: Real, maxIterations?: Size,
      guess?: Rate): Rate;
  static yield2(
      solver: ISolver1D, leg: Leg, npv: Real, dc: DayCounter, comp: Compounding,
      freq: Frequency, includeSettlementDateFlows: boolean,
      settlementDate?: Date, npvDate?: Date, accuracy?: Real,
      maxIterations?: Size, guess?: Rate): Rate;
  static duration1(
      leg: Leg, rate: InterestRate, type: Duration.Type,
      includeSettlementDateFlows: boolean, settlementDate?: Date,
      npvDate?: Date): Time;
  static duration2(
      leg: Leg, y: Rate, dc: DayCounter, comp: Compounding, freq: Frequency,
      type: Duration.Type, includeSettlementDateFlows: boolean,
      settlementDate?: Date, npvDate?: Date): Time;
  static convexity1(
      leg: Leg, y: InterestRate, includeSettlementDateFlows: boolean,
      settlementDate?: Date, npvDate?: Date): number;
  static convexity2(
      leg: Leg, y: Rate, dc: DayCounter, comp: Compounding, freq: Frequency,
      includeSettlementDateFlows: boolean, settlementDate?: Date,
      npvDate?: Date): number;
  static basisPointValue1(
      leg: Leg, y: InterestRate, includeSettlementDateFlows: boolean,
      settlementDate?: Date, npvDate?: Date): number;
  static basisPointValue2(
      leg: Leg, y: Rate, dc: DayCounter, comp: Compounding, freq: Frequency,
      includeSettlementDateFlows: boolean, settlementDate?: Date,
      npvDate?: Date): number;
  static yieldValueBasisPoint1(
      leg: Leg, y: InterestRate, includeSettlementDateFlows: boolean,
      settlementDate?: Date, npvDate?: Date): number;
  static yieldValueBasisPoint2(
      leg: Leg, y: Rate, dc: DayCounter, comp: Compounding, freq: Frequency,
      includeSettlementDateFlows: boolean, settlementDate?: Date,
      npvDate?: Date): number;
  static zSpread1(
      leg: Leg, npv: Real, discount: YieldTermStructure, dayCounter: DayCounter,
      compounding: Compounding, frequency: Frequency,
      includeSettlementDateFlows: boolean, settlementDate: Date, npvDate: Date,
      accuracy: Real, maxIterations: Size, guess: Rate): Spread;
  static zSpread2(
      leg: Leg, d: YieldTermStructure, npv: Real, dc: DayCounter,
      comp: Compounding, freq: Frequency, includeSettlementDateFlows: boolean,
      settlementDate?: Date, npvDate?: Date, accuracy?: Real,
      maxIterations?: Size, guess?: Rate): Spread;
}
export declare namespace CashFlows {
  interface byRef {
    npv: Real;
    bps: Real;
  }
  class IrrFinder implements UnaryFunction<Rate, Real> {
    constructor(
        leg: Leg, npv: Real, dayCounter: DayCounter, comp: Compounding,
        freq: Frequency, includeSettlementDateFlows: boolean,
        settlementDate: Date, npvDate: Date);
    f(y: Rate): Real;
    d(y: Rate): Real;
    private checkSign;
    private _leg;
    private _npv;
    private _dayCounter;
    private _compounding;
    private _frequency;
    private _includeSettlementDateFlows;
    private _settlementDate;
    private _npvDate;
  }
}

export declare function effectiveFixedRate(
    spreads: Spread[], caps: Rate[], floors: Rate[], i: Size): Rate;
export declare function noOption(
    caps: Rate[], floors: Rate[], i: Size): boolean;
export declare function FloatingLeg(
    schedule: Schedule, nominals: Real[],
    index: IborIndex|SwapIndex|SwapSpreadIndex, paymentDayCounter: DayCounter,
    paymentAdj: BusinessDayConvention, fixingDays: Natural[], gearings: Real[],
    spreads: Spread[], caps: Rate[], floors: Rate[], isInArrears: boolean,
    isZero: boolean, paymentLag?: Natural, paymentCalendar?: Calendar): Leg;
export declare function FloatingDigitalLeg(
    schedule: Schedule, nominals: Real[], index: InterestRateIndex,
    paymentDayCounter: DayCounter, paymentAdj: BusinessDayConvention,
    fixingDays: Natural[], gearings: Real[], spreads: Spread[],
    isInArrears: boolean, callStrikes: Rate[], callPosition: Position.Type,
    isCallATMIncluded: boolean, callDigitalPayoffs: Rate[], putStrikes: Rate[],
    putPosition: Position.Type, isPutATMIncluded: boolean,
    putDigitalPayoffs: Rate[], replication: DigitalReplication): Leg;

export declare class CmsCoupon extends FloatingRateCoupon {
  constructor(
      paymentDate: Date, nominal: Real, startDate: Date, endDate: Date,
      fixingDays: Natural, swapIndex: SwapIndex, gearing?: Real,
      spread?: Spread, refPeriodStart?: Date, refPeriodEnd?: Date,
      dayCounter?: DayCounter, isInArrears?: boolean);
  swapIndex(): SwapIndex;
  accept(v: AcyclicVisitor): void;
  private _swapIndex;
}
export declare class CmsLeg implements NullaryFunction<Leg> {
  constructor(schedule: Schedule, swapIndex: SwapIndex);
  withNotionals1(notional: Real): CmsLeg;
  withNotionals2(notionals: Real[]): CmsLeg;
  withPaymentDayCounter(dayCounter: DayCounter): CmsLeg;
  withPaymentAdjustment(convention: BusinessDayConvention): CmsLeg;
  withFixingDays1(fixingDays: Natural): CmsLeg;
  withFixingDays2(fixingDays: Natural[]): CmsLeg;
  withGearings1(gearing: Real): CmsLeg;
  withGearings2(gearings: Real[]): CmsLeg;
  withSpreads1(spread: Spread): CmsLeg;
  withSpreads2(spreads: Spread[]): CmsLeg;
  withCaps1(cap: Rate): CmsLeg;
  withCaps2(caps: Rate[]): CmsLeg;
  withFloors1(floor: Rate): CmsLeg;
  withFloors2(floors: Rate[]): CmsLeg;
  inArrears(flag?: boolean): CmsLeg;
  withZeroPayments(flag?: boolean): CmsLeg;
  f(): Leg;
  private _schedule;
  private _swapIndex;
  private _notionals;
  private _paymentDayCounter;
  private _paymentAdjustment;
  private _fixingDays;
  private _gearings;
  private _spreads;
  private _caps;
  private _floors;
  private _inArrears;
  private _zeroPayments;
}

export declare class VanillaOptionPricer implements
    TernaryFunction<Real, Option.Type, Real, Real> {
  f(strike: Real, optionType: Option.Type, deflator: Real): Real;
}
export declare class BlackVanillaOptionPricer extends VanillaOptionPricer {
  constructor(
      forwardValue: Rate, expiryDate: Date, swapTenor: Period,
      volatilityStructure: SwaptionVolatilityStructure);
  f(strike: Real, optionType: Option.Type, deflator: Real): Real;
  private _forwardValue;
  private _expiryDate;
  private _swapTenor;
  private _volatilityStructure;
  private _smile;
}
export declare class GFunction implements UnaryFunction<Real, Real> {
  f(x: Real): Real;
  firstDerivative(x: Real): Real;
  secondDerivative(x: Real): Real;
}
export declare class GFunctionFactory {
  static newGFunctionStandard(q: Size, delta: Real, swapLength: Size):
      GFunction;
  static newGFunctionExactYield(coupon: CmsCoupon): GFunction;
  static newGFunctionWithShifts(
      coupon: CmsCoupon, meanReversion: Handle<Quote>): GFunction;
}
export declare namespace GFunctionFactory {
  enum YieldCurveModel {
    Standard = 0,
    ExactYield = 1,
    ParallelShifts = 2,
    NonParallelShifts = 3
  }
  class GFunctionStandard extends GFunction {
    constructor(q: Size, delta: Real, swapLength: Size);
    f(x: Real): Real;
    firstDerivative(x: Real): Real;
    secondDerivative(x: Real): Real;
    protected _q: Integer;
    protected _delta: Real;
    protected _swapLength: Size;
  }
  class GFunctionExactYield extends GFunction {
    constructor(coupon: CmsCoupon);
    f(x: Real): Real;
    firstDerivative(x: Real): Real;
    secondDerivative(x: Real): Real;
    protected _delta: Real;
    protected _accruals: Time[];
  }
  class GFunctionWithShifts extends GFunction {
    constructor(coupon: CmsCoupon, meanReversion: Handle<Quote>);
    f(Rs: Real): Real;
    firstDerivative(Rs: Real): Real;
    secondDerivative(Rs: Real): Real;
    shapeOfShift(s: Real): Real;
    calibrationOfShift(Rs: Real): Real;
    functionZ(x: Real): Real;
    derRs_derX(x: Real): Real;
    derZ_derX(x: Real): Real;
    der2Rs_derX2(x: Real): Real;
    der2Z_derX2(x: Real): Real;
    _swapStartTime: Time;
    _shapedPaymentTime: Time;
    _shapedSwapPaymentTimes: Time[];
    _accruals: Time[];
    _swapPaymentDiscounts: Real[];
    _discountAtStart: Real;
    _discountRatio: Real;
    _swapRateValue: Real;
    _meanReversion: Handle<Quote>;
    _calibratedShift: Real;
    _tmpRs: Real;
    _accuracy: Real;
    _objectiveFunction: GFunctionWithShifts.ObjectiveFunction;
  }
  namespace GFunctionWithShifts {
    class ObjectiveFunction implements UnaryFunction<Real, Real> {
      constructor(o: GFunctionWithShifts, Rs: Real);
      f(x: Real): Real;
      d(x: Real): Real;
      setSwapRateValue(x: Real): void;
      gFunctionWithShifts(): GFunctionWithShifts;
      _o: GFunctionWithShifts;
      _Rs: Real;
      _derivative: Real;
    }
  }
}
export declare class HaganPricer extends CmsCouponPricerMeanRevertingPricer {
  constructor(
      swaptionVol: Handle<SwaptionVolatilityStructure>,
      modelOfYieldCurve: GFunctionFactory.YieldCurveModel,
      meanReversion: Handle<Quote>);
  swapletPrice(): Real;
  swapletRate(): Rate;
  capletPrice(effectiveCap: Rate): Real;
  capletRate(effectiveCap: Rate): Rate;
  floorletPrice(effectiveFloor: Rate): Real;
  floorletRate(effectiveFloor: Rate): Rate;
  meanReversion(): Real;
  setMeanReversion(meanReversion: Handle<Quote>): void;
  initialize(coupon: FloatingRateCoupon): void;
  protected optionletPrice(optionType: Option.Type, strike: Real): Real;
  protected _rateCurve: YieldTermStructure;
  protected _modelOfYieldCurve: GFunctionFactory.YieldCurveModel;
  protected _gFunction: GFunction;
  protected _coupon: CmsCoupon;
  protected _paymentDate: Date;
  protected _fixingDate: Date;
  protected _swapRateValue: Rate;
  protected _discount: DiscountFactor;
  protected _annuity: Real;
  protected _gearing: Real;
  protected _spread: Spread;
  protected _spreadLegValue: Real;
  protected _cutoffForCaplet: Rate;
  protected _cutoffForFloorlet: Rate;
  protected _meanReversion: Handle<Quote>;
  protected _swapTenor: Period;
  protected _vanillaOptionPricer: VanillaOptionPricer;
}
export declare class NumericHaganPricer extends HaganPricer {
  constructor(
      swaptionVol: Handle<SwaptionVolatilityStructure>,
      modelOfYieldCurve: GFunctionFactory.YieldCurveModel,
      meanReversion: Handle<Quote>, lowerLimit?: Rate, upperLimit?: Rate,
      precision?: Real, hardUpperLimit?: Real);
  upperLimit(): Real;
  stdDeviations(): Real;
  integrate(a: Real, b: Real, integrand: NumericHaganPricer.ConundrumIntegrand):
      Real;
  optionletPrice(optionType: Option.Type, strike: Rate): Real;
  swapletPrice(): Real;
  resetUpperLimit(stdDeviationsForUpperLimit: Real): Real;
  refineIntegration(
      integralValue: Real,
      integrand: NumericHaganPricer.ConundrumIntegrand): Real;
  private _upperLimit;
  private _stdDeviationsForUpperLimit;
  private _lowerLimit;
  private _requiredStdDeviations;
  private _precision;
  private _refiningIntegrationTolerance;
  private _hardUpperLimit;
}
export declare namespace NumericHaganPricer {
  class Function implements UnaryFunction<Real, Real> {
    f(x: Real): Real;
  }
  class ConundrumIntegrand extends Function {
    constructor(
        o: VanillaOptionPricer, rateCurve: YieldTermStructure,
        gFunction: GFunction, fixingDate: Date, paymentDate: Date,
        annuity: Real, forwardValue: Real, strike: Real,
        optionType: Option.Type);
    f(x: Real): Real;
    functionF(x: Real): Real;
    firstDerivativeOfF(x: Real): Real;
    secondDerivativeOfF(x: Real): Real;
    protected strike(): Real;
    protected annuity(): Real;
    protected fixingDate(): Date;
    protected setStrike(strike: Real): void;
    protected _vanillaOptionPricer: VanillaOptionPricer;
    protected _forwardValue: Real;
    protected _annuity: Real;
    protected _fixingDate: Date;
    protected _paymentDate: Date;
    protected _strike: Real;
    protected _optionType: Option.Type;
    protected _gFunction: GFunction;
  }
}
export declare class AnalyticHaganPricer extends HaganPricer {
  constructor(
      swaptionVol: Handle<SwaptionVolatilityStructure>,
      modelOfYieldCurve: GFunctionFactory.YieldCurveModel,
      meanReversion: Handle<Quote>);
  optionletPrice(optionType: Option.Type, strike: Rate): Real;
  swapletPrice(): Real;
}

export declare class Coupon extends CashFlow {
  init(
      paymentDate: Date, nominal: Real, accrualStartDate: Date,
      accrualEndDate: Date, refPeriodStart?: Date, refPeriodEnd?: Date,
      exCouponDate?: Date): Coupon;
  date(): Date;
  exCouponDate(): Date;
  nominal(): Real;
  accrualStartDate(): Date;
  accrualEndDate(): Date;
  referencePeriodStart(): Date;
  referencePeriodEnd(): Date;
  accrualPeriod(): Time;
  accrualDays(): Integer;
  rate(): Rate;
  dayCounter(): DayCounter;
  accruedPeriod(d: Date): Time;
  accruedDays(d: Date): Integer;
  accruedAmount(d: Date): Real;
  accept(v: AcyclicVisitor): void;
  _paymentDate: Date;
  _nominal: Real;
  _accrualStartDate: Date;
  _accrualEndDate: Date;
  _refPeriodStart: Date;
  _refPeriodEnd: Date;
  _exCouponDate: Date;
  _accrualPeriod: Real;
}

export declare class FloatingRateCouponPricer extends ObserverObservable {
  swapletPrice(): Real;
  swapletRate(): Rate;
  capletPrice(effectiveCap: Rate): Real;
  capletRate(effectiveCap: Rate): Rate;
  floorletPrice(effectiveFloor: Rate): Real;
  floorletRate(effectiveFloor: Rate): Rate;
  initialize(coupon: FloatingRateCoupon): void;
  update(): void;
}
export declare class IborCouponPricer extends FloatingRateCouponPricer {
  constructor(v?: Handle<OptionletVolatilityStructure>);
  capletVolatility(): Handle<OptionletVolatilityStructure>;
  setCapletVolatility(v?: Handle<OptionletVolatilityStructure>): void;
  private _capletVol;
}
export declare class BlackIborCouponPricer extends IborCouponPricer {
  constructor(
      v?: Handle<OptionletVolatilityStructure>,
      timingAdjustment?: BlackIborCouponPricer.TimingAdjustment,
      correlation?: Handle<Quote>);
  initialize(coupon: FloatingRateCoupon): void;
  swapletPrice(): Real;
  swapletRate(): Rate;
  capletPrice(effectiveCap: Rate): Real;
  capletRate(effectiveCap: Rate): Rate;
  floorletPrice(effectiveFloor: Rate): Real;
  floorletRate(effectiveFloor: Rate): Rate;
  protected optionletPrice(optionType: Option.Type, effStrike: Real): Real;
  protected adjustedFixing(fixing?: Rate): Rate;
  protected _gearing: Real;
  protected _spread: Spread;
  protected _accrualPeriod: Time;
  protected _index: IborIndex;
  protected _discount: Real;
  protected _spreadLegValue: Real;
  protected _coupon: FloatingRateCoupon;
  private _timingAdjustment;
  private _correlation;
}
export declare namespace BlackIborCouponPricer {
  enum TimingAdjustment { Black76 = 0, BivariateLognormal = 1 }
}
export declare class CmsCouponPricer extends FloatingRateCouponPricer {
  init(v?: Handle<SwaptionVolatilityStructure>): CmsCouponPricer;
  swaptionVolatility(): Handle<SwaptionVolatilityStructure>;
  setSwaptionVolatility(v?: Handle<SwaptionVolatilityStructure>): void;
  _swaptionVol: Handle<SwaptionVolatilityStructure>;
}
export declare class MeanRevertingPricer {
  meanReversion(): Real;
  setMeanReversion(h: Handle<Quote>): void;
}
export declare class PricerSetter {
  constructor(pricer: FloatingRateCouponPricer);
  visit(c: any): void;
  private _pricer;
}
export declare function setCouponPricersFirstMatching(
    leg: Leg, p: FloatingRateCouponPricer[]): void;
export declare function setCouponPricer(
    leg: Leg, pricer: FloatingRateCouponPricer): void;
export declare function setCouponPricers1(
    leg: Leg, pricers: FloatingRateCouponPricer[]): void;
export declare function setCouponPricers2(
    leg: Leg, p1: FloatingRateCouponPricer, p2: FloatingRateCouponPricer,
    p: FloatingRateCouponPricer[]): void;
export declare function setCouponPricers3(
    leg: Leg, p1: FloatingRateCouponPricer, p2: FloatingRateCouponPricer,
    p3: FloatingRateCouponPricer, p: FloatingRateCouponPricer[]): void;
export declare function setCouponPricers4(
    leg: Leg, p1: FloatingRateCouponPricer, p2: FloatingRateCouponPricer,
    p3: FloatingRateCouponPricer, p4: FloatingRateCouponPricer,
    p: FloatingRateCouponPricer[]): void;

export declare class CPICoupon extends InflationCoupon {
  cpicInit(
      baseCPI: Real, paymentDate: Date, nominal: Real, startDate: Date,
      endDate: Date, fixingDays: Natural, zeroIndex: ZeroInflationIndex,
      observationLag: Period, observationInterpolation: CPI.InterpolationType,
      dayCounter: DayCounter, fixedRate: Real, spread?: Spread,
      refPeriodStart?: Date, refPeriodEnd?: Date,
      exCouponDate?: Date): CPICoupon;
  fixedRate(): Real;
  spread(): Spread;
  adjustedFixing(): Rate;
  indexFixing1(): Rate;
  baseCPI(): Rate;
  observationInterpolation(): CPI.InterpolationType;
  indexObservation(onDate: Date): Rate;
  cpiIndex(): ZeroInflationIndex;
  accept(v: AcyclicVisitor): void;
  protected checkPricerImpl(pricer: InflationCouponPricer): boolean;
  protected indexFixing2(d: Date): Rate;
  protected _baseCPI: Real;
  protected _fixedRate: Real;
  protected _spread: Spread;
  protected _observationInterpolation: CPI.InterpolationType;
}
export declare class CPICashFlow extends IndexedCashFlow {
  constructor(
      notional: Real, index: ZeroInflationIndex, baseDate: Date,
      baseFixing: Real, fixingDate: Date, paymentDate: Date,
      growthOnly: boolean, interpolation: CPI.InterpolationType,
      frequency?: Frequency);
  baseFixing(): Real;
  baseDate(): Date;
  interpolation(): CPI.InterpolationType;
  frequency(): Frequency;
  amount1(): Real;
  protected _baseFixing: Real;
  protected _interpolation: CPI.InterpolationType;
  protected _frequency: Frequency;
}
export declare class CPILeg implements NullaryFunction<Leg> {
  constructor(
      schedule: Schedule, index: ZeroInflationIndex, baseCPI: Real,
      observationLag: Period);
  withNotionals1(notional: Real): CPILeg;
  withNotionals2(notionals: Real[]): CPILeg;
  withFixedRates1(fixedRate: Real): CPILeg;
  withFixedRates2(fixedRates: Real[]): CPILeg;
  withPaymentDayCounter(dayCounter: DayCounter): CPILeg;
  withPaymentAdjustment(convention: BusinessDayConvention): CPILeg;
  withPaymentCalendar(cal: Calendar): CPILeg;
  withFixingDays1(fixingDays: Natural): CPILeg;
  withFixingDays2(fixingDays: Natural[]): CPILeg;
  withObservationInterpolation(interp: CPI.InterpolationType): CPILeg;
  withSubtractInflationNominal(growthOnly: boolean): CPILeg;
  withSpreads1(spread: Spread): CPILeg;
  withSpreads2(spreads: Spread[]): CPILeg;
  withCaps1(cap: Rate): CPILeg;
  withCaps2(caps: Rate[]): CPILeg;
  withFloors1(floor: Rate): CPILeg;
  withFloors2(floors: Rate[]): CPILeg;
  withExCouponPeriod(
      period: Period, cal: Calendar, convention: BusinessDayConvention,
      endOfMonth?: boolean): CPILeg;
  f(): Leg;
  private _schedule;
  private _index;
  private _baseCPI;
  private _observationLag;
  private _notionals;
  private _fixedRates;
  private _paymentDayCounter;
  private _paymentAdjustment;
  private _paymentCalendar;
  private _fixingDays;
  private _observationInterpolation;
  private _subtractInflationNominal;
  private _spreads;
  private _caps;
  private _floors;
  private _exCouponPeriod;
  private _exCouponCalendar;
  private _exCouponAdjustment;
  private _exCouponEndOfMonth;
}
export declare namespace CPI {
  enum InterpolationType { AsIndex = 0, Flat = 1, Linear = 2 }
}

export declare class CPICouponPricer extends InflationCouponPricer {
  constructor(capletVol?: Handle<CPIVolatilitySurface>);
  capletVolatility(): Handle<CPIVolatilitySurface>;
  setCapletVolatility(capletVol: Handle<CPIVolatilitySurface>): void;
  swapletPrice(): Real;
  swapletRate(): Rate;
  capletPrice(effectiveCap: Rate): Real;
  capletRate(effectiveCap: Rate): Rate;
  floorletPrice(effectiveFloor: Rate): Real;
  floorletRate(effectiveFloor: Rate): Rate;
  initialize(coupon: InflationCoupon): void;
  protected optionletPrice(optionType: Option.Type, effStrike: Real): Real;
  protected optionletPriceImp(
      optionType: Option.Type, strike: Real, forward: Real, stdDev: Real): Real;
  protected adjustedFixing(fixing?: Rate): Rate;
  protected _capletVol: Handle<CPIVolatilitySurface>;
  protected _coupon: CPICoupon;
  protected _gearing: Real;
  protected _spread: Spread;
  protected _discount: Real;
  protected _spreadLegValue: Real;
}

export declare class DigitalCmsCoupon extends DigitalCoupon {
  constructor(
      underlying: CmsCoupon, callStrike?: Rate, callPosition?: Position.Type,
      isCallATMIncluded?: boolean, callDigitalPayoff?: Rate, putStrike?: Rate,
      putPosition?: Position.Type, isPutATMIncluded?: boolean,
      putDigitalPayoff?: Rate, replication?: DigitalReplication);
  accept(v: AcyclicVisitor): void;
}
export declare class DigitalCmsLeg implements NullaryFunction<Leg> {
  constructor(schedule: Schedule, index: SwapIndex);
  withNotionals1(notional: Real): DigitalCmsLeg;
  withNotionals2(notionals: Real[]): DigitalCmsLeg;
  withPaymentDayCounter(dayCounter: DayCounter): DigitalCmsLeg;
  withPaymentAdjustment(convention: BusinessDayConvention): DigitalCmsLeg;
  withFixingDays1(fixingDays: Natural): DigitalCmsLeg;
  withFixingDays2(fixingDays: Natural[]): DigitalCmsLeg;
  withGearings1(gearing: Real): DigitalCmsLeg;
  withGearings2(gearings: Real[]): DigitalCmsLeg;
  withSpreads1(spread: Spread): DigitalCmsLeg;
  withSpreads2(spreads: Spread[]): DigitalCmsLeg;
  inArrears(flag?: boolean): DigitalCmsLeg;
  withCallStrikes1(strike: Rate): DigitalCmsLeg;
  withCallStrikes2(strikes: Rate[]): DigitalCmsLeg;
  withLongCallOption(type: Position.Type): DigitalCmsLeg;
  withCallATM(flag?: boolean): DigitalCmsLeg;
  withCallPayoffs1(payoff: Rate): DigitalCmsLeg;
  withCallPayoffs2(payoffs: Rate[]): DigitalCmsLeg;
  withPutStrikes1(strike: Rate): DigitalCmsLeg;
  withPutStrikes2(strikes: Rate[]): DigitalCmsLeg;
  withLongPutOption(type: Position.Type): DigitalCmsLeg;
  withPutATM(flag?: boolean): DigitalCmsLeg;
  withPutPayoffs1(payoff: Rate): DigitalCmsLeg;
  withPutPayoffs2(payoffs: Rate[]): DigitalCmsLeg;
  withReplication(replication?: DigitalReplication): DigitalCmsLeg;
  f(): Leg;
  private _schedule;
  private _index;
  private _notionals;
  private _paymentDayCounter;
  private _paymentAdjustment;
  private _fixingDays;
  private _gearings;
  private _spreads;
  private _inArrears;
  private _callStrikes;
  private _callPayoffs;
  private _longCallOption;
  private _callATM;
  private _putStrikes;
  private _putPayoffs;
  private _longPutOption;
  private _putATM;
  private _replication;
}

export declare class DigitalCoupon extends FloatingRateCoupon {
  constructor(
      underlying: FloatingRateCoupon, callStrike?: Rate,
      callPosition?: Position.Type, isCallATMIncluded?: boolean,
      callDigitalPayoff?: Rate, putStrike?: Rate, putPosition?: Position.Type,
      isPutATMIncluded?: boolean, putDigitalPayoff?: Rate,
      replication?: DigitalReplication);
  rate(): Rate;
  convexityAdjustment(): Rate;
  callStrike(): Rate;
  putStrike(): Rate;
  callDigitalPayoff(): Rate;
  putDigitalPayoff(): Rate;
  hasPut(): boolean;
  hasCall(): boolean;
  hasCollar(): boolean;
  isLongPut(): boolean;
  isLongCall(): boolean;
  underlying(): FloatingRateCoupon;
  callOptionRate(): Rate;
  putOptionRate(): Rate;
  update(): void;
  accept(v: AcyclicVisitor): void;
  setPricer(pricer: FloatingRateCouponPricer): void;
  private callPayoff;
  private putPayoff;
  protected _underlying: FloatingRateCoupon;
  protected _callStrike: Rate;
  protected _putStrike: Rate;
  protected _callCsi: Real;
  protected _putCsi: Real;
  protected _isCallATMIncluded: boolean;
  protected _isPutATMIncluded: boolean;
  protected _isCallCashOrNothing: boolean;
  protected _isPutCashOrNothing: boolean;
  protected _callDigitalPayoff: Rate;
  protected _putDigitalPayoff: Rate;
  protected _callLeftEps: Real;
  protected _callRightEps: Real;
  protected _putLeftEps: Real;
  protected _putRightEps: Real;
  protected _hasPutStrike: boolean;
  protected _hasCallStrike: boolean;
  protected _replicationType: Replication.Type;
}

export declare class DigitalIborCoupon extends DigitalCoupon {
  constructor(
      underlying: IborCoupon, callStrike?: Rate, callPosition?: Position.Type,
      isCallATMIncluded?: boolean, callDigitalPayoff?: Rate, putStrike?: Rate,
      putPosition?: Position.Type, isPutATMIncluded?: boolean,
      putDigitalPayoff?: Rate, replication?: DigitalReplication);
  accept(v: AcyclicVisitor): void;
}
export declare class DigitalIborLeg implements NullaryFunction<Leg> {
  constructor(schedule: Schedule, index: IborIndex);
  withNotionals1(notional: Real): DigitalIborLeg;
  withNotionals2(notionals: Real[]): DigitalIborLeg;
  withPaymentDayCounter(dayCounter: DayCounter): DigitalIborLeg;
  withPaymentAdjustment(convention: BusinessDayConvention): DigitalIborLeg;
  withFixingDays1(fixingDays: Natural): DigitalIborLeg;
  withFixingDays2(fixingDays: Natural[]): DigitalIborLeg;
  withGearings1(gearing: Real): DigitalIborLeg;
  withGearings2(gearings: Real[]): DigitalIborLeg;
  withSpreads1(spread: Spread): DigitalIborLeg;
  withSpreads2(spreads: Spread[]): DigitalIborLeg;
  inArrears(flag?: boolean): DigitalIborLeg;
  withCallStrikes1(strike: Rate): DigitalIborLeg;
  withCallStrikes2(strikes: Rate[]): DigitalIborLeg;
  withLongCallOption(type: Position.Type): DigitalIborLeg;
  withCallATM(flag?: boolean): DigitalIborLeg;
  withCallPayoffs1(payoff: Rate): DigitalIborLeg;
  withCallPayoffs2(payoffs: Rate[]): DigitalIborLeg;
  withPutStrikes1(strike: Rate): DigitalIborLeg;
  withPutStrikes2(strikes: Rate[]): DigitalIborLeg;
  withLongPutOption(type: Position.Type): DigitalIborLeg;
  withPutATM(flag?: boolean): DigitalIborLeg;
  withPutPayoffs1(payoff: Rate): DigitalIborLeg;
  withPutPayoffs2(payoffs: Rate[]): DigitalIborLeg;
  withReplication(replication?: DigitalReplication): DigitalIborLeg;
  f(): Leg;
  private _schedule;
  private _index;
  private _notionals;
  private _paymentDayCounter;
  private _paymentAdjustment;
  private _fixingDays;
  private _gearings;
  private _spreads;
  private _inArrears;
  private _callStrikes;
  private _callPayoffs;
  private _longCallOption;
  private _callATM;
  private _putStrikes;
  private _putPayoffs;
  private _longPutOption;
  private _putATM;
  private _replication;
}

export declare class Dividend extends CashFlow {
  constructor(date: Date);
  date(): Date;
  amount1(): Real;
  amount2(underlying: Real): Real;
  accept(v: AcyclicVisitor): void;
  protected _date: Date;
}
export declare class FixedDividend extends Dividend {
  constructor(amount: Real, date: Date);
  amount1(): Real;
  amount2(underlying: Real): Real;
  protected _amount: Real;
}
export declare class FractionalDividend extends Dividend {
  constructor(rate: Real, nominal: Real, date: Date);
  amount1(): Real;
  amount2(underlying: Real): Real;
  rate(): Real;
  nominal(): Real;
  protected _rate: Real;
  protected _nominal: Real;
}
export declare function DividendVector(
    dividendDates: Date[], dividends: Real[]): Dividend[];

export declare namespace Duration {
  enum Type { Simple = 0, Macaulay = 1, Modified = 2 }
}

export declare class FixedRateCoupon extends Coupon {
  frcInit1(
      paymentDate: Date, nominal: Real, rate: Rate, dayCounter: DayCounter,
      accrualStartDate: Date, accrualEndDate: Date, refPeriodStart?: Date,
      refPeriodEnd?: Date, exCouponDate?: Date): FixedRateCoupon;
  frcInit2(
      paymentDate: Date, nominal: Real, interestRate: InterestRate,
      accrualStartDate: Date, accrualEndDate: Date, refPeriodStart?: Date,
      refPeriodEnd?: Date, exCouponDate?: Date): FixedRateCoupon;
  amount1(): Real;
  rate(): Rate;
  interestRate(): InterestRate;
  dayCounter(): DayCounter;
  accruedAmount(d: Date): Real;
  accept(v: AcyclicVisitor): void;
  private _rate;
}
export declare class FixedRateLeg implements NullaryFunction<Leg> {
  constructor(schedule: Schedule);
  withNotionals1(notional: Real): FixedRateLeg;
  withNotionals2(notionals: Real[]): FixedRateLeg;
  withCouponRates1(
      rate: Rate, dc: DayCounter, comp?: Compounding,
      freq?: Frequency): FixedRateLeg;
  withCouponRates2(i: InterestRate): FixedRateLeg;
  withCouponRates3(
      rates: Rate[], dc: DayCounter, comp?: Compounding,
      freq?: Frequency): FixedRateLeg;
  withCouponRates4(interestRates: InterestRate[]): FixedRateLeg;
  withPaymentAdjustment(convention: BusinessDayConvention): FixedRateLeg;
  withFirstPeriodDayCounter(dayCounter: DayCounter): FixedRateLeg;
  withLastPeriodDayCounter(dayCounter: DayCounter): FixedRateLeg;
  withPaymentCalendar(cal: Calendar): FixedRateLeg;
  withPaymentLag(lag: Natural): FixedRateLeg;
  withExCouponPeriod(
      period: Period, cal: Calendar, convention: BusinessDayConvention,
      endOfMonth?: boolean): FixedRateLeg;
  f(): Leg;
  private _schedule;
  private _notionals;
  private _couponRates;
  private _firstPeriodDC;
  private _lastPeriodDC;
  private _paymentCalendar;
  private _paymentAdjustment;
  private _paymentLag;
  private _exCouponPeriod;
  private _exCouponCalendar;
  private _exCouponAdjustment;
  private _exCouponEndOfMonth;
}

export declare class FloatingRateCoupon extends CouponLazyObject {
  constructor(
      paymentDate: Date, nominal: Real, startDate: Date, endDate: Date,
      fixingDays: Natural, index: InterestRateIndex, gearing?: Real,
      spread?: Spread, refPeriodStart?: Date, refPeriodEnd?: Date,
      dayCounter?: DayCounter, isInArrears?: boolean);
  amount1(): Real;
  rate(): Rate;
  price(discountingCurve: Handle<YieldTermStructure>): Real;
  dayCounter(): DayCounter;
  accruedAmount(d: Date): Real;
  index(): InterestRateIndex;
  fixingDays(): Natural;
  fixingDate(): Date;
  gearing(): Real;
  spread(): Spread;
  indexFixing(): Rate;
  convexityAdjustment(): Rate;
  adjustedFixing(): Rate;
  isInArrears(): boolean;
  performCalculations(): void;
  accept(v: AcyclicVisitor): void;
  setPricer(pricer: FloatingRateCouponPricer): void;
  pricer(): FloatingRateCouponPricer;
  protected convexityAdjustmentImpl(fixing: Rate): Rate;
  protected _index: InterestRateIndex;
  protected _dayCounter: DayCounter;
  protected _fixingDays: Natural;
  protected _gearing: Real;
  protected _spread: Spread;
  protected _isInArrears: boolean;
  protected _pricer: FloatingRateCouponPricer;
  protected _swapletRate: Real;
}

export declare class IborCoupon extends FloatingRateCoupon {
  constructor(
      paymentDate: Date, nominal: Real, startDate: Date, endDate: Date,
      fixingDays: Natural, iborIndex: IborIndex, gearing?: Real,
      spread?: Spread, refPeriodStart?: Date, refPeriodEnd?: Date,
      dayCounter?: DayCounter, isInArrears?: boolean);
  iborIndex(): IborIndex;
  fixingEndDate(): Date;
  indexFixing(): Rate;
  accept(v: AcyclicVisitor): void;
  private _iborIndex;
  private _fixingDate;
  private _fixingValueDate;
  private _fixingEndDate;
  private _spanningTime;
}
export declare class IborLeg implements NullaryFunction<Leg> {
  constructor(schedule: Schedule, index: IborIndex);
  withNotionals1(notional: Real): IborLeg;
  withNotionals2(notionals: Real[]): IborLeg;
  withPaymentDayCounter(dayCounter: DayCounter): IborLeg;
  withPaymentAdjustment(convention: BusinessDayConvention): IborLeg;
  withPaymentLag(lag: Natural): IborLeg;
  withPaymentCalendar(cal: Calendar): IborLeg;
  withFixingDays1(fixingDays: Natural): IborLeg;
  withFixingDays2(fixingDays: Natural[]): IborLeg;
  withGearings1(gearing: Real): IborLeg;
  withGearings2(gearings: Real[]): IborLeg;
  withSpreads1(spread: Spread): IborLeg;
  withSpreads2(spreads: Spread[]): IborLeg;
  withCaps1(cap: Rate): IborLeg;
  withCaps2(caps: Rate[]): IborLeg;
  withFloors1(floor: Rate): IborLeg;
  withFloors2(floors: Rate[]): IborLeg;
  inArrears(flag?: boolean): IborLeg;
  withZeroPayments(flag?: boolean): IborLeg;
  f(): Leg;
  private _schedule;
  private _index;
  private _notionals;
  private _paymentDayCounter;
  private _paymentAdjustment;
  private _paymentLag;
  private _paymentCalendar;
  private _fixingDays;
  private _gearings;
  private _spreads;
  private _caps;
  private _floors;
  private _inArrears;
  private _zeroPayments;
}

export declare class IndexedCashFlow extends CashFlowObserver {
  constructor(
      notional: Real, index: Index, baseDate: Date, fixingDate: Date,
      paymentDate: Date, growthOnly?: boolean);
  date(): Date;
  notional(): Real;
  baseDate(): Date;
  fixingDate(): Date;
  index(): Index;
  growthOnly(): boolean;
  amount1(): Real;
  accept(v: AcyclicVisitor): void;
  update(): void;
  private _notional;
  private _index;
  private _baseDate;
  private _fixingDate;
  private _paymentDate;
  private _growthOnly;
}

export declare class InflationCoupon extends CouponObserver {
  icInit(
      paymentDate: Date, nominal: Real, startDate: Date, endDate: Date,
      fixingDays: Natural, index: InflationIndex, observationLag: Period,
      dayCounter: DayCounter, refPeriodStart?: Date, refPeriodEnd?: Date,
      exCouponDate?: Date): InflationCoupon;
  amount1(): Real;
  price(discountingCurve: Handle<YieldTermStructure>): Real;
  dayCounter(): DayCounter;
  accruedAmount(d: Date): Real;
  rate(): Rate;
  index(): InflationIndex;
  observationLag(): Period;
  fixingDays(): Natural;
  fixingDate(): Date;
  indexFixing(): Rate;
  update(): void;
  accept(v: AcyclicVisitor): void;
  setPricer(pricer: InflationCouponPricer): void;
  pricer(): InflationCouponPricer;
  protected checkPricerImpl(pricer: InflationCouponPricer): boolean;
  protected _pricer: InflationCouponPricer;
  protected _index: InflationIndex;
  protected _observationLag: Period;
  protected _dayCounter: DayCounter;
  protected _fixingDays: Natural;
}

export declare class InflationCouponPricer extends ObserverObservable {
  swapletPrice(): Real;
  swapletRate(): Rate;
  capletPrice(effectiveCap: Rate): Real;
  capletRate(effectiveCap: Rate): Rate;
  floorletPrice(effectiveFloor: Rate): Real;
  floorletRate(effectiveFloor: Rate): Rate;
  initialize(c: InflationCoupon): void;
  update(): void;
  protected _rateCurve: Handle<YieldTermStructure>;
  protected _paymentDate: Date;
}
export declare class YoYInflationCouponPricer extends InflationCouponPricer {
  constructor(capletVol?: Handle<YoYOptionletVolatilitySurface>);
  capletVolatility(): Handle<YoYOptionletVolatilitySurface>;
  setCapletVolatility(capletVol: Handle<YoYOptionletVolatilitySurface>): void;
  swapletPrice(): Real;
  swapletRate(): Rate;
  capletPrice(effectiveCap: Rate): Real;
  capletRate(effectiveCap: Rate): Rate;
  floorletPrice(effectiveFloor: Rate): Real;
  floorletRate(effectiveFloor: Rate): Rate;
  initialize(coupon: InflationCoupon): void;
  protected optionletPrice(optionType: Option.Type, effStrike: Real): Real;
  protected optionletPriceImp(
      type: Option.Type, strike: Real, forward: Real, stdDev: Real): Real;
  protected adjustedFixing(fixing?: Rate): Rate;
  protected _capletVol: Handle<YoYOptionletVolatilitySurface>;
  protected _coupon: YoYInflationCoupon;
  protected _gearing: Real;
  protected _spread: Spread;
  protected _discount: Real;
  protected _spreadLegValue: Real;
}
export declare class BlackYoYInflationCouponPricer extends
    YoYInflationCouponPricer {
  constructor(capletVol?: Handle<YoYOptionletVolatilitySurface>);
  protected optionletPriceImp(
      optionType: Option.Type, effStrike: Real, forward: Real,
      stdDev: Real): Real;
}
export declare class UnitDisplacedBlackYoYInflationCouponPricer extends
    YoYInflationCouponPricer {
  constructor(capletVol?: Handle<YoYOptionletVolatilitySurface>);
  protected optionletPriceImp(
      optionType: Option.Type, effStrike: Real, forward: Real,
      stdDev: Real): Real;
}
export declare class BachelierYoYInflationCouponPricer extends
    YoYInflationCouponPricer {
  constructor(capletVol?: Handle<YoYOptionletVolatilitySurface>);
  protected optionletPriceImp(
      optionType: Option.Type, effStrike: Real, forward: Real,
      stdDev: Real): Real;
}

export declare class LinearTsrPricer extends
    CmsCouponPricerMeanRevertingPricer {
  constructor(
      swaptionVol: Handle<SwaptionVolatilityStructure>,
      meanReversion: Handle<Quote>,
      couponDiscountCurve?: Handle<YieldTermStructure>,
      settings?: LinearTsrPricer.Settings, integrator?: Integrator);
  static defaultLowerBound: Real;
  static defaultUpperBound: Real;
  swapletRate(): Rate;
  capletPrice(effectiveCap: Rate): Real;
  capletRate(effectiveCap: Rate): Rate;
  floorletPrice(effectiveFloor: Rate): Real;
  floorletRate(effectiveFloor: Rate): Rate;
  swapletPrice(): Real;
  meanReversion(): Real;
  setMeanReversion(meanReversion: Handle<Quote>): void;
  GsrG(d: Date): Real;
  singularTerms(type: Option.Type, strike: Real): Real;
  integrand(strike: Real): Real;
  initialize(coupon: FloatingRateCoupon): void;
  optionletPrice(optionType: Option.Type, strike: Real): Real;
  strikeFromVegaRatio(
      ratio: Real, optionType: Option.Type, referenceStrike: Real): Real;
  strikeFromPrice(price: Real, optionType: Option.Type, referenceStrike: Real):
      Real;
  private _a;
  private _b;
  private _meanReversion;
  private _forwardCurve;
  private _discountCurve;
  private _couponDiscountCurve;
  private _coupon;
  private _today;
  private _paymentDate;
  private _fixingDate;
  private _gearing;
  private _spread;
  private _swapTenor;
  private _spreadLegValue;
  private _swapRateValue;
  private _couponDiscountRatio;
  private _annuity;
  private _swapIndex;
  private _swap;
  private _smileSection;
  private _settings;
  private _volDayCounter;
  private _integrator;
  private _adjustedLowerBound;
  private _adjustedUpperBound;
}
export declare namespace LinearTsrPricer {
  class Settings {
    withRateBound(lowerRateBound?: Real, upperRateBound?: Real): Settings;
    withVegaRatio1(vegaRatio?: Real): Settings;
    withVegaRatio2(vegaRatio: Real, lowerRateBound: Real): Settings;
    withVegaRatio3(vegaRatio: Real, lowerRateBound: Real, upperRateBound: Real):
        Settings;
    withPriceThreshold1(priceThreshold?: Real): Settings;
    withPriceThreshold2(priceThreshold: Real, lowerRateBound: Real): Settings;
    withPriceThreshold3(
        priceThreshold: Real, lowerRateBound: Real,
        upperRateBound: Real): Settings;
    withBSStdDevs1(stdDevs?: Real): Settings;
    withBSStdDevs2(stdDevs: Real, lowerRateBound: Real): Settings;
    withBSStdDevs3(stdDevs: Real, lowerRateBound: Real, upperRateBound: Real):
        Settings;
    _strategy: Settings.Strategy;
    _vegaRatio: Real;
    _priceThreshold: Real;
    _stdDevs: Real;
    _lowerRateBound: Real;
    _upperRateBound: Real;
    _defaultBounds: boolean;
  }
  namespace Settings {
    enum Strategy {
      RateBound = 0,
      VegaRatio = 1,
      PriceThreshold = 2,
      BSStdDevs = 3
    }
  }
}

export declare class OvernightIndexedCoupon extends FloatingRateCoupon {
  constructor(
      paymentDate: Date, nominal: Real, startDate: Date, endDate: Date,
      overnightIndex: OvernightIndex, gearing?: Rate, spread?: Spread,
      refPeriodStart?: Date, refPeriodEnd?: Date, dayCounter?: DayCounter,
      telescopicValueDates?: boolean);
  indexFixings(): Rate[];
  fixingDates(): Date[];
  valueDates(): Date[];
  dt(): Time[];
  accept(v: AcyclicVisitor): void;
  private _valueDates;
  private _fixingDates;
  private _fixings;
  private _n;
  private _dt;
}
export declare class OvernightLeg implements NullaryFunction<Leg> {
  constructor(schedule: Schedule, overnightIndex: OvernightIndex);
  withNotionals1(notional: Real): OvernightLeg;
  withNotionals2(notionals: Real[]): OvernightLeg;
  withPaymentDayCounter(dc: DayCounter): OvernightLeg;
  withPaymentAdjustment(convention: BusinessDayConvention): OvernightLeg;
  withPaymentCalendar(cal: Calendar): OvernightLeg;
  withPaymentLag(lag: Natural): OvernightLeg;
  withGearings1(gearing: Real): OvernightLeg;
  withGearings2(gearings: Real[]): OvernightLeg;
  withSpreads1(spread: Spread): OvernightLeg;
  withSpreads2(spreads: Spread[]): OvernightLeg;
  withTelescopicValueDates(telescopicValueDates: boolean): OvernightLeg;
  f(): Leg;
  private _schedule;
  private _overnightIndex;
  private _notionals;
  private _paymentDayCounter;
  private _paymentCalendar;
  private _paymentAdjustment;
  private _paymentLag;
  private _gearings;
  private _spreads;
  private _telescopicValueDates;
}
export declare class OvernightIndexedCouponPricer extends
    FloatingRateCouponPricer {
  initialize(coupon: FloatingRateCoupon): void;
  swapletRate(): Rate;
  swapletPrice(): Real;
  capletPrice(r: Rate): Real;
  capletRate(r: Rate): Real;
  floorletPrice(r: Rate): Real;
  floorletRate(r: Rate): Real;
  protected _coupon: OvernightIndexedCoupon;
}

export declare class RangeAccrualFloatersCoupon extends FloatingRateCoupon {
  constructor(
      paymentDate: Date, nominal: Real, index: IborIndex, startDate: Date,
      endDate: Date, fixingDays: Natural, dayCounter: DayCounter, gearing: Real,
      spread: Spread, refPeriodStart: Date, refPeriodEnd: Date,
      observationsSchedule: Schedule, lowerTrigger: Real, upperTrigger: Real);
  startTime(): Real;
  endTime(): Real;
  lowerTrigger(): Real;
  upperTrigger(): Real;
  observationsNo(): Size;
  observationDates(): Date[];
  observationTimes(): Real[];
  observationsSchedule(): Schedule;
  priceWithoutOptionality(discountCurve: Handle<YieldTermStructure>): Real;
  accept(v: AcyclicVisitor): void;
  private _startTime;
  private _endTime;
  private _observationsSchedule;
  private _observationDates;
  private _observationTimes;
  private _observationsNo;
  private _lowerTrigger;
  private _upperTrigger;
}
export declare class RangeAccrualPricer extends FloatingRateCouponPricer {
  swapletRate(): Rate;
  capletPrice(effectiveCap: Rate): Real;
  capletRate(effectiveCap: Rate): Real;
  floorletPrice(effectiveFloor: Rate): Real;
  floorletRate(effectiveFloor: Rate): Rate;
  initialize(coupon: FloatingRateCoupon): void;
  protected _coupon: RangeAccrualFloatersCoupon;
  protected _startTime: Real;
  protected _endTime: Real;
  protected _accrualFactor: Real;
  protected _observationTimeLags: Real[];
  protected _observationTimes: Real[];
  protected _initialValues: Real[];
  protected _observationsNo: Size;
  protected _lowerTrigger: Real;
  protected _upperTrigger: Real;
  protected _discount: Real;
  protected _gearing: Real;
  protected _spread: Spread;
  protected _spreadLegValue: Real;
}
export declare class RangeAccrualPricerByBgm extends RangeAccrualPricer {
  constructor(
      correlation: Real, smilesOnExpiry: SmileSection,
      smilesOnPayment: SmileSection, withSmile: boolean, byCallSpread: boolean);
  swapletPrice(): Real;
  protected drift(U: Real, lambdaS: Real, lambdaT: Real, correlation: Real):
      Real;
  protected derDriftDerLambdaS(
      U: Real, lambdaS: Real, lambdaT: Real, correlation: Real): Real;
  protected derDriftDerLambdaT(
      U: Real, lambdaS: Real, lambdaT: Real, correlation: Real): Real;
  protected lambda(U: Real, lambdaS: Real, lambdaT: Real): Real;
  protected derLambdaDerLambdaS(U: Real): Real;
  protected derLambdaDerLambdaT(U: Real): Real;
  protected driftsOverPeriod(
      U: Real, lambdaS: Real, lambdaT: Real, correlation: Real): Real[];
  protected lambdasOverPeriod(U: Real, lambdaS: Real, lambdaT: Real): Real[];
  protected digitalRangePrice(
      lowerTrigger: Real, upperTrigger: Real, initialValue: Real, expiry: Real,
      deflator: Real): Real;
  protected digitalPrice(
      strike: Real, initialValue: Real, expiry: Real, deflator: Real): Real;
  protected digitalPriceWithoutSmile(
      strike: Real, initialValue: Real, expiry: Real, deflator: Real): Real;
  protected digitalPriceWithSmile(
      strike: Real, initialValue: Real, expiry: Real, deflator: Real): Real;
  protected callSpreadPrice(
      previousForward: Real, nextForward: Real, previousStrike: Real,
      nextStrike: Real, deflator: Real, previousVariance: Real,
      nextVariance: Real): Real;
  protected smileCorrection(
      strike: Real, forward: Real, expiry: Real, deflator: Real): Real;
  private _correlation;
  private _withSmile;
  private _byCallSpread;
  private _smilesOnExpiry;
  private _smilesOnPayment;
  private _eps;
}
export declare class RangeAccrualLeg implements NullaryFunction<Leg> {
  constructor(schedule: Schedule, index: IborIndex);
  withNotionals1(notional: Real): RangeAccrualLeg;
  withNotionals2(notionals: Real[]): RangeAccrualLeg;
  withPaymentDayCounter(dayCounter: DayCounter): RangeAccrualLeg;
  withPaymentAdjustment(convention: BusinessDayConvention): RangeAccrualLeg;
  withFixingDays1(fixingDays: Natural): RangeAccrualLeg;
  withFixingDays2(fixingDays: Natural[]): RangeAccrualLeg;
  withGearings1(gearing: Real): RangeAccrualLeg;
  withGearings2(gearings: Real[]): RangeAccrualLeg;
  withSpreads1(spread: Spread): RangeAccrualLeg;
  withSpreads2(spreads: Spread[]): RangeAccrualLeg;
  withLowerTriggers1(trigger: Rate): RangeAccrualLeg;
  withLowerTriggers2(triggers: Rate[]): RangeAccrualLeg;
  withUpperTriggers1(trigger: Rate): RangeAccrualLeg;
  withUpperTriggers2(triggers: Rate[]): RangeAccrualLeg;
  withObservationTenor(tenor: Period): RangeAccrualLeg;
  withObservationConvention(convention: BusinessDayConvention): RangeAccrualLeg;
  f(): Leg;
  private _schedule;
  private _index;
  private _notionals;
  private _paymentDayCounter;
  private _paymentAdjustment;
  private _fixingDays;
  private _gearings;
  private _spreads;
  private _lowerTriggers;
  private _upperTriggers;
  private _observationTenor;
  private _observationConvention;
}

export declare class DigitalReplication {
  constructor(t?: Replication.Type, gap?: Real);
  replicationType(): Replication.Type;
  gap(): Real;
  private _gap;
  private _replicationType;
}
export declare namespace Replication {
  enum Type { Sub = 0, Central = 1, Super = 2 }
}

export declare class SimpleCashFlow extends CashFlow {
  constructor(amount: Real, date: Date);
  date(): Date;
  amount1(): Real;
  accept(v: AcyclicVisitor): void;
  private _amount;
  private _date;
}
export declare class Redemption extends SimpleCashFlow {
  constructor(amount: Real, date: Date);
  accept(v: AcyclicVisitor): void;
}
export declare class AmortizingPayment extends SimpleCashFlow {
  constructor(amount: Real, date: Date);
  accept(v: AcyclicVisitor): void;
}

export declare class TimeBasket extends Map<Natural, Real> {
  constructor(dates: Date[], values: Real[]);
  hasDate(d: Date): boolean;
  adda(other: TimeBasket): TimeBasket;
  suba(other: TimeBasket): TimeBasket;
  rebin(buckets: Date[]): TimeBasket;
}

export declare class YoYInflationCoupon extends InflationCoupon {
  yoyicInit(
      paymentDate: Date, nominal: Real, startDate: Date, endDate: Date,
      fixingDays: Natural, yoyIndex: YoYInflationIndex, observationLag: Period,
      dayCounter: DayCounter, gearing?: Real, spread?: Spread,
      refPeriodStart?: Date, refPeriodEnd?: Date): YoYInflationCoupon;
  gearing(): Real;
  spread(): Spread;
  adjustedFixing(): Rate;
  yoyIndex(): YoYInflationIndex;
  accept(v: AcyclicVisitor): void;
  protected checkPricerImpl(pricer: InflationCouponPricer): boolean;
  protected _gearing: Real;
  protected _spread: Spread;
  private _yoyIndex;
}
export declare class yoyInflationLeg implements NullaryFunction<Leg> {
  constructor(
      schedule: Schedule, paymentCalendar: Calendar, index: YoYInflationIndex,
      observationLag: Period);
  withNotionals1(notional: Real): yoyInflationLeg;
  withNotionals2(notionals: Real[]): yoyInflationLeg;
  withPaymentDayCounter(dayCounter: DayCounter): yoyInflationLeg;
  withPaymentAdjustment(convention: BusinessDayConvention): yoyInflationLeg;
  withFixingDays1(fixingDays: Natural): yoyInflationLeg;
  withFixingDays2(fixingDays: Natural[]): yoyInflationLeg;
  withGearings1(gearing: Real): yoyInflationLeg;
  withGearings2(gearings: Real[]): yoyInflationLeg;
  withSpreads1(spread: Spread): yoyInflationLeg;
  withSpreads2(spreads: Spread[]): yoyInflationLeg;
  withCaps1(cap: Rate): yoyInflationLeg;
  withCaps2(caps: Rate[]): yoyInflationLeg;
  withFloors1(floor: Rate): yoyInflationLeg;
  withFloors2(floors: Rate[]): yoyInflationLeg;
  f(): Leg;
  private _schedule;
  private _index;
  private _observationLag;
  private _notionals;
  private _paymentDayCounter;
  private _paymentAdjustment;
  private _paymentCalendar;
  private _fixingDays;
  private _gearings;
  private _spreads;
  private _caps;
  private _floors;
}

export declare class ZARCurrency extends Currency {
  constructor();
  static zarData: Currency.Data;
}

export declare class ARSCurrency extends Currency {
  constructor();
  static arsData: Currency.Data;
}
export declare class BRLCurrency extends Currency {
  constructor();
  static brlData: Currency.Data;
}
export declare class CADCurrency extends Currency {
  constructor();
  static cadData: Currency.Data;
}
export declare class CLPCurrency extends Currency {
  constructor();
  static clpData: Currency.Data;
}
export declare class COPCurrency extends Currency {
  constructor();
  static copData: Currency.Data;
}
export declare class MXNCurrency extends Currency {
  constructor();
  static mxnData: Currency.Data;
}
export declare class PENCurrency extends Currency {
  constructor();
  static penData: Currency.Data;
}
export declare class PEICurrency extends Currency {
  constructor();
  static peiData: Currency.Data;
}
export declare class PEHCurrency extends Currency {
  constructor();
  static pehData: Currency.Data;
}
export declare class TTDCurrency extends Currency {
  constructor();
  static ttdData: Currency.Data;
}
export declare class USDCurrency extends Currency {
  constructor();
  static usdData: Currency.Data;
}
export declare class VEBCurrency extends Currency {
  constructor();
  static vebData: Currency.Data;
}

export declare class BDTCurrency extends Currency {
  constructor();
  static bdtData: Currency.Data;
}
export declare class CNYCurrency extends Currency {
  constructor();
  static cnyData: Currency.Data;
}
export declare class HKDCurrency extends Currency {
  constructor();
  static hkdData: Currency.Data;
}
export declare class IDRCurrency extends Currency {
  constructor();
  static idrData: Currency.Data;
}
export declare class ILSCurrency extends Currency {
  constructor();
  static ilsData: Currency.Data;
}
export declare class INRCurrency extends Currency {
  constructor();
  static inrData: Currency.Data;
}
export declare class IQDCurrency extends Currency {
  constructor();
  static iqdData: Currency.Data;
}
export declare class IRRCurrency extends Currency {
  constructor();
  static irrData: Currency.Data;
}
export declare class JPYCurrency extends Currency {
  constructor();
  static jpyData: Currency.Data;
}
export declare class KRWCurrency extends Currency {
  constructor();
  static krwData: Currency.Data;
}
export declare class KWDCurrency extends Currency {
  constructor();
  static kwdData: Currency.Data;
}
export declare class MYRCurrency extends Currency {
  constructor();
  static myrData: Currency.Data;
}
export declare class NPRCurrency extends Currency {
  constructor();
  static nprData: Currency.Data;
}
export declare class PKRCurrency extends Currency {
  constructor();
  static pkrData: Currency.Data;
}
export declare class SARCurrency extends Currency {
  constructor();
  static sarData: Currency.Data;
}
export declare class SGDCurrency extends Currency {
  constructor();
  static sgdData: Currency.Data;
}
export declare class THBCurrency extends Currency {
  constructor();
  static thbData: Currency.Data;
}
export declare class TWDCurrency extends Currency {
  constructor();
  static twdData: Currency.Data;
}
export declare class VNDCurrency extends Currency {
  constructor();
  static vndData: Currency.Data;
}

export declare class BTCCurrency extends Currency {
  constructor();
  static btcData: Currency.Data;
}
export declare class ETHCurrency extends Currency {
  constructor();
  static ethData: Currency.Data;
}
export declare class ETCCurrency extends Currency {
  constructor();
  static etcData: Currency.Data;
}
export declare class BCHCurrency extends Currency {
  constructor();
  static bchData: Currency.Data;
}
export declare class XRPCurrency extends Currency {
  constructor();
  static xrpData: Currency.Data;
}
export declare class LTCCurrency extends Currency {
  constructor();
  static ltcData: Currency.Data;
}
export declare class DASHCurrency extends Currency {
  constructor();
  static dashData: Currency.Data;
}
export declare class ZECCurrency extends Currency {
  constructor();
  static zecData: Currency.Data;
}

export declare class BGLCurrency extends Currency {
  constructor();
  static bglData: Currency.Data;
}
export declare class BYRCurrency extends Currency {
  constructor();
  static byrData: Currency.Data;
}
export declare class CHFCurrency extends Currency {
  constructor();
  static chfData: Currency.Data;
}
export declare class CZKCurrency extends Currency {
  constructor();
  static czkData: Currency.Data;
}
export declare class DKKCurrency extends Currency {
  constructor();
  static dkkData: Currency.Data;
}
export declare class EEKCurrency extends Currency {
  constructor();
  static eekData: Currency.Data;
}
export declare class EURCurrency extends Currency {
  constructor();
  static eurData: Currency.Data;
}
export declare class GBPCurrency extends Currency {
  constructor();
  static gbpData: Currency.Data;
}
export declare class HUFCurrency extends Currency {
  constructor();
  static hufData: Currency.Data;
}
export declare class ISKCurrency extends Currency {
  constructor();
  static iskData: Currency.Data;
}
export declare class LTLCurrency extends Currency {
  constructor();
  static ltlData: Currency.Data;
}
export declare class LVLCurrency extends Currency {
  constructor();
  static lvlData: Currency.Data;
}
export declare class NOKCurrency extends Currency {
  constructor();
  static nokData: Currency.Data;
}
export declare class PLNCurrency extends Currency {
  constructor();
  static plnData: Currency.Data;
}
export declare class ROLCurrency extends Currency {
  constructor();
  static rolData: Currency.Data;
}
export declare class RONCurrency extends Currency {
  constructor();
  static ronData: Currency.Data;
}
export declare class RUBCurrency extends Currency {
  constructor();
  static rubData: Currency.Data;
}
export declare class SEKCurrency extends Currency {
  constructor();
  static sekData: Currency.Data;
}
export declare class SITCurrency extends Currency {
  constructor();
  static sitData: Currency.Data;
}
export declare class TRLCurrency extends Currency {
  constructor();
  static trlData: Currency.Data;
}
export declare class TRYCurrency extends Currency {
  constructor();
  static tryData: Currency.Data;
}
export declare class ATSCurrency extends Currency {
  constructor();
  static atsData: Currency.Data;
}
export declare class BEFCurrency extends Currency {
  constructor();
  static befData: Currency.Data;
}
export declare class CYPCurrency extends Currency {
  constructor();
  static cypData: Currency.Data;
}
export declare class DEMCurrency extends Currency {
  constructor();
  static demData: Currency.Data;
}
export declare class ESPCurrency extends Currency {
  constructor();
  static espData: Currency.Data;
}
export declare class FIMCurrency extends Currency {
  constructor();
  static fimData: Currency.Data;
}
export declare class FRFCurrency extends Currency {
  constructor();
  static frfData: Currency.Data;
}
export declare class GRDCurrency extends Currency {
  constructor();
  static grdData: Currency.Data;
}
export declare class IEPCurrency extends Currency {
  constructor();
  static iepData: Currency.Data;
}
export declare class ITLCurrency extends Currency {
  constructor();
  static itlData: Currency.Data;
}
export declare class LUFCurrency extends Currency {
  constructor();
  static lufData: Currency.Data;
}
export declare class MTLCurrency extends Currency {
  constructor();
  static mtlData: Currency.Data;
}
export declare class NLGCurrency extends Currency {
  constructor();
  static nlgData: Currency.Data;
}
export declare class PTECurrency extends Currency {
  constructor();
  static pteData: Currency.Data;
}
export declare class SKKCurrency extends Currency {
  constructor();
  static skkData: Currency.Data;
}
export declare class UAHCurrency extends Currency {
  constructor();
  static uahData: Currency.Data;
}

declare type Key = number;
export declare namespace ExchangeRateManager {
  function add(rate: ExchangeRate, startDate?: Date, endDate?: Date): void;
  function lookup(
      source: Currency, target: Currency, date?: Date,
      type?: ExchangeRate.Type): ExchangeRate;
  function clear(): void;
  class Entry {
    constructor(rate: ExchangeRate, start: Date, end: Date);
    rate: ExchangeRate;
    startDate: Date;
    endDate: Date;
  }
  function hash(c1: Currency, c2: Currency): Key;
  function hashes(k: Key, c: Currency): boolean;
  function addKnownRates(): void;
  function directLookup(
      source: Currency, target: Currency, date: Date): ExchangeRate;
  function smartLookup(
      source: Currency, target: Currency, date: Date,
      forbiddenCodes?: Set<Integer>): ExchangeRate;
  function fetch(source: Currency, target: Currency, date: Date): ExchangeRate;
}


export declare class AUDCurrency extends Currency {
  constructor();
  static audData: Currency.Data;
}
export declare class NZDCurrency extends Currency {
  constructor();
  static nzdData: Currency.Data;
}

export declare class Composite<T> {
  protected add(c: T): void;
  protected _components: Set<T>;
}

export interface ICuriouslyRecurringTemplate {
  impl(): any;
}
export declare class CuriouslyRecurringTemplate<
    T extends CuriouslyRecurringTemplate<T>> implements
    ICuriouslyRecurringTemplate {
  impl(): any;
}

export declare class LazyObject extends ObserverObservable {
  update(): void;
  recalculate(): void;
  freeze(): void;
  unfreeze(): void;
  alwaysForwardNotifications(): void;
  calculate(): void;
  performCalculations(): void;
  _calculated: boolean;
  _frozen: boolean;
  _alwaysForward: boolean;
}

export declare class Observable {
  constructor();
  notifyObservers(): void;
  registerObserver(o: Observer): void;
  unregisterObserver(o: Observer): void;
  readonly isDisposed: boolean;
  dispose(): void;
  _observers: Set<Observer>;
  _isDisposed: boolean;
}
export declare class Observer {
  constructor();
  registerWith(h: Observable): void;
  registerWithObservables(o: Observer): void;
  unregisterWith(h: Observable): Size;
  unregisterWithAll(): void;
  update(): void;
  deepUpdate(): void;
  readonly isDisposed: boolean;
  dispose(): void;
  _observables: Set<Observable>;
  _isDisposed: boolean;
}
export declare namespace ObservableSettings {
  function disableUpdates(deferred?: boolean): void;
  function enableUpdates(): void;
  function updatesEnabled(): boolean;
  function updatesDeferred(): boolean;
  function registerDeferredObservers(o: Set<Observer>): void;
  function unregisterDeferredObserver(o: Observer): void;
}

export declare class AcyclicVisitor {}
export declare class Visitor<T> {
  visit(t: T): void;
}

export declare class BatesProcess extends HestonProcess {
  constructor(
      riskFreeRate: Handle<YieldTermStructure>,
      dividendYield: Handle<YieldTermStructure>, s0: Handle<Quote>, v0: Real,
      kappa: Real, theta: Real, sigma: Real, rho: Real, lambda: Real, nu: Real,
      delta: Real, d?: HestonProcess.Discretization);
  factors(): Size;
  drift1(t: Time, x: Real[]): Real[];
  evolve1(t0: Time, x0: Real[], dt: Time, dw: Real[]): Real[];
  lambda(): Real;
  nu(): Real;
  delta(): Real;
  private _lambda;
  private _delta;
  private _nu;
  private _m;
  private _cumNormalDist;
}

export declare class GeneralizedBlackScholesProcess extends
    StochasticProcess1D {
  init1(
      x0: Handle<Quote>, dividendTS: Handle<YieldTermStructure>,
      riskFreeTS: Handle<YieldTermStructure>,
      blackVolTS: Handle<BlackVolTermStructure>,
      disc?: StochasticProcess.discretization,
      forceDiscretization?: boolean): GeneralizedBlackScholesProcess;
  init2(
      x0: Handle<Quote>, dividendTS: Handle<YieldTermStructure>,
      riskFreeTS: Handle<YieldTermStructure>,
      blackVolTS: Handle<BlackVolTermStructure>,
      localVolTS: Handle<LocalVolTermStructure>):
      GeneralizedBlackScholesProcess;
  x0(): Real;
  drift2(t: Time, x: Real): Real;
  diffusion2(t: Time, x: Real): Real;
  apply2(x0: Real, dx: Real): Real;
  expectation2(t0: Time, x0: Real, dt: Time): Real;
  stdDeviation2(t0: Time, x0: Real, dt: Time): Real;
  variance(t0: Time, x0: Real, dt: Time): Real;
  evolve2(t0: Time, x0: Real, dt: Time, dw: Real): Real;
  time(d: Date): Time;
  update(): void;
  stateVariable(): Handle<Quote>;
  dividendYield(): Handle<YieldTermStructure>;
  riskFreeRate(): Handle<YieldTermStructure>;
  blackVolatility(): Handle<BlackVolTermStructure>;
  localVolatility(): Handle<LocalVolTermStructure>;
  private _x0;
  private _riskFreeRate;
  private _dividendYield;
  private _blackVolatility;
  private _externalLocalVolTS;
  private _forceDiscretization;
  private _hasExternalLocalVol;
  private _localVolatility;
  private _updated;
  private _isStrikeIndependent;
}
export declare class BlackScholesProcess extends
    GeneralizedBlackScholesProcess {
  constructor(
      x0: Handle<Quote>, riskFreeTS: Handle<YieldTermStructure>,
      blackVolTS: Handle<BlackVolTermStructure>,
      d?: StochasticProcess.discretization, forceDiscretization?: boolean);
}
export declare class BlackScholesMertonProcess extends
    GeneralizedBlackScholesProcess {
  constructor(
      x0: Handle<Quote>, dividendTS: Handle<YieldTermStructure>,
      riskFreeTS: Handle<YieldTermStructure>,
      blackVolTS: Handle<BlackVolTermStructure>,
      d?: StochasticProcess.discretization, forceDiscretization?: boolean);
}
export declare class BlackProcess extends GeneralizedBlackScholesProcess {
  constructor(
      x0: Handle<Quote>, riskFreeTS: Handle<YieldTermStructure>,
      blackVolTS: Handle<BlackVolTermStructure>,
      d?: StochasticProcess.discretization, forceDiscretization?: boolean);
}
export declare class GarmanKohlagenProcess extends
    GeneralizedBlackScholesProcess {
  constructor(
      x0: Handle<Quote>, foreignRiskFreeTS: Handle<YieldTermStructure>,
      domesticRiskFreeTS: Handle<YieldTermStructure>,
      blackVolTS: Handle<BlackVolTermStructure>,
      d?: StochasticProcess.discretization, forceDiscretization?: boolean);
}

export declare class EndEulerDiscretization extends
    StochasticProcess.discretization {
  drift1(process: StochasticProcess, t0: Time, x0: Real[], dt: Time): Real[];
  drift2(process: StochasticProcess1D, t0: Time, x0: Real, dt: Time): Real;
  diffusion1(process: StochasticProcess, t0: Time, x0: Real[], dt: Time):
      Matrix;
  diffusion2(process: StochasticProcess1D, t0: Time, x0: Real, dt: Time): Real;
  covariance(process: StochasticProcess, t0: Time, x0: Real[], dt: Time):
      Matrix;
  variance(process: StochasticProcess1D, t0: Time, x0: Real, dt: Time): Real;
}

export declare class EulerDiscretization extends
    StochasticProcess.discretization {
  drift1(process: StochasticProcess, t0: Time, x0: Real[], dt: Time): Real[];
  drift2(process: StochasticProcess1D, t0: Time, x0: Real, dt: Time): Real;
  diffusion1(process: StochasticProcess, t0: Time, x0: Real[], dt: Time):
      Matrix;
  diffusion2(process: StochasticProcess1D, t0: Time, x0: Real, dt: Time): Real;
  covariance(process: StochasticProcess, t0: Time, x0: Real[], dt: Time):
      Matrix;
  variance(process: StochasticProcess1D, t0: Time, x0: Real, dt: Time): Real;
}

export declare class ForwardMeasureProcess extends StochasticProcess {
  fmpInit1(t: Time): ForwardMeasureProcess;
  fmpInit2(d: StochasticProcess.discretization): ForwardMeasureProcess;
  setForwardMeasureTime(t: Time): void;
  getForwardMeasureTime(): Time;
  protected _T: Time;
}
export declare class ForwardMeasureProcess1D extends StochasticProcess1D {
  fmpInit1(t: Time): ForwardMeasureProcess1D;
  fmpInit2(d: StochasticProcess.discretization): ForwardMeasureProcess1D;
  setForwardMeasureTime(t: Time): void;
  getForwardMeasureTime(): Time;
  protected _T: Time;
}

export declare class G2Process extends StochasticProcess {
  constructor(a: Real, sigma: Real, b: Real, eta: Real, rho: Real);
  size(): Size;
  initialValues(): Real[];
  drift1(t: Time, x: Real[]): Real[];
  diffusion1(t: Time, x: Real[]): Matrix;
  expectation1(t0: Time, x0: Real[], dt: Time): Real[];
  stdDeviation1(t0: Time, x0: Real[], dt: Time): Matrix;
  covariance(t0: Time, x0: Real[], dt: Time): Matrix;
  x0(): Real;
  y0(): Real;
  a(): Real;
  sigma(): Real;
  b(): Real;
  eta(): Real;
  rho(): Real;
  private _x0;
  private _y0;
  private _a;
  private _sigma;
  private _b;
  private _eta;
  private _rho;
  private _xProcess;
  private _yProcess;
}
export declare class G2ForwardProcess extends ForwardMeasureProcess {
  constructor(a: Real, sigma: Real, b: Real, eta: Real, rho: Real);
  size(): Size;
  initialValues(): Real[];
  drift1(t: Time, x: Real[]): Real[];
  diffusion1(t: Time, x: Real[]): Matrix;
  expectation1(t0: Time, x0: Real[], dt: Time): Real[];
  stdDeviation1(t0: Time, x0: Real[], dt: Time): Matrix;
  covariance(t0: Time, x0: Real[], dt: Time): Matrix;
  protected xForwardDrift(t: Time, T: Time): Real;
  protected yForwardDrift(t: Time, T: Time): Real;
  protected Mx_T(s: Real, t: Real, T: Real): Real;
  protected My_T(s: Real, t: Real, T: Real): Real;
  protected _x0: Real;
  protected _y0: Real;
  protected _a: Real;
  protected _sigma: Real;
  protected _b: Real;
  protected _eta: Real;
  protected _rho: Real;
  protected _xProcess: OrnsteinUhlenbeckProcess;
  protected _yProcess: OrnsteinUhlenbeckProcess;
}

export declare class GeometricBrownianMotionProcess extends
    StochasticProcess1D {
  constructor(initialValue: Real, mue: Real, sigma: Real);
  x0(): Real;
  drift2(t: Time, x: Real): Real;
  diffusion2(t: Time, x: Real): Real;
  protected _initialValue: Real;
  protected _mue: Real;
  protected _sigma: Real;
}

export declare class GJRGARCHProcess extends StochasticProcess {
  constructor(
      riskFreeRate: Handle<YieldTermStructure>,
      dividendYield: Handle<YieldTermStructure>, s0: Handle<Quote>, v0: Real,
      omega: Real, alpha: Real, beta: Real, gamma: Real, lambda: Real,
      daysPerYear?: Real, d?: GJRGARCHProcess.Discretization);
  size(): Size;
  initialValues(): Real[];
  drift1(t: Time, x: Real[]): Real[];
  diffusion1(t: Time, x: Real[]): Matrix;
  apply1(x0: Real[], dx: Real[]): Real[];
  evolve1(t0: Time, x0: Real[], dt: Time, dw: Real[]): Real[];
  v0(): Real;
  lambda(): Real;
  omega(): Real;
  alpha(): Real;
  beta(): Real;
  gamma(): Real;
  daysPerYear(): Real;
  s0(): Handle<Quote>;
  dividendYield(): Handle<YieldTermStructure>;
  riskFreeRate(): Handle<YieldTermStructure>;
  time(d: Date): Time;
  private _riskFreeRate;
  private _dividendYield;
  private _s0;
  private _v0;
  private _omega;
  private _alpha;
  private _beta;
  private _gamma;
  private _lambda;
  private _daysPerYear;
  _discretization1: GJRGARCHProcess.Discretization;
}
export declare namespace GJRGARCHProcess {
  enum Discretization {
    PartialTruncation = 0,
    FullTruncation = 1,
    Reflection = 2
  }
}

export declare class GsrProcess extends ForwardMeasureProcess1D {
  constructor(
      times: Real[], vols: Real[], reversions: Real[], T?: Real,
      referenceDate?: Date, dc?: DayCounter);
  x0(): Real;
  drift2(t: Time, x: Real): Real;
  diffusion2(t: Time, x: Real): Real;
  expectation2(w: Time, xw: Real, dt: Time): Real;
  stdDeviation2(t0: Time, x0: Real, dt: Time): Real;
  variance(w: Time, x0: Real, dt: Time): Real;
  time(d: Date): Real;
  setForwardMeasureTime(t: Time): void;
  sigma(t: Time): Real;
  reversion(t: Time): Real;
  y(t: Time): Real;
  G(t: Time, w: Time, x: Real): Real;
  checkT(t: Time): void;
  flushCache(): void;
  private _core;
  private _referenceDate;
  private _dc;
}

export declare class GsrProcessCore {
  constructor(times: Real[], vols: Real[], reversions: Real[], T?: Real);
  expectation_x0dep_part(w: Time, xw: Real, dt: Time): Real;
  expectation_rn_part(w: Time, dt: Time): Real;
  expectation_tf_part(w: Time, dt: Time): Real;
  variance(w: Time, dt: Time): Real;
  y(t: Time): Real;
  G(t: Time, w: Time): Real;
  sigma(t: Time): Real;
  reversion(t: Time): Real;
  flushCache(): void;
  private lowerIndex;
  private upperIndex;
  private time2;
  private cappedTime;
  private flooredTime;
  private vol;
  private rev;
  private revZero;
  protected _times: Real[];
  protected _vols: Real[];
  protected _reversions: Real[];
  private _cache1;
  private _cache2a;
  private _cache2b;
  private _cache3;
  private _cache5;
  private _cache4;
  private _T;
  private _revZero;
}

export declare class HestonProcess extends StochasticProcess {
  constructor(
      riskFreeRate: Handle<YieldTermStructure>,
      dividendYield: Handle<YieldTermStructure>, s0: Handle<Quote>, v0: Real,
      kappa: Real, theta: Real, sigma: Real, rho: Real,
      d?: HestonProcess.Discretization);
  size(): Size;
  factors(): Size;
  initialValues(): Real[];
  drift1(t: Time, x: Real[]): Real[];
  diffusion1(t: Time, x: Real[]): Matrix;
  apply1(x0: Real[], dx: Real[]): Real[];
  evolve1(t0: Time, x0: Real[], dt: Time, dw: Real[]): Real[];
  v0(): Real;
  rho(): Real;
  kappa(): Real;
  theta(): Real;
  sigma(): Real;
  s0(): Handle<Quote>;
  dividendYield(): Handle<YieldTermStructure>;
  riskFreeRate(): Handle<YieldTermStructure>;
  time(d: Date): Time;
  pdf(x: Real, v: Real, t: Time, eps?: Real): Real;
  private varianceDistribution;
  private _riskFreeRate;
  private _dividendYield;
  private _s0;
  private _v0;
  private _kappa;
  private _theta;
  private _sigma;
  private _rho;
  _discretization1: HestonProcess.Discretization;
}
export declare namespace HestonProcess {
  enum Discretization {
    PartialTruncation = 0,
    FullTruncation = 1,
    Reflection = 2,
    NonCentralChiSquareVariance = 3,
    QuadraticExponential = 4,
    QuadraticExponentialMartingale = 5,
    BroadieKayaExactSchemeLobatto = 6,
    BroadieKayaExactSchemeLaguerre = 7,
    BroadieKayaExactSchemeTrapezoidal = 8
  }
}

export declare class HullWhiteProcess extends StochasticProcess1D {
  constructor(h: Handle<YieldTermStructure>, a: Real, sigma: Real);
  x0(): Real;
  drift2(t: Time, x: Real): Real;
  diffusion2(t: Time, x: Real): Real;
  expectation2(t0: Time, x0: Real, dt: Time): Real;
  stdDeviation2(t0: Time, x0: Real, dt: Time): Real;
  variance(t0: Time, x0: Real, dt: Time): Real;
  a(): Real;
  sigma(): Real;
  alpha(t: Time): Real;
  protected _process: OrnsteinUhlenbeckProcess;
  protected _h: Handle<YieldTermStructure>;
  protected _a: Real;
  protected _sigma: Real;
}
export declare class HullWhiteForwardProcess extends ForwardMeasureProcess1D {
  constructor(h: Handle<YieldTermStructure>, a: Real, sigma: Real);
  x0(): Real;
  drift2(t: Time, x: Real): Real;
  diffusion2(t: Time, x: Real): Real;
  expectation2(t0: Time, x0: Real, dt: Time): Real;
  stdDeviation2(t0: Time, x0: Real, dt: Time): Real;
  variance(t0: Time, x0: Real, dt: Time): Real;
  a(): Real;
  sigma(): Real;
  alpha(t: Time): Real;
  M_T(s: Real, t: Real, T: Real): Real;
  B(t: Time, T: Time): Real;
  protected _process: OrnsteinUhlenbeckProcess;
  protected _h: Handle<YieldTermStructure>;
  protected _a: Real;
  protected _sigma: Real;
}

export declare class HybridHestonHullWhiteProcess extends StochasticProcess {
  constructor(
      hestonProcess: HestonProcess, hullWhiteProcess: HullWhiteForwardProcess,
      corrEquityShortRate: Real,
      discretization?: HybridHestonHullWhiteProcess.Discretization);
  size(): Size;
  initialValues(): Real[];
  drift1(t: Time, x: Real[]): Real[];
  diffusion1(t: Time, x: Real[]): Matrix;
  apply1(x0: Real[], dx: Real[]): Real[];
  evolve1(t0: Time, x0: Real[], dt: Time, dw: Real[]): Real[];
  numeraire(t: Time, x: Real[]): DiscountFactor;
  hestonProcess(): HestonProcess;
  hullWhiteProcess(): HullWhiteForwardProcess;
  eta(): Real;
  time(date: Date): Time;
  discretization(): HybridHestonHullWhiteProcess.Discretization;
  update(): void;
  protected _hestonProcess: HestonProcess;
  protected _hullWhiteProcess: HullWhiteForwardProcess;
  protected _hullWhiteModel: HullWhite;
  protected _corrEquityShortRate: Real;
  protected _discretization1: HybridHestonHullWhiteProcess.Discretization;
  protected _maxRho: Real;
  protected _T: Time;
  protected _endDiscount: DiscountFactor;
}
export declare namespace HybridHestonHullWhiteProcess {
  enum Discretization { Euler = 0, BSMHullWhite = 1 }
}

export declare class JointStochasticProcess extends StochasticProcess {
  constructor(l: StochasticProcess[], factors?: Size);
  size(): Size;
  factors(): Size;
  initialValues(): Real[];
  drift1(t: Time, x: Real[]): Real[];
  expectation1(t0: Time, x0: Real[], dt: Time): Real[];
  diffusion1(t: Time, x: Real[]): Matrix;
  covariance(t0: Time, x0: Real[], dt: Time): Matrix;
  stdDeviation(t0: Time, x0: Real[], dt: Time): Matrix;
  apply1(x0: Real[], dx: Real[]): Real[];
  evolve1(t0: Time, x0: Real[], dt: Time, dw: Real[]): Real[];
  preEvolve(t0: Time, x0: Real[], dt: Time, dw: Real[]): void;
  postEvolve(t0: Time, x0: Real[], dt: Time, dw: Real[], y0: Real[]): Real[];
  numeraire(t: Time, x: Real[]): DiscountFactor;
  correlationIsStateDependent(): boolean;
  crossModelCorrelation(t0: Time, x0: Real[]): Matrix;
  constituents(): StochasticProcess[];
  update(): void;
  time(date: Date): Time;
  protected slice(x: Real[], i: Size): Real[];
  protected _l: StochasticProcess[];
  private _size;
  private _factors;
  private _modelFactors;
  private _vsize;
  private _vfactors;
  private _correlationCache;
}
export declare namespace JointStochasticProcess {
  class CachingKey {
    static lessThan(key1: [Time, Time], key2: [Time, Time]): boolean;
  }
}

export declare class Merton76Process extends StochasticProcess1D {
  constructor(
      stateVariable: Handle<Quote>, dividendTS: Handle<YieldTermStructure>,
      riskFreeTS: Handle<YieldTermStructure>,
      blackVolTS: Handle<BlackVolTermStructure>, jumpInt: Handle<Quote>,
      logJMean: Handle<Quote>, logJVol: Handle<Quote>,
      disc?: StochasticProcess.discretization);
  x0(): Real;
  drift2(t: Time, x: Real): Real;
  diffusion2(t: Time, x: Real): Real;
  apply2(x0: Real, dx: Real): Real;
  time(d: Date): Time;
  stateVariable(): Handle<Quote>;
  dividendYield(): Handle<YieldTermStructure>;
  riskFreeRate(): Handle<YieldTermStructure>;
  blackVolatility(): Handle<BlackVolTermStructure>;
  jumpIntensity(): Handle<Quote>;
  logMeanJump(): Handle<Quote>;
  logJumpVolatility(): Handle<Quote>;
  private _blackProcess;
  private _jumpIntensity;
  private _logMeanJump;
  private _logJumpVolatility;
}

export declare class MfStateProcess extends StochasticProcess1D {
  constructor(reversion: Real, times: Real[], vols: Real[]);
}

export declare class OrnsteinUhlenbeckProcess extends StochasticProcess1D {
  constructor(speed: Real, vol: Volatility, x0?: Real, level?: Real);
  drift2(t: Time, x: Real): Real;
  diffusion(t: Time, x: Real): Real;
  expectation2(t: Time, x0: Real, dt: Time): Real;
  stdDeviation2(t: Time, x0: Real, dt: Time): Real;
  x0(): Real;
  speed(): Real;
  volatility(): Real;
  level(): Real;
  variance(t0: Time, x0: Real, dt: Time): Real;
  private _x0;
  private _speed;
  private _level;
  private _volatility;
}

export declare class SquareRootProcess extends StochasticProcess1D {
  constructor(
      b: Real, a: Real, sigma: Volatility, x0?: Real,
      disc?: StochasticProcess.discretization);
  x0(): Real;
  drift2(t: Time, x: Real): Real;
  diffusion2(t: Time, x: Real): Real;
  a(): Real;
  b(): Real;
  sigma(): Real;
  private _x0;
  private _mean;
  private _speed;
  private _volatility;
}

export declare class StochasticProcessArray extends StochasticProcess {
  constructor(processes: StochasticProcess1D[], correlation: Matrix);
  size(): Size;
  initialValues(): Real[];
  drift1(t: Time, x: Real[]): Real[];
  expectation1(t0: Time, x0: Real[], dt: Time): Real[];
  diffusion1(t: Time, x: Real[]): Matrix;
  covariance(t0: Time, x0: Real[], dt: Time): Matrix;
  stdDeviation1(t0: Time, x0: Real[], dt: Time): Matrix;
  apply1(x0: Real[], dx: Real[]): Real[];
  evolve1(t0: Time, x0: Real[], dt: Time, dw: Real[]): Real[];
  time(d: Date): Time;
  process(i: Size): StochasticProcess1D;
  correlation(): Matrix;
  protected _processes: StochasticProcess1D[];
  protected _sqrtCorrelation: Matrix;
}

export declare class CompositeQuote extends QuoteObserver {
  constructor(
      element1: Handle<Quote>, element2: Handle<Quote>,
      f: BinaryFunction<Real, Real, Real>);
  value1(): Real;
  value2(): Real;
  value(): Real;
  isValid(): boolean;
  update(): void;
  private _element1;
  private _element2;
  private _f;
}

export declare class DerivedQuote extends QuoteObserver {
  constructor(element: Handle<Quote>, f: UnaryFunction<Real, Real>);
  value(): Real;
  isValid(): boolean;
  update(): void;
  private _element;
  private _f;
}

export declare class EurodollarFuturesImpliedStdDevQuote extends
    QuoteLazyObject {
  constructor(
      forward: Handle<Quote>, callPrice: Handle<Quote>, putPrice: Handle<Quote>,
      strike: Real, guess?: Real, accuracy?: Real, maxIter?: Natural);
  value(): Real;
  isValid(): boolean;
  performCalculations(): void;
  protected _impliedStdev: Real;
  protected _strike: Real;
  protected _accuracy: Real;
  protected _maxIter: Natural;
  protected _forward: Handle<Quote>;
  protected _callPrice: Handle<Quote>;
  protected _putPrice: Handle<Quote>;
}

export declare class ForwardSwapQuote extends QuoteLazyObject {
  constructor(swapIndex: SwapIndex, spread: Handle<Quote>, fwdStart: Period);
  value(): Real;
  isValid(): boolean;
  valueDate(): Date;
  startDate(): Date;
  fixingDate(): Date;
  update(): void;
  performCalculations(): void;
  protected initializeDates(): void;
  protected _swapIndex: SwapIndex;
  protected _spread: Handle<Quote>;
  protected _fwdStart: Period;
  protected _evaluationDate: Date;
  protected _valueDate: Date;
  protected _startDate: Date;
  protected _fixingDate: Date;
  protected _swap: VanillaSwap;
  protected _result: Rate;
}

export declare class ForwardValueQuote extends QuoteObserver {
  constructor(index: Index, fixingDate: Date);
  value(): Real;
  isValid(): boolean;
  update(): void;
  private _index;
  private _fixingDate;
}

export declare class FuturesConvAdjustmentQuote extends QuoteObserver {
  constructor(index: Index, fixingDate: Date);
  value(): Real;
  isValid(): boolean;
  update(): void;
  private _index;
  private _fixingDate;
}

export declare class ImpliedStdDevQuote extends QuoteLazyObject {
  constructor(
      optionType: Option.Type, forward: Handle<Quote>, price: Handle<Quote>,
      strike: Real, guess: Real, accuracy?: Real, maxIter?: Natural);
  value(): Real;
  isValid(): boolean;
  performCalculations(): void;
  protected _impliedStdev: Real;
  protected _optionType: Option.Type;
  protected _strike: Real;
  protected _accuracy: Real;
  protected _maxIter: Natural;
  protected _forward: Handle<Quote>;
  protected _price: Handle<Quote>;
}

export declare class LastFixingQuote extends QuoteObserver {
  constructor(index: Index);
  value(): Real;
  isValid(): boolean;
  update(): void;
  index(): Index;
  referenceDate(): Date;
  private _index;
}

export declare class SimpleQuote extends Quote {
  constructor(value?: Real);
  value(): Real;
  setValue(value?: Real): Real;
  isValid(): boolean;
  reset(): void;
  private _value;
}



export declare class PeriodParser {
  static parse(str: string): Period;
  static parseOnePeriod(str: string): Period;
}

export interface Disposable {
  readonly isDisposed: boolean;
  dispose(): void;
}
export declare function using<T extends Disposable>(
    resource: T, func: (resource: T) => void): void;
export declare class Disposable {}

export declare class Null {}

export declare class ObservableValue<T> {
  constructor(t: T);
  set(t: T): void;
  get(): Observable;
  value(): T;
  private _value;
  private _observable;
}

export declare class StepIterator {
  readonly isDisposed: boolean;
  dispose(): void;
  private _isDisposed;
}


export declare function get(v: number[], i: Size, defaultValue: number): number;

export declare class AmortizingCmsRateBond extends Bond {
  constructor(
      settlementDays: Natural, notionals: Real[], schedule: Schedule,
      index: SwapIndex, paymentDayCounter: DayCounter,
      paymentConvention?: BusinessDayConvention, fixingDays?: Natural,
      gearings?: Real[], spreads?: Real[], caps?: Rate[], floors?: Rate[],
      inArrears?: boolean, issueDate?: Date);
}

export declare class AmortizingFixedRateBond extends Bond {
  afrbInit1(
      settlementDays: Natural, notionals: Real[], schedule: Schedule,
      coupons: Rate[], accrualDayCounter: DayCounter,
      paymentConvention?: BusinessDayConvention,
      issueDate?: Date): AmortizingFixedRateBond;
  afrbInit2(
      settlementDays: Natural, calendar: Calendar, initialFaceAmount: Real,
      startDate: Date, bondTenor: Period, sinkingFrequency: Frequency,
      coupon: Rate, accrualDayCounter: DayCounter,
      paymentConvention?: BusinessDayConvention,
      issueDate?: Date): AmortizingFixedRateBond;
  frequency(): Frequency;
  dayCounter(): DayCounter;
  protected _frequency: Frequency;
  protected _dayCounter: DayCounter;
}

export declare class AmortizingFloatingRateBond extends Bond {
  constructor(
      settlementDays: Natural, notionals: Real[], schedule: Schedule,
      index: IborIndex, paymentDayCounter: DayCounter,
      paymentConvention?: BusinessDayConvention, fixingDays?: Natural,
      gearings?: Real[], spreads?: Real[], caps?: Rate[], floors?: Rate[],
      inArrears?: boolean, issueDate?: Date);
}

export declare class ArithmeticAverageOIS extends Swap {
  aaoisInit1(
      type: ArithmeticAverageOIS.Type, nominal: Real,
      fixedLegSchedule: Schedule, fixedRate: Rate, fixedDC: DayCounter,
      overnightIndex: OvernightIndex, overnightLegSchedule: Schedule,
      spread?: Spread, meanReversionSpeed?: Real, volatility?: Real,
      byApprox?: boolean): ArithmeticAverageOIS;
  aaoisInit2(
      type: ArithmeticAverageOIS.Type, nominals: Real[],
      fixedLegSchedule: Schedule, fixedRate: Rate, fixedDC: DayCounter,
      overnightIndex: OvernightIndex, overnightLegSchedule: Schedule,
      spread?: Spread, meanReversionSpeed?: Real, volatility?: Real,
      byApprox?: boolean): ArithmeticAverageOIS;
  type(): ArithmeticAverageOIS.Type;
  nominal(): Real;
  nominals(): Real[];
  fixedLegPaymentFrequency(): Frequency;
  overnightLegPaymentFrequency(): Frequency;
  fixedRate(): Rate;
  fixedDayCount(): DayCounter;
  overnightIndex(): OvernightIndex;
  spread(): Spread;
  fixedLeg(): Leg;
  overnightLeg(): Leg;
  fixedLegBPS(): Real;
  fixedLegNPV(): Real;
  fairRate(): Real;
  overnightLegBPS(): Real;
  overnightLegNPV(): Real;
  fairSpread(): Spread;
  private initialize;
  private _type;
  private _nominals;
  private _fixedLegPaymentFrequency;
  private _overnightLegPaymentFrequency;
  private _fixedRate;
  private _fixedDC;
  private _overnightIndex;
  private _spread;
  private _byApprox;
  private _mrs;
  private _vol;
}
export declare namespace ArithmeticAverageOIS {
  enum Type { Receiver = -1, Payer = 1 }
}

export declare class ArithmeticOISRateHelper extends
    RelativeDateBootstrapHelper {
  constructor(
      settlementDays: Natural, tenor: Period,
      fixedLegPaymentFrequency: Frequency, fixedRate: Handle<Quote>,
      overnightIndex: OvernightIndex, overnightLegPaymentFrequency: Frequency,
      spread: Handle<Quote>, meanReversionSpeed?: Real, volatility?: Real,
      byApprox?: boolean, discount?: Handle<YieldTermStructure>);
  impliedQuote(): Real;
  setTermStructure(t: YieldTermStructure): void;
  swap(): ArithmeticAverageOIS;
  accept(v: AcyclicVisitor): void;
  protected initializeDates(): void;
  protected _settlementDays: Natural;
  protected _tenor: Period;
  protected _overnightIndex: OvernightIndex;
  protected _swap: ArithmeticAverageOIS;
  protected _termStructureHandle: RelinkableHandle<YieldTermStructure>;
  protected _discountHandle: Handle<YieldTermStructure>;
  protected _discountRelinkableHandle: RelinkableHandle<YieldTermStructure>;
  protected _fixedLegPaymentFrequency: Frequency;
  protected _overnightLegPaymentFrequency: Frequency;
  protected _spread: Handle<Quote>;
  protected _mrs: Real;
  protected _vol: Real;
  protected _byApprox: boolean;
}

export declare class ArithmeticAveragedOvernightIndexedCouponPricer extends
    FloatingRateCouponPricer {
  constructor(meanReversion?: Real, volatility?: Real, byApprox?: boolean);
  initialize(coupon: FloatingRateCoupon): void;
  swapletRate(): Rate;
  swapletPrice(): Real;
  capletPrice(r: Rate): Real;
  capletRate(r: Rate): Rate;
  floorletPrice(r: Rate): Real;
  floorletRate(r: Rate): Rate;
  protected convAdj1(ts: Time, te: Time): Real;
  protected convAdj2(ts: Time, te: Time): Real;
  protected _coupon: OvernightIndexedCoupon;
  protected _byApprox: boolean;
  protected _mrs: Real;
  protected _vol: Real;
}

export declare class MakeArithmeticAverageOIS implements
    NullaryFunction<ArithmeticAverageOIS> {
  constructor(
      swapTenor: Period, overnightIndex: OvernightIndex, fixedRate?: Rate,
      forwardStart?: Period);
  receiveFixed(flag?: boolean): MakeArithmeticAverageOIS;
  withType(type: ArithmeticAverageOIS.Type): MakeArithmeticAverageOIS;
  withNominal(n: Real): MakeArithmeticAverageOIS;
  withSettlementDays(settlementDays: Natural): MakeArithmeticAverageOIS;
  withEffectiveDate(effectiveDate: Date): MakeArithmeticAverageOIS;
  withTerminationDate(terminationDate: Date): MakeArithmeticAverageOIS;
  withRule(r: DateGeneration.Rule): MakeArithmeticAverageOIS;
  withFixedLegPaymentFrequency(f: Frequency): MakeArithmeticAverageOIS;
  withOvernightLegPaymentFrequency(f: Frequency): MakeArithmeticAverageOIS;
  withEndOfMonth(flag?: boolean): MakeArithmeticAverageOIS;
  withFixedLegDayCount(dc: DayCounter): MakeArithmeticAverageOIS;
  withOvernightLegSpread(sp: Spread): MakeArithmeticAverageOIS;
  withDiscountingTermStructure(d: Handle<YieldTermStructure>):
      MakeArithmeticAverageOIS;
  withPricingEngine(engine: PricingEngine): MakeArithmeticAverageOIS;
  withArithmeticAverage(
      meanReversionSpeed?: Real, volatility?: Real,
      byApprox?: boolean): MakeArithmeticAverageOIS;
  f(): ArithmeticAverageOIS;
  private _swapTenor;
  private _overnightIndex;
  private _fixedRate;
  private _forwardStart;
  private _settlementDays;
  private _effectiveDate;
  private _terminationDate;
  private _calendar;
  private _fixedLegPaymentFrequency;
  private _overnightLegPaymentFrequency;
  private _rule;
  private _endOfMonth;
  private _isDefaultEOM;
  private _byApprox;
  private _mrs;
  private _vol;
  private _type;
  private _nominal;
  private _overnightSpread;
  private _fixedDayCount;
  private _engine;
}

export declare class AnalyticDoubleBarrierBinaryEngine extends
    DoubleBarrierOption.engine {
  init1(process: GeneralizedBlackScholesProcess, series?: Size):
      AnalyticDoubleBarrierBinaryEngine;
}

export declare class AnalyticDoubleBarrierEngine extends
    DoubleBarrierOption.engine {
  init1(process: GeneralizedBlackScholesProcess, series?: Size):
      AnalyticDoubleBarrierEngine;
}

export declare class BinomialDoubleBarrierEngine extends
    DoubleBarrierOption.engine {
  constructor(T: any, D?: any);
  bdbeInit(process: GeneralizedBlackScholesProcess, timeSteps: Size):
      BinomialDoubleBarrierEngine;
  T: any;
  D: any;
}

export declare class DiscretizedDoubleBarrierOption extends DiscretizedAsset {
  ddInit(
      args: DoubleBarrierOptionEngine.Arguments, process: StochasticProcess,
      grid?: TimeGrid): DiscretizedDoubleBarrierOption;
  reset(size: Size): void;
  vanilla(): Real[];
  arguments(): DoubleBarrierOptionEngine.Arguments;
  mandatoryTimes(): Time[];
  checkBarrier(optvalues: Real[], grid: Real[]): void;
  postAdjustValuesImpl(): void;
  private _arguments;
  private _stoppingTimes;
  private _vanilla;
}
export declare class DiscretizedDermanKaniDoubleBarrierOption extends
    DiscretizedAsset {
  ddInit(
      args: DoubleBarrierOptionEngine.Arguments, process: StochasticProcess,
      grid?: TimeGrid): DiscretizedDermanKaniDoubleBarrierOption;
  reset(size: Size): void;
  mandatoryTimes(): Time[];
  postAdjustValuesImpl(): void;
  private adjustBarrier;
  private _unenhanced;
}

export declare class DoubleBarrierOption extends OneAssetOption {
  constructor(
      barrierType: DoubleBarrier.Type, barrier_lo: Real, barrier_hi: Real,
      rebate: Real, payoff: StrikedTypePayoff, exercise: Exercise);
  setupArguments(args: PricingEngine.Arguments): void;
  impliedVolatility(
      targetValue: Real, process: GeneralizedBlackScholesProcess,
      accuracy?: Real, maxEvaluations?: Size, minVol?: Volatility,
      maxVol?: Volatility): Volatility;
  protected _barrierType: DoubleBarrier.Type;
  protected _barrier_lo: Real;
  protected _barrier_hi: Real;
  protected _rebate: Real;
}
export declare namespace DoubleBarrierOptionEngine {
  class Arguments extends OneAssetOption.Arguments {
    constructor();
    validate(): void;
    barrierType: DoubleBarrier.Type;
    barrier_lo: Real;
    barrier_hi: Real;
    rebate: Real;
  }
  class Results extends OneAssetOption.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
    protected triggered(underlying: Real): boolean;
  }
}

export declare namespace DoubleBarrier {
  enum Type { KnockIn = 0, KnockOut = 1, KIKO = 2, KOKI = 3 }
}

export declare class PerturbativeBarrierOptionEngine extends
    BarrierOptionEngine.engine {
  constructor(
      process: GeneralizedBlackScholesProcess, order?: Natural,
      zeroGamma?: boolean);
  calculate(): void;
  private _process;
  private _order;
  private _zeroGamma;
}

export declare class QuantoDoubleBarrierOption extends DoubleBarrierOption {
  constructor(
      barrierType: DoubleBarrier.Type, barrier_lo: Real, barrier_hi: Real,
      rebate: Real, payoff: StrikedTypePayoff, exercise: Exercise);
  qvega(): Real;
  qrho(): Real;
  qlambda(): Real;
  fetchResults(r: PricingEngine.Results): void;
  setupExpired(): void;
  private _qvega;
  private _qrho;
  private _qlambda;
}
export declare namespace QuantoDoubleBarrierOption {
  class Arguments extends DoubleBarrierOptionEngine.Arguments {}
  class Results extends DoubleBarrierOptionEngine.Results {
    qvega: Real;
    qrho: Real;
    qlambda: Real;
  }
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class VannaVolgaBarrierEngine extends GenericEngine<
    DividendBarrierOption.Arguments, DividendBarrierOption.Results> {
  constructor(
      atmVol: Handle<DeltaVolQuote>, vol25Put: Handle<DeltaVolQuote>,
      vol25Call: Handle<DeltaVolQuote>, spotFX: Handle<Quote>,
      domesticTS: Handle<YieldTermStructure>,
      foreignTS: Handle<YieldTermStructure>, adaptVanDelta?: boolean,
      bsPriceWithSmile?: number);
  calculate(): void;
  private _atmVol;
  private _vol25Put;
  private _vol25Call;
  private _T;
  private _spotFX;
  private _domesticTS;
  private _foreignTS;
  private _adaptVanDelta;
  private _bsPriceWithSmile;
}

export declare class VannaVolgaDoubleBarrierEngine extends GenericEngine<
    DoubleBarrierOptionEngine.Arguments, DoubleBarrierOptionEngine.Results> {
  constructor(Engine: PricingEngine);
  vvdbeInit(
      atmVol: Handle<DeltaVolQuote>, vol25Put: Handle<DeltaVolQuote>,
      vol25Call: Handle<DeltaVolQuote>, spotFX: Handle<Quote>,
      domesticTS: Handle<YieldTermStructure>,
      foreignTS: Handle<YieldTermStructure>, adaptVanDelta?: boolean,
      bsPriceWithSmile?: Real, series?: Size): VannaVolgaDoubleBarrierEngine;
  Engine: PricingEngine;
}

export declare class VannaVolgaInterpolation extends Interpolation {
  constructor(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size, spot: Real,
      dDiscount: DiscountFactor, fDiscount: DiscountFactor, T: Time);
}
export declare class VannaVolga implements Interpolator {
  constructor(
      spot: Real, dDiscount: DiscountFactor, fDiscount: DiscountFactor,
      T: Time);
  interpolate(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size):
      Interpolation;
  private _spot;
  private _dDiscount;
  private _fDiscount;
  private _T;
  static requiredPoints: Size;
}

export declare class WulinYongDoubleBarrierEngine extends
    DoubleBarrierOption.engine {
  init1(process: GeneralizedBlackScholesProcess, series?: Size):
      WulinYongDoubleBarrierEngine;
}

export declare class BlackCallableFixedRateBondEngine extends
    CallableBond.engine {
  bcfrbeInit1(
      fwdYieldVol: Handle<Quote>, discountCurve: Handle<YieldTermStructure>):
      BlackCallableFixedRateBondEngine;
  bcfrbeInit2(
      yieldVolStructure: Handle<CallableBondVolatilityStructure>,
      discountCurve: Handle<YieldTermStructure>):
      BlackCallableFixedRateBondEngine;
  calculate(): void;
  private spotIncome;
  private forwardPriceVolatility;
  private _volatility;
  private _discountCurve;
}
export declare class BlackCallableZeroCouponBondEngine extends
    BlackCallableFixedRateBondEngine {
  bczcbeInit1(
      fwdYieldVol: Handle<Quote>, discountCurve: Handle<YieldTermStructure>):
      BlackCallableZeroCouponBondEngine;
  bczcbeInit2(
      yieldVolStructure: Handle<CallableBondVolatilityStructure>,
      discountCurve: Handle<YieldTermStructure>):
      BlackCallableZeroCouponBondEngine;
}

export declare class CallableBond extends Bond {
  constructor(
      settlementDays: Natural, schedule: Schedule,
      paymentDayCounter: DayCounter, issueDate?: Date,
      putCallSchedule?: CallabilitySchedule);
  callability(): CallabilitySchedule;
  impliedVolatility(
      targetValue: Real, discountCurve: Handle<YieldTermStructure>,
      accuracy: Real, maxEvaluations: Size, minVol: Volatility,
      maxVol: Volatility): Volatility;
  OAS(cleanPrice: Real, engineTS: Handle<YieldTermStructure>,
      dayCounter: DayCounter, compounding: Compounding, frequency: Frequency,
      settlement?: Date, accuracy?: Real, maxIterations?: Size,
      guess?: Rate): Spread;
  cleanPriceOAS(
      oas: Real, engineTS: Handle<YieldTermStructure>, dayCounter: DayCounter,
      compounding: Compounding, frequency: Frequency, settlement?: Date): Real;
  effectiveDuration(
      oas: Real, engineTS: Handle<YieldTermStructure>, dayCounter: DayCounter,
      compounding: Compounding, frequency: Frequency, bump?: Real): Real;
  effectiveConvexity(
      oas: Real, engineTS: Handle<YieldTermStructure>, dayCounter: DayCounter,
      compounding: Compounding, frequency: Frequency, bump?: Real): Real;
  setupArguments(args: PricingEngine.Arguments): void;
  protected _paymentDayCounter: DayCounter;
  protected _frequency: Frequency;
  protected _putCallSchedule: CallabilitySchedule;
  _blackEngine: PricingEngine;
  _blackVolQuote: RelinkableHandle<Quote>;
  protected _blackDiscountCurve: RelinkableHandle<YieldTermStructure>;
}
export declare namespace CallableBond {
  class Arguments extends Bond.Arguments {
    couponDates: Date[];
    couponAmounts: Real[];
    redemption: Real;
    redemptionDate: Date;
    paymentDayCounter: DayCounter;
    frequency: Frequency;
    putCallSchedule: CallabilitySchedule;
    callabilityPrices: Real[];
    callabilityDates: Date[];
    spread: Real;
    validate(): void;
  }
  class Results extends Bond.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
  class ImpliedVolHelper implements UnaryFunction<Volatility, Real> {
    constructor(bond: CallableBond, targetValue: Real);
    f(x: Volatility): Real;
    private _engine;
    private _targetValue;
    private _vol;
    private _results;
  }
  class NPVSpreadHelper implements UnaryFunction<Spread, Real> {
    constructor(bond: CallableBond);
    f(x: Spread): Real;
    private _bond;
    private _results;
  }
}
export declare class CallableFixedRateBond extends CallableBond {
  constructor(
      settlementDays: Natural, faceAmount: Real, schedule: Schedule,
      coupons: Rate[], accrualDayCounter: DayCounter,
      paymentConvention: BusinessDayConvention, redemption?: Real,
      issueDate?: Date, putCallSchedule?: CallabilitySchedule);
  setupArguments(args: PricingEngine.Arguments): void;
  private accrued;
}
export declare class CallableZeroCouponBond extends CallableFixedRateBond {
  constructor(
      settlementDays: Natural, faceAmount: Real, calendar: Calendar,
      maturityDate: Date, dayCounter: DayCounter,
      paymentConvention: BusinessDayConvention, redemption?: Real,
      issueDate?: Date, putCallSchedule?: CallabilitySchedule);
}

export declare class CallableBondConstantVolatility extends
    CallableBondVolatilityStructure {
  cbcvInit1(
      referenceDate: Date, volatility: Volatility,
      dayCounter: DayCounter): CallableBondConstantVolatility;
  cbcvInit2(
      referenceDate: Date, volatility: Handle<Quote>,
      dayCounter: DayCounter): CallableBondConstantVolatility;
  cbcvInit3(
      settlementDays: Natural, cal: Calendar, volatility: Volatility,
      dayCounter: DayCounter): CallableBondConstantVolatility;
  cbcvInit4(
      settlementDays: Natural, cal: Calendar, volatility: Handle<Quote>,
      dayCounter: DayCounter): CallableBondConstantVolatility;
}

export declare class CallableBondVolatilityStructure extends TermStructure {
  cbvsInit1(dc?: DayCounter, bdc?: BusinessDayConvention):
      CallableBondVolatilityStructure;
  cbvsInit2(
      referenceDate: Date, calendar?: Calendar, dc?: DayCounter,
      bdc?: BusinessDayConvention): CallableBondVolatilityStructure;
  cbvsInit3(
      settlementDays: Natural, calendar: Calendar, dc?: DayCounter,
      bdc?: BusinessDayConvention): CallableBondVolatilityStructure;
  volatility1(
      optionTime: Time, bondLength: Time, strike: Rate,
      extrapolate?: boolean): Volatility;
  blackVariance1(
      optionTime: Time, bondLength: Time, strike: Rate,
      extrapolate?: boolean): Volatility;
  volatility2(
      optionDate: Date, bondTenor: Period, strike: Rate,
      extrapolate?: boolean): Volatility;
  blackVariance2(
      optionDate: Date, bondTenor: Period, strike: Rate,
      extrapolate?: boolean): Volatility;
  smileSection1(optionDate: Date, bondTenor: Period): SmileSection;
  volatility3(
      optionTenor: Period, bondTenor: Period, strike: Rate,
      extrapolate?: boolean): Volatility;
  blackVariance3(
      optionTenor: Period, bondTenor: Period, strike: Rate,
      extrapolate?: boolean): Volatility;
  smileSection2(optionTenor: Period, bondTenor: Period): SmileSection;
  maxBondTenor(): Period;
  maxBondLength(): Time;
  minStrike(): Rate;
  maxStrike(): Rate;
  convertDates(optionDate: Date, bondTenor: Period): [Time, Time];
  businessDayConvention(): BusinessDayConvention;
  optionDateFromTenor(optionTenor: Period): Date;
  checkRange3(
      optionTime: Time, bondLength: Time, k: Rate, extrapolate: boolean): void;
  checkRange4(
      optionDate: Date, bondTenor: Period, k: Rate, extrapolate: boolean): void;
  protected smileSectionImpl(optionTime: Time, bondLength: Time): SmileSection;
  protected volatilityImpl1(optionTime: Time, bondLength: Time, strike: Rate):
      Volatility;
  protected volatilityImpl2(optionDate: Date, bondTenor: Period, strike: Rate):
      Volatility;
  private _bdc;
}

export declare class DiscretizedCallableFixedRateBond extends DiscretizedAsset {
}

export declare class TreeCallableFixedRateBondEngine extends
    LatticeShortRateModelEngine<CallableBond.Arguments, CallableBond.Results> {
  tcfrbeInit1(
      model: ShortRateModel, timeSteps: Size,
      termStructure?: Handle<YieldTermStructure>):
      TreeCallableFixedRateBondEngine;
  tcfrbeInit2(
      model: ShortRateModel, timeGrid: TimeGrid,
      termStructure?: Handle<YieldTermStructure>):
      TreeCallableFixedRateBondEngine;
}

export declare class CatBond extends Bond {
  cbInit(
      settlementDays: Natural, calendar: Calendar, issueDate: Date,
      notionalRisk: NotionalRisk): CatBond;
  setupArguments(args: PricingEngine.Arguments): void;
  fetchResults(r: PricingEngine.Results): void;
  lossProbability(): Real;
  expectedLoss(): Real;
  exhaustionProbability(): Real;
  protected _notionalRisk: NotionalRisk;
  protected _lossProbability: Real;
  protected _exhaustionProbability: Real;
  protected _expectedLoss: Real;
}
export declare namespace CatBond {
  class Arguments extends Bond.Arguments {
    startDate: Date;
    notionalRisk: NotionalRisk;
    validate(): void;
  }
  class Results extends Bond.Results {
    lossProbability: Real;
    exhaustionProbability: Real;
    expectedLoss: Real;
  }
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}
export declare class FloatingCatBond extends CatBond {
  fcbInit1(
      settlementDays: Natural, faceAmount: Real, schedule: Schedule,
      iborIndex: IborIndex, paymentDayCounter: DayCounter,
      notionalRisk: NotionalRisk, paymentConvention?: BusinessDayConvention,
      fixingDays?: Natural, gearings?: Real[], spreads?: Real[], caps?: Rate[],
      floors?: Rate[], inArrears?: boolean, redemption?: Real,
      issueDate?: Date): FloatingCatBond;
  fcbInit2(
      settlementDays: Natural, faceAmount: Real, startDate: Date,
      maturityDate: Date, couponFrequency: Frequency, calendar: Calendar,
      iborIndex: IborIndex, accrualDayCounter: DayCounter,
      notionalRisk: NotionalRisk, accrualConvention?: BusinessDayConvention,
      paymentConvention?: BusinessDayConvention, fixingDays?: Natural,
      gearings?: Real[], spreads?: Real[], caps?: Rate[], floors?: Rate[],
      inArrears?: boolean, redemption?: Real, issueDate?: Date, stubDate?: Date,
      rule?: DateGeneration.Rule, endOfMonth?: boolean): FloatingCatBond;
}

export declare class CatSimulation {
  constructor(start: Date, end: Date);
  nextPath(path: Array<[Integer, Real]>): boolean;
  protected _start: Date;
  protected _end: Date;
}
export declare class CatRisk {
  newSimulation(start: Date, end: Date): CatSimulation;
}
export declare class EventSetSimulation extends CatSimulation {
  constructor(
      events: Array<[Integer, Real]>, eventsStart: Date, eventsEnd: Date,
      start: Date, end: Date);
  nextPath(path: Array<[Integer, Real]>): boolean;
  private _events;
  private _eventsStart;
  private _eventsEnd;
  private _years;
  private _periodStart;
  private _periodEnd;
  private _i;
}
export declare class EventSet extends CatRisk {
  constructor(
      events: Array<[Integer, Real]>, eventsStart: Date, eventsEnd: Date);
  newSimulation(start: Date, end: Date): CatSimulation;
  private _events;
  private _eventsStart;
  private _eventsEnd;
}
export declare class BetaRiskSimulation extends CatSimulation {
  constructor(
      start: Date, end: Date, maxLoss: Real, lambda: Real, alpha: Real,
      beta: Real);
  nextPath(path: Array<[Integer, Real]>): boolean;
  generateBeta(): Real;
  private _maxLoss;
  private _dayCount;
  private _yearFraction;
  private _rng;
  private _exponential;
  private _gammaAlpha;
  private _gammaBeta;
}
export declare class BetaRisk extends CatRisk {
  constructor(maxLoss: Real, years: Real, mean: Real, stdDev: Real);
  newSimulation(start: Date, end: Date): CatSimulation;
  private _maxLoss;
  private _lambda;
  private _alpha;
  private _beta;
}

export declare class MonteCarloCatBondEngine extends CatBond.engine {
  constructor(
      catRisk: CatRisk, discountCurve?: Handle<YieldTermStructure>,
      includeSettlementDateFlows?: boolean);
  calculate(): void;
  discountCurve(): Handle<YieldTermStructure>;
  protected cashFlowRiskyValue(cf: CashFlow, notionalPath: NotionalPath): Real;
  protected npv(
      includeSettlementDateFlows: boolean, settlementDate: Date, npvDate: Date,
      ref: byRef): Real;
  protected pathNpv(
      includeSettlementDateFlows: boolean, settlementDate: Date,
      notionalPath: NotionalPath): Real;
  private _catRisk;
  private _discountCurve;
  private _includeSettlementDateFlows;
}
interface byRef {
  lossProbability: Real;
  exhaustionProbability: Real;
  expectedLoss: Real;
}


export declare class EventPaymentOffset {
  paymentDate(eventDate: Date): Date;
}
export declare class NoOffset extends EventPaymentOffset {
  paymentDate(eventDate: Date): Date;
}
export declare class NotionalPath {
  constructor();
  notionalRate(date: Date): Rate;
  reset(): void;
  addReduction(date: Date, newRate: Rate): void;
  loss(): Real;
  private _notionalRate;
}
export declare class NotionalRisk {
  constructor(paymentOffset: EventPaymentOffset);
  updatePath(events: Array<[Integer, Real]>, path: NotionalPath): void;
  protected _paymentOffset: EventPaymentOffset;
}
export declare class DigitalNotionalRisk extends NotionalRisk {
  constructor(paymentOffset: EventPaymentOffset, threshold: Real);
  updatePath(events: Array<[Integer, Real]>, path: NotionalPath): void;
  protected _threshold: Real;
}
export declare class ProportionalNotionalRisk extends NotionalRisk {
  constructor(
      paymentOffset: EventPaymentOffset, attachement: Real, exhaustion: Real);
  updatePath(events: Array<[Integer, Real]>, path: NotionalPath): void;
  protected _attachement: Real;
  protected _exhaustion: Real;
}

export declare type SecondaryCosts = Map<string, any>;
export declare type SecondaryCostAmounts = Map<string, Money>;
export declare class PricingError {
  constructor(errorLevel: PricingError.Level, error: string, detail: string);
  errorLevel: PricingError.Level;
  tradeId: string;
  error: string;
  detail: string;
}
export declare namespace PricingError {
  enum Level { Info = 0, Warning = 1, Error = 2, Fatal = 3 }
}
export declare type PricingErrors = PricingError[];
export declare class Commodity extends Instrument {
  constructor(secondaryCosts: SecondaryCosts);
  secondaryCostAmounts(): SecondaryCostAmounts;
  pricingErrors(): PricingErrors;
  addPricingError(
      errorLevel: PricingError.Level, error: string, detail?: string): void;
  protected _secondaryCosts: SecondaryCosts;
  protected _pricingErrors: PricingErrors;
  protected _secondaryCostAmounts: SecondaryCostAmounts;
}

export declare class CommodityCashFlow extends CashFlow {
  constructor(
      date: Date, discountedAmount: Money, undiscountedAmount: Money,
      discountedPaymentAmount: Money, undiscountedPaymentAmount: Money,
      discountFactor: Real, paymentDiscountFactor: Real, finalized: boolean);
  date(): Date;
  amount(): Real;
  currency(): Currency;
  discountedAmount(): Money;
  undiscountedAmount(): Money;
  discountedPaymentAmount(): Money;
  undiscountedPaymentAmount(): Money;
  discountFactor(): Real;
  paymentDiscountFactor(): Real;
  finalized(): boolean;
  accept(v: AcyclicVisitor): void;
  private _date;
  private _discountedAmount;
  private _undiscountedAmount;
  private _discountedPaymentAmount;
  private _undiscountedPaymentAmount;
  private _discountFactor;
  private _paymentDiscountFactor;
  private _finalized;
}

export declare class CommodityCurve extends TermStructure {
  ccInit1(
      name: string, commodityType: CommodityType, currency: Currency,
      unitOfMeasure: UnitOfMeasure, calendar: Calendar, dates: Date[],
      prices: Real[], dayCounter?: DayCounter): CommodityCurve;
  ccInit2(
      name: string, commodityType: CommodityType, currency: Currency,
      unitOfMeasure: UnitOfMeasure, calendar: Calendar,
      dayCounter?: DayCounter): CommodityCurve;
  name(): string;
  commodityType(): CommodityType;
  unitOfMeasure(): UnitOfMeasure;
  currency(): Currency;
  maxDate(): Date;
  times(): Time[];
  dates(): Date[];
  prices(): Real[];
  nodes(): Array<[Date, Real]>;
  empty(): boolean;
  setPrices(prices: Map<Date, Real>): void;
  setBasisOfCurve(basisOfCurve: CommodityCurve): void;
  price(d: Date, exchangeContracts: ExchangeContracts, nearbyOffset: Integer):
      Real;
  basisOfPrice(d: Date): Real;
  underlyingPriceDate(
      date: Date, exchangeContracts: ExchangeContracts,
      nearbyOffset: Integer): Date;
  basisOfCurve(): CommodityCurve;
  basisOfPriceImpl(t: Time): Real;
  priceImpl(t: Time): Real;
  private _name;
  private _commodityType;
  private _unitOfMeasure;
  private _currency;
  private _dates;
  private _times;
  private _data;
  private _interpolation;
  private _interpolator;
  private _basisOfCurve;
  private _basisOfCurveUomConversionFactor;
}

export declare class CommodityIndex extends ObserverObservable {
  protected _name: string;
  protected _commodityType: CommodityType;
  protected _unitOfMeasure: UnitOfMeasure;
  protected _currency: Currency;
  protected _calendar: Calendar;
  protected _lotQuantity: Real;
  protected _quotes: TimeSeries<Real>;
  protected _forwardCurve: CommodityCurve;
  protected _forwardCurveUomConversionFactor: Real;
  protected _exchangeContracts: ExchangeContracts;
  protected _nearbyOffset: Integer;
}

export declare class CommodityPricingHelper {
  static calculateFxConversionFactor(
      fromCurrency: Currency, toCurrency: Currency, evaluationDate: Date): Real;
  static calculateUomConversionFactor(
      commodityType: CommodityType, fromUnitOfMeasure: UnitOfMeasure,
      toUnitOfMeasure: UnitOfMeasure): Real;
  static calculateUnitCost(
      commodityType: CommodityType, unitCost: CommodityUnitCost,
      baseCurrency: Currency, baseUnitOfMeasure: UnitOfMeasure,
      evaluationDate: Date): Real;
  static createPricingPeriods(
      startDate: Date, endDate: Date, quantity: Quantity,
      deliverySchedule: EnergyCommodity.DeliverySchedule,
      qtyPeriodicity: EnergyCommodity.QuantityPeriodicity,
      paymentTerm: PaymentTerm, pricingPeriods: PricingPeriods): void;
}

export declare namespace CommoditySettings {
  let currency: Currency;
  let unitOfMeasure: UnitOfMeasure;
}

export declare class CommodityType {
  init1(): CommodityType;
  init2(code: string, name: string): CommodityType;
  code(): string;
  name(): string;
  empty(): boolean;
  protected _data: CommodityType.Data;
  static _commodityTypes: Map<string, CommodityType.Data>;
}
export declare namespace CommodityType {
  class Data {
    constructor(name: string, code: string);
    name: string;
    code: string;
  }
}
export declare class NullCommodityType extends CommodityType {
  constructor();
}

export declare class CommodityUnitCost {
  init(amount: Money, unitOfMeasure: UnitOfMeasure): CommodityUnitCost;
  amount(): Money;
  unitOfMeasure(): UnitOfMeasure;
  private _amount;
  private _unitOfMeasure;
}

export declare class DateInterval {
  init(startDate: Date, endDate: Date): DateInterval;
  startDate(): Date;
  endDate(): Date;
  isDateBetween(date: Date, includeFirst?: boolean, includeLast?: boolean):
      boolean;
  intersection(di: DateInterval): DateInterval;
  equal(rhs: DateInterval): boolean;
  _startDate: Date;
  _endDate: Date;
}

export declare class EnergyBasisSwap extends EnergySwap {}

export declare class EnergyDailyPosition {}
export declare class EnergyCommodity extends Commodity {}
export declare namespace EnergyCommodity {
  enum DeliverySchedule {
    Constant = 0,
    Window = 1,
    Hourly = 2,
    Daily = 3,
    Weekly = 4,
    Monthly = 5,
    Quarterly = 6,
    Yearly = 7
  }
  enum QuantityPeriodicity {
    Absolute = 0,
    PerHour = 1,
    PerDay = 2,
    PerWeek = 3,
    PerMonth = 4,
    PerQuarter = 5,
    PerYear = 6
  }
  enum PaymentSchedule {
    WindowSettlement = 0,
    MonthlySettlement = 1,
    QuarterlySettlement = 2,
    YearlySettlement = 3
  }
}

export declare class EnergyFuture extends EnergyCommodity {}

export declare class EnergySwap extends EnergyCommodity {}

export declare class EnergyVanillaSwap extends EnergySwap {}

export declare type ExchangeContracts = Map<Date, ExchangeContract>;
export declare class ExchangeContract {
  constructor(
      code: string, expirationDate: Date, underlyingStartDate: Date,
      underlyingEndDate: Date);
  code(): string;
  expirationDate(): Date;
  underlyingStartDate(): Date;
  underlyingEndDate(): Date;
  protected _code: string;
  protected _expirationDate: Date;
  protected _underlyingStartDate: Date;
  protected _underlyingEndDate: Date;
}

export declare class PaymentTerm {
  init(
      name: string, eventType: PaymentTerm.EventType, offsetDays: Integer,
      calendar: Calendar): PaymentTerm;
  name(): string;
  eventType(): PaymentTerm.EventType;
  offsetDays(): Integer;
  calendar(): Calendar;
  empty(): boolean;
  getPaymentDate(date: Date): Date;
  protected _data: PaymentTerm.Data;
  static _paymentTerms: Map<string, PaymentTerm.Data>;
}
export declare namespace PaymentTerm {
  enum EventType { TradeDate = 0, PricingDate = 1 }
  class Data {
    constructor(
        name: string, eventType: EventType, offsetDays: Integer,
        calendar: Calendar);
    name: string;
    eventType: EventType;
    offsetDays: Integer;
    calendar: Calendar;
  }
}

export declare class BarrelUnitOfMeasure extends UnitOfMeasure {
  constructor();
}
export declare class MTUnitOfMeasure extends UnitOfMeasure {
  constructor();
}
export declare class MBUnitOfMeasure extends UnitOfMeasure {
  constructor();
}
export declare class GallonUnitOfMeasure extends UnitOfMeasure {
  constructor();
}
export declare class LitreUnitOfMeasure extends UnitOfMeasure {
  constructor();
}
export declare class KilolitreUnitOfMeasure extends UnitOfMeasure {
  constructor();
}
export declare class TokyoKilolitreUnitOfMeasure extends UnitOfMeasure {
  constructor();
}

export declare type PricingPeriods = PricingPeriod[];
export declare class PricingPeriod extends DateInterval {
  constructor(
      startDate: Date, endDate: Date, paymentDate: Date, quantity: Quantity);
  paymentDate(): Date;
  quantity(): Quantity;
  private _paymentDate;
  private _quantity;
}

export declare class Quantity {
  init1(): Quantity;
  init2(
      commodityType: CommodityType, unitOfMeasure: UnitOfMeasure,
      amount: Real): Quantity;
  commodityType(): CommodityType;
  unitOfMeasure(): UnitOfMeasure;
  amount(): Real;
  rounded(): Quantity;
  plus(): Quantity;
  minus(): Quantity;
  mulScalar(x: Real): Quantity;
  divScalar(x: Real): Quantity;
  add(m: Quantity): Quantity;
  sub(m: Quantity): Quantity;
  div(m: Quantity): Real;
  equal(m: Quantity): boolean;
  lessThan(m: Quantity): boolean;
  lessOrEqual(m: Quantity): boolean;
  close(m: Quantity): boolean;
  close_enough(m: Quantity, n: Size): boolean;
  toString(): string;
  static conversionType: Quantity.ConversionType;
  static baseUnitOfMeasure: UnitOfMeasure;
  private _commodityType;
  private _unitOfMeasure;
  private _amount;
}
export declare namespace Quantity {
  enum ConversionType {
    NoConversion = 0,
    BaseUnitOfMeasureConversion = 1,
    AutomatedConversion = 2
  }
}

export declare class UnitOfMeasure {
  init1(): UnitOfMeasure;
  init2(name: string, code: string, unitType: UnitOfMeasure.Type):
      UnitOfMeasure;
  name(): string;
  code(): string;
  unitType(): UnitOfMeasure.Type;
  empty(): boolean;
  rounding(): Rounding;
  triangulationUnitOfMeasure(): UnitOfMeasure;
  protected _data: UnitOfMeasure.Data;
  private _unitsOfMeasure;
}
export declare namespace UnitOfMeasure {
  enum Type { Mass = 0, Volume = 1, Energy = 2, Quantity = 3 }
  class Data {
    constructor(
        name: string, code: string, unitType: Type,
        triangulationUnitOfMeasure?: UnitOfMeasure, rounding?: Rounding);
    name: string;
    code: string;
    unitType: Type;
    triangulationUnitOfMeasure: UnitOfMeasure;
    rounding: Rounding;
  }
}

export declare class UnitOfMeasureConversion {
  init1(
      commodityType: CommodityType, source: UnitOfMeasure,
      target: UnitOfMeasure, conversionFactor: Real): UnitOfMeasureConversion;
  init2(r1: UnitOfMeasureConversion, r2: UnitOfMeasureConversion):
      UnitOfMeasureConversion;
  source(): UnitOfMeasure;
  target(): UnitOfMeasure;
  commodityType(): CommodityType;
  type(): UnitOfMeasureConversion.Type;
  conversionFactor(): Real;
  code(): string;
  convert(quantity: Quantity): Quantity;
  static chain(r1: UnitOfMeasureConversion, r2: UnitOfMeasureConversion):
      UnitOfMeasureConversion;
  protected _data: UnitOfMeasureConversion.Data;
}
export declare namespace UnitOfMeasureConversion {
  enum Type { Direct = 0, Derived = 1 }
  class Data {
    init1(
        commodityType: CommodityType, source: UnitOfMeasure,
        target: UnitOfMeasure, conversionFactor: Real, type: Type): Data;
    init2(r1: UnitOfMeasureConversion, r2: UnitOfMeasureConversion): Data;
    commodityType: CommodityType;
    source: UnitOfMeasure;
    target: UnitOfMeasure;
    conversionFactor: Real;
    type: Type;
    code: string;
    conversionFactorChain: [UnitOfMeasureConversion, UnitOfMeasureConversion];
  }
}

export declare namespace UnitOfMeasureConversionManager {
  function lookup(
      commodityType: CommodityType, source: UnitOfMeasure,
      target: UnitOfMeasure,
      type?: UnitOfMeasureConversion.Type): UnitOfMeasureConversion;
  function add(c: UnitOfMeasureConversion): void;
  function clear(): void;
  function addKnownConversionFactors(): void;
}

export declare class BinomialConvertibleEngine extends
    ConvertibleBond.option.engine {
  constructor(T: any);
  bceInit(process: GeneralizedBlackScholesProcess, timeSteps: Size):
      BinomialConvertibleEngine;
  calculate(): void;
  T: any;
  private _process;
  private _timeSteps;
}

export declare class SoftCallability extends Callability {
  constructor(price: Callability.Price, date: Date, trigger: Real);
  trigger(): Real;
  private _trigger;
}
export declare class ConvertibleBond extends Bond {
  constructor(
      exercise: Exercise, conversionRatio: Real, dividends: DividendSchedule,
      callability: CallabilitySchedule, creditSpread: Handle<Quote>,
      issueDate: Date, settlementDays: Natural, schedule: Schedule,
      redemption: Real);
  conversionRatio(): Real;
  dividends(): DividendSchedule;
  callability(): CallabilitySchedule;
  creditSpread(): Handle<Quote>;
  performCalculations(): void;
  protected _conversionRatio: Real;
  protected _callability: CallabilitySchedule;
  protected _dividends: DividendSchedule;
  protected _creditSpread: Handle<Quote>;
  protected _option: ConvertibleBond.option;
}
export declare namespace ConvertibleBond {
  class option extends OneAssetOption {
    constructor(
        bond: ConvertibleBond, exercise: Exercise, conversionRatio: Real,
        dividends: DividendSchedule, callability: CallabilitySchedule,
        creditSpread: Handle<Quote>, cashflows: Leg, dayCounter: DayCounter,
        schedule: Schedule, issueDate: Date, settlementDays: Natural,
        redemption: Real);
    setupArguments(args: PricingEngine.Arguments): void;
    private _bond;
    private _conversionRatio;
    private _callability;
    private _dividends;
    private _creditSpread;
    _cashflows: Leg;
    _dayCounter: DayCounter;
    private _issueDate;
    _schedule: Schedule;
    private _settlementDays;
    private _redemption;
  }
  namespace option {
    class Arguments extends OneAssetOption.Arguments {
      constructor();
      validate(): void;
      conversionRatio: Real;
      creditSpread: Handle<Quote>;
      dividends: DividendSchedule;
      dividendDates: Date[];
      callabilityDates: Date[];
      callabilityTypes: Callability.Type[];
      callabilityPrices: Real[];
      callabilityTriggers: Real[];
      couponDates: Date[];
      couponAmounts: Real[];
      issueDate: Date;
      settlementDate: Date;
      settlementDays: Natural;
      redemption: Real;
    }
    class Results extends OneAssetOption.Results {}
    class engine extends GenericEngine<Arguments, Results> {
      constructor();
    }
  }
}
export declare class ConvertibleZeroCouponBond extends ConvertibleBond {
  constructor(
      exercise: Exercise, conversionRatio: Real, dividends: DividendSchedule,
      callability: CallabilitySchedule, creditSpread: Handle<Quote>,
      issueDate: Date, settlementDays: Natural, dayCounter: DayCounter,
      schedule: Schedule, redemption?: Real);
}
export declare class ConvertibleFixedCouponBond extends ConvertibleBond {
  constructor(
      exercise: Exercise, conversionRatio: Real, dividends: DividendSchedule,
      callability: CallabilitySchedule, creditSpread: Handle<Quote>,
      issueDate: Date, settlementDays: Natural, coupons: Rate[],
      dayCounter: DayCounter, schedule: Schedule, redemption?: Real);
}
export declare class ConvertibleFloatingRateBond extends ConvertibleBond {
  constructor(
      exercise: Exercise, conversionRatio: Real, dividends: DividendSchedule,
      callability: CallabilitySchedule, creditSpread: Handle<Quote>,
      issueDate: Date, settlementDays: Natural, index: IborIndex,
      fixingDays: Natural, spreads: Spread[], dayCounter: DayCounter,
      schedule: Schedule, redemption?: Real);
}

export declare class DiscretizedConvertible extends DiscretizedAsset {
  constructor(
      args: ConvertibleBond.option.Arguments,
      process: GeneralizedBlackScholesProcess, grid?: TimeGrid);
  reset(size: Size): void;
  conversionProbability: Real[];
  spreadAdjustedRate: Real[];
  dividendValues: Real[];
  postAdjustValuesImpl(): void;
  protected _conversionProbability: Real[];
  protected _spreadAdjustedRate: Real[];
  protected _dividendValues: Real[];
}

export declare class TsiveriotisFernandesLattice<T extends TreeLatticeImpl>
    extends BlackScholesLattice<T> {
  constructor(
      tree: T, riskFreeRate: Rate, end: Time, steps: Size, creditSpread: Spread,
      volatility: Volatility, divYield: Spread);
  creditSpread(): Spread;
  protected stepback2(
      i: Size, values: Real[], conversionProbability: Real[],
      spreadAdjustedRate: Real[], newValues: Real[],
      newConversionProbability: Real[], newSpreadAdjustedRate: Real[]): void;
  rollback(asset: DiscretizedAsset, to: Time): void;
  partialRollback(asset: DiscretizedAsset, to: Time): void;
  private _creditSpread;
}

export declare class CmsSpreadCoupon extends FloatingRateCoupon {
  constructor(
      paymentDate: Date, nominal: Real, startDate: Date, endDate: Date,
      fixingDays: Natural, index: SwapSpreadIndex, gearing?: Real,
      spread?: Spread, refPeriodStart?: Date, refPeriodEnd?: Date,
      dayCounter?: DayCounter, isInArrears?: boolean);
  swapSpreadIndex(): SwapSpreadIndex;
  accept(v: AcyclicVisitor): void;
  _index: SwapSpreadIndex;
}
export declare class CappedFlooredCmsSpreadCoupon extends CappedFlooredCoupon {
  constructor(
      paymentDate: Date, nominal: Real, startDate: Date, endDate: Date,
      fixingDays: Natural, index: SwapSpreadIndex, gearing?: Real,
      spread?: Spread, cap?: Rate, floor?: Rate, refPeriodStart?: Date,
      refPeriodEnd?: Date, dayCounter?: DayCounter, isInArrears?: boolean);
  accept(v: AcyclicVisitor): void;
}
export declare class CmsSpreadLeg implements NullaryFunction<Leg> {
  constructor(schedule: Schedule, swapSpreadIndex: SwapSpreadIndex);
  withNotionals1(notional: Real): CmsSpreadLeg;
  withNotionals2(notionals: Real[]): CmsSpreadLeg;
  withPaymentDayCounter(dayCounter: DayCounter): CmsSpreadLeg;
  withPaymentAdjustment(convention: BusinessDayConvention): CmsSpreadLeg;
  withFixingDays1(fixingDays: Natural): CmsSpreadLeg;
  withFixingDays2(fixingDays: Natural[]): CmsSpreadLeg;
  withGearings1(gearing: Real): CmsSpreadLeg;
  withGearings2(gearings: Real[]): CmsSpreadLeg;
  withSpreads1(spread: Spread): CmsSpreadLeg;
  withSpreads2(spreads: Spread[]): CmsSpreadLeg;
  withCaps1(cap: Rate): CmsSpreadLeg;
  withCaps2(caps: Rate[]): CmsSpreadLeg;
  withFloors1(floor: Rate): CmsSpreadLeg;
  withFloors2(floors: Rate[]): CmsSpreadLeg;
  inArrears(flag?: boolean): CmsSpreadLeg;
  withZeroPayments(flag?: boolean): CmsSpreadLeg;
  f(): Leg;
  private _schedule;
  private _swapSpreadIndex;
  private _notionals;
  private _paymentDayCounter;
  private _paymentAdjustment;
  private _fixingDays;
  private _gearings;
  private _spreads;
  private _caps;
  private _floors;
  private _inArrears;
  private _zeroPayments;
}
export declare class CmsSpreadCouponPricer extends FloatingRateCouponPricer {
  constructor(correlation?: Handle<Quote>);
  correlation(): Handle<Quote>;
  setCorrelation(correlation?: Handle<Quote>): void;
  private _correlation;
}

export declare class DigitalCmsSpreadCoupon extends DigitalCoupon {
  constructor(
      underlying: CmsSpreadCoupon, callStrike?: Rate,
      callPosition?: Position.Type, isCallATMIncluded?: boolean,
      callDigitalPayoff?: Rate, putStrike?: Rate, putPosition?: Position.Type,
      isPutATMIncluded?: boolean, putDigitalPayoff?: Rate,
      replication?: DigitalReplication);
  accept(v: AcyclicVisitor): void;
}
export declare class DigitalCmsSpreadLeg implements NullaryFunction<Leg> {
  constructor(schedule: Schedule, index: SwapSpreadIndex);
  withNotionals1(notional: Real): DigitalCmsSpreadLeg;
  withNotionals2(notionals: Real[]): DigitalCmsSpreadLeg;
  withPaymentDayCounter(dayCounter: DayCounter): DigitalCmsSpreadLeg;
  withPaymentAdjustment(convention: BusinessDayConvention): DigitalCmsSpreadLeg;
  withFixingDays1(fixingDays: Natural): DigitalCmsSpreadLeg;
  withFixingDays2(fixingDays: Natural[]): DigitalCmsSpreadLeg;
  withGearings1(gearing: Real): DigitalCmsSpreadLeg;
  withGearings2(gearings: Real[]): DigitalCmsSpreadLeg;
  withSpreads1(spread: Spread): DigitalCmsSpreadLeg;
  withSpreads2(spreads: Spread[]): DigitalCmsSpreadLeg;
  inArrears(flag?: boolean): DigitalCmsSpreadLeg;
  withCallStrikes1(strike: Rate): DigitalCmsSpreadLeg;
  withCallStrikes2(strikes: Rate[]): DigitalCmsSpreadLeg;
  withCallATM(flag?: boolean): DigitalCmsSpreadLeg;
  withCallPayoffs1(payoff: Rate): DigitalCmsSpreadLeg;
  withCallPayoffs2(payoffs: Rate[]): DigitalCmsSpreadLeg;
  withPutStrikes1(strike: Rate): DigitalCmsSpreadLeg;
  withPutStrikes2(strikes: Rate[]): DigitalCmsSpreadLeg;
  withLongPutOption(type: Position.Type): DigitalCmsSpreadLeg;
  withPutATM(flag?: boolean): DigitalCmsSpreadLeg;
  withPutPayoffs1(payoff: Rate): DigitalCmsSpreadLeg;
  withPutPayoffs2(payoffs: Rate[]): DigitalCmsSpreadLeg;
  withReplication(replication?: DigitalReplication): DigitalCmsSpreadLeg;
  f(): Leg;
  private _schedule;
  private _index;
  private _notionals;
  private _paymentDayCounter;
  private _paymentAdjustment;
  private _fixingDays;
  private _gearings;
  private _spreads;
  private _inArrears;
  private _callStrikes;
  private _callPayoffs;
  private _longCallOption;
  private _callATM;
  private _putStrikes;
  private _putPayoffs;
  private _longPutOption;
  private _putATM;
  private _replication;
}

export declare class LognormalCmsSpreadPricer extends CmsSpreadCouponPricer {
  constructor(
      cmsPricer: CmsCouponPricer, correlation: Handle<Quote>,
      couponDiscountCurve?: Handle<YieldTermStructure>,
      integrationPoints?: Size, volatilityType?: VolatilityType, shift1?: Real,
      shift2?: Real);
  swapletPrice(): Real;
  swapletRate(): Rate;
  capletPrice(effectiveCap: Rate): Real;
  capletRate(effectiveCap: Rate): Rate;
  floorletPrice(effectiveFloor: Rate): Real;
  floorletRate(effectiveFloor: Rate): Rate;
  flushCache(): void;
  initialize(coupon: FloatingRateCoupon): void;
  private optionletPrice;
  integrand(x: Real): Real;
  integrand_normal(x: Real): Real;
  private _privateObserver;
  private _cmsPricer;
  private _couponDiscountCurve;
  private _coupon;
  private _today;
  private _fixingDate;
  private _paymentDate;
  private _fixingTime;
  private _gearing;
  private _spread;
  private _spreadLegValue;
  private _discount;
  private _index;
  private _cnd;
  private _integrator;
  private _swapRate1;
  private _swapRate2;
  private _gearing1;
  private _gearing2;
  private _adjustedRate1;
  private _adjustedRate2;
  private _vol1;
  private _vol2;
  private _mu1;
  private _mu2;
  private _rho;
  private _inheritedVolatilityType;
  private _volType;
  private _shift1;
  private _shift2;
  private _phi;
  private _a;
  private _b;
  private _s1;
  private _s2;
  private _m1;
  private _m2;
  private _v1;
  private _v2;
  private _k;
  private _alpha;
  private _psi;
  private _optionType;
  private _c1;
  private _c2;
  private _cache;
}

export declare class ProxyIbor extends IborIndex {
  constructor(
      familyName: string, tenor: Period, settlementDays: Natural,
      currency: Currency, fixingCalendar: Calendar,
      convention: BusinessDayConvention, endOfMonth: boolean,
      dayCounter: DayCounter, gearing: Handle<Quote>, iborIndex: IborIndex,
      spread: Handle<Quote>);
  protected forecastFixing(fixingDate: Date): Rate;
  private _gearing;
  private _iborIndex;
  private _spread;
}

export declare class BlackIborQuantoCouponPricer extends BlackIborCouponPricer {
  constructor(
      fxRateBlackVolatility: Handle<BlackVolTermStructure>,
      underlyingFxCorrelation: Handle<Quote>,
      capletVolatility: Handle<OptionletVolatilityStructure>);
  protected adjustedFixing(fixing?: Rate): Rate;
  private _fxRateBlackVolatility;
  private _underlyingFxCorrelation;
}

export declare class StrippedCappedFlooredCoupon extends FloatingRateCoupon {
  constructor(underlying: CappedFlooredCoupon);
  rate(): Rate;
  convexityAdjustment(): Rate;
  cap(): Rate;
  floor(): Rate;
  effectiveCap(): Rate;
  effectiveFloor(): Rate;
  update(): void;
  accept(v: AcyclicVisitor): void;
  isCap(): boolean;
  isFloor(): boolean;
  isCollar(): boolean;
  setPricer(pricer: FloatingRateCouponPricer): void;
  underlying(): CappedFlooredCoupon;
  protected _underlying: CappedFlooredCoupon;
}
export declare class StrippedCappedFlooredCouponLeg implements
    NullaryFunction<Leg> {
  constructor(underlyingLeg: Leg);
  f(): Leg;
  private _underlyingLeg;
}

export declare class SubPeriodsCoupon extends FloatingRateCoupon {
  constructor(
      paymentDate: Date, nominal: Real, index: IborIndex, startDate: Date,
      endDate: Date, fixingDays: Natural, dayCounter: DayCounter, gearing: Real,
      couponSpread: Rate, rateSpread: Rate, refPeriodStart: Date,
      refPeriodEnd: Date);
  rateSpread(): Spread;
  startTime(): Real;
  endTime(): Real;
  observations(): Size;
  observationDates(): Date[];
  observationTimes(): Time[];
  observationsSchedule(): Schedule;
  accept(v: AcyclicVisitor): void;
  private _startTime;
  private _endTime;
  private _observationsSchedule;
  private _observationDates;
  private _observationTimes;
  private _observations;
  private _rateSpread;
}
export declare class SubPeriodsPricer extends FloatingRateCouponPricer {
  swapletRate(): Rate;
  capletPrice(effectiveCap: Rate): Real;
  capletRate(effectiveCap: Rate): Real;
  floorletPrice(effectiveFloor: Rate): Real;
  floorletRate(effectiveFloor: Rate): Real;
  initialize(coupon: FloatingRateCoupon): void;
  protected _coupon: SubPeriodsCoupon;
  protected _startTime: Time;
  protected _endTime: Time;
  protected _accrualFactor: Real;
  protected _observationTimes: Time[];
  protected _observationCvg: Real[];
  protected _initialValues: Real[];
  protected _observationIndexStartDates: Date[];
  protected _observationIndexEndDates: Date[];
  protected _observations: Size;
  protected _discount: Real;
  protected _gearing: Real;
  protected _spread: Spread;
  protected _spreadLegValue: Real;
}
export declare class AveragingRatePricer extends SubPeriodsPricer {
  swapletPrice(): Real;
}
export declare class CompoundingRatePricer extends SubPeriodsPricer {
  swapletPrice(): Real;
}

export declare class SwapSpreadIndex extends InterestRateIndex {
  constructor(
      familyName: string, swapIndex1: SwapIndex, swapIndex2: SwapIndex,
      gearing1?: Real, gearing2?: Real);
  maturityDate(valueDate: Date): Date;
  forecastFixing(fixingDate: Date): Rate;
  pastFixing(fixingDate: Date): Rate;
  // allowsNativeFixings(): boolean;
  swapIndex1(): SwapIndex;
  swapIndex2(): SwapIndex;
  gearing1(): Real;
  gearing2(): Real;
  private _swapIndex1;
  private _swapIndex2;
  private _gearing1;
  private _gearing2;
}

export declare class BaseCorrelationLossModel extends DefaultLossModelObserver {
  constructor(BaseModel_T: any, Corr2DInt_T: Interpolator2D);
  bclmInit(
      correlTS: Handle<BaseCorrelationTermStructure>, recoveries: Real[],
      traits?: any): BaseCorrelationLossModel;
  update(): void;
  resetModel(): void;
  setupModels(): void;
  expectedTrancheLoss(d: Date): Real;
  BaseModel_T: any;
  Corr2DInt_T: Interpolator2D;
  private _attachRatio;
  private _detachRatio;
  private _remainingNotional;
  private _localCorrelationAttach;
  private _localCorrelationDetach;
  private _basketAttach;
  private _basketDetach;
  private _recoveries;
  private _correlTS;
  _copulaTraits: any;
  private _scalarCorrelModelAttach;
  private _scalarCorrelModelDetach;
}
export declare class GaussianLHPFlatBCLM extends BaseCorrelationLossModel {
  constructor();
}

export declare class BaseCorrelationTermStructure extends
    CorrelationTermStructure {
  constructor(Interpolator2D_T: Interpolator2D);
  bctsInit(
      settlementDays: Natural, cal: Calendar, bdc: BusinessDayConvention,
      tenors: Period[], lossLevel: Real[], correls: Array<Array<Handle<Quote>>>,
      dc?: DayCounter): BaseCorrelationTermStructure;
  correlationSize(): Size;
  checkTrancheTenors(): void;
  checkLosses(): void;
  initializeTrancheTimes(): void;
  checkInputs(volRows: Size, volsColumns: Size): void;
  registerWithMarketData(): void;
  update(): void;
  updateMatrix(): void;
  maxDate(): Date;
  correlation1(d: Date, lossLevel: Real, extrapolate?: boolean): Real;
  correlation2(t: Time, lossLevel: Real, extrapolate?: boolean): Real;
  private setupInterpolation;
  Interpolator2D_T: Interpolator2D;
  private _correlHandles;
  private _correlations;
  private _interpolation;
  private _nTrancheTenors;
  private _nLosses;
  private _tenors;
  private _lossLevel;
  private _trancheDates;
  private _trancheTimes;
}

export declare class Basket extends LazyObject {
  init(
      refDate: Date, names: string[], notionals: Real[], pool: Pool,
      attachment?: Real, detachment?: Real, claim?: Claim): Basket;
  update(): void;
  computeBasket(): void;
  size(): Size;
  names(): string[];
  notionals(): Real[];
  exposure(name: string, d?: Date): Real;
  pool(): Pool;
  defaultKeys(): DefaultProbKey[];
  refDate(): Date;
  attachmentRatio(): Real;
  detachmentRatio(): Real;
  basketNotional(): Real;
  trancheNotional(): Real;
  attachmentAmount(): Real;
  detachmentAmount(): Real;
  claim(): Claim;
  probabilities(d: Date): Probability[];
  settledLoss1(): Real;
  settledLoss2(endDate: Date): Real;
  cumulatedLoss1(): Real;
  cumulatedLoss2(endDate: Date): Real;
  remainingNotional1(): Real;
  remainingNotional2(endDate: Date): Real;
  remainingNotionals1(): Real[];
  remainingNotionals2(endDate: Date): Real[];
  remainingNames1(): string[];
  remainingNames2(endDate: Date): string[];
  remainingDefaultKeys1(): DefaultProbKey[];
  remainingDefaultKeys2(endDate: Date): DefaultProbKey[];
  remainingSize1(): Size;
  remainingProbabilities(d: Date): Probability[];
  remainingAttachmentAmount1(): Real;
  remainingAttachmentAmount2(endDate: Date): Real;
  remainingDetachmentAmount1(): Real;
  remainingDetachmentAmount2(d: Date): Real;
  remainingTrancheNotional(): Real;
  remainingTrancheNotional2(endDate: Date): Real;
  liveList1(): Size[];
  liveList2(endDate: Date): Size[];
  setLossModel(lossModel: DefaultLossModel): void;
  expectedTrancheLoss(d: Date): Real;
  probOverLoss(d: Date, lossFraction: Real): Probability;
  percentile(d: Date, prob: Probability): Real;
  expectedShortfall(d: Date, prob: Probability): Real;
  splitVaRLevel(date: Date, loss: Real): Real[];
  lossDistribution(d: Date): Map<Real, Probability>;
  defaultCorrelation(d: Date, iName: Size, jName: Size): Real;
  probsBeingNthEvent(n: Size, d: Date): Probability[];
  probAtLeastNEvents(n: Size, d: Date): Probability;
  recoveryRate(d: Date, iName: Size): Real;
  performCalculations(): void;
  private _notionals;
  private _pool;
  private _claim;
  private _attachmentRatio;
  private _detachmentRatio;
  private _basketNotional;
  private _attachmentAmount;
  private _detachmentAmount;
  private _trancheNotional;
  private _evalDateSettledLoss;
  private _evalDateRemainingNot;
  private _evalDateAttachAmount;
  private _evalDateDetachAmmount;
  private _evalDateLiveList;
  private _evalDateLiveNotionals;
  private _evalDateLiveNames;
  private _evalDateLiveKeys;
  private _refDate;
  private _lossModel;
}

export declare class BinomialLossModel extends DefaultLossModel {
  constructor(LLM: any);
  blmInit(copula: any): BinomialLossModel;
  resetModel(): void;
  expectedDistribution(date: Date): Real[];
  lossPoints(d: Date): Real[];
  lossDistribution(d: Date): Map<Real, Probability>;
  percentile(d: Date, perc: Real): Real;
  expectedShortfall(d: Date, perctl: Real): Real;
  expectedTrancheLoss(d: Date): Real;
  averageLoss(d: Date, reminingNots: Real[], mktFctrs: Real[]): Real;
  condTrancheLoss(
      d: Date, lossVals: Real[], bsktNots: Real[],
      uncondDefProbsInv: Probability[], mkf: Real[]): Real;
  expConditionalLgd(d: Date, mktFactors: Real[]): Real[];
  lossProbability(
      date: Date, bsktNots: Real[], uncondDefProbInv: Real[],
      mktFactors: Real[]): Real[];
  LLM: any;
  protected _copula: any;
  protected _attachAmount: Real;
  protected _detachAmount: Real;
}
export declare class GaussianBinomialLossModel extends BinomialLossModel {
  constructor();
}
export declare class TBinomialLossModel extends BinomialLossModel {
  constructor();
}

export declare class BlackCdsOptionEngine extends CdsOptionEngine.engine {
  constructor(
      probability: Handle<DefaultProbabilityTermStructure>, recoveryRate: Real,
      termStructure: Handle<YieldTermStructure>, volatility: Handle<Quote>);
  calculate(): void;
  termStructure(): Handle<YieldTermStructure>;
  volatility(): Handle<Quote>;
  private _probability;
  private _recoveryRate;
  private _termStructure;
  private _volatility;
}

export declare class CDO extends Instrument {
  constructor(
      attachment: Real, detachment: Real, nominals: Real[],
      basket: Array<Handle<DefaultProbabilityTermStructure>>,
      copula: Handle<OneFactorCopula>, protectionSeller: boolean,
      premiumSchedule: Schedule, premiumRate: Rate, dayCounter: DayCounter,
      recoveryRate: Rate, upfrontPremiumRate: Rate,
      yieldTS: Handle<YieldTermStructure>, nBuckets: Size,
      integrationStep?: Period);
  nominal(): Real;
  lgd(): Real;
  attachment(): Real;
  detachment(): Real;
  nominals(): Real[];
  size(): Size;
  isExpired(): boolean;
  fairPremium(): Rate;
  premiumValue(): Rate;
  protectionValue(): Rate;
  error(): Size;
  setupExpired(): void;
  performCalculations(): void;
  expectedTrancheLoss(d: Date): Real;
  private _attachment;
  private _detachment;
  private _nominals;
  private _basket;
  private _copula;
  private _protectionSeller;
  private _premiumSchedule;
  private _premiumRate;
  private _dayCounter;
  private _recoveryRate;
  private _upfrontPremiumRate;
  private _yieldTS;
  private _nBuckets;
  private _integrationStep;
  private _lgds;
  private _nominal;
  private _lgd;
  private _xMax;
  private _xMin;
  private _error;
  private _premiumValue;
  private _protectionValue;
  private _upfrontPremiumValue;
}

export declare class CdsOption extends Option {
  constructor(swap: CreditDefaultSwap, exercise: Exercise, knocksOut?: boolean);
  isExpired(): boolean;
  setupExpired(): void;
  setupArguments(args: PricingEngine.Arguments): void;
  fetchResults(r: PricingEngine.Results): void;
  underlyingSwap(): CreditDefaultSwap;
  atmRate(): Rate;
  riskyAnnuity(): Rate;
  impliedVolatility(
      targetValue: Real, termStructure: Handle<YieldTermStructure>,
      probability: Handle<DefaultProbabilityTermStructure>, recoveryRate: Real,
      accuracy?: Real, maxEvaluations?: Size, minVol?: Volatility,
      maxVol?: Volatility): Volatility;
  private _swap;
  private _knocksOut;
  private _riskyAnnuity;
}

export declare namespace CdsOptionEngine {
  class Arguments extends CdsOptionArguments {
    validate(): void;
    knocksOut: boolean;
    swap: CreditDefaultSwap;
  }
  class Results extends Option.Results {
    riskyAnnuity: Real;
    reset(): void;
  }
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

declare class CdsOptionArguments implements PricingEngine.Arguments,
                                            CreditDefaultSwapEngine.Arguments,
                                            Option.Arguments {
  validate(): void;
  payoff: Payoff;
  exercise: Exercise;
  side: Protection.Side;
  notional: Real;
  upfront: Rate;
  spread: Rate;
  leg: Leg;
  upfrontPayment: CashFlow;
  accrualRebate: CashFlow;
  settlesAccrual: boolean;
  paysAtDefaultTime: boolean;
  claim: Claim;
  protectionStart: Date;
  maturity: Date;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
}

export declare class ConstantLossLatentmodel extends DefaultLatentModel {
  constructor(copulaPolicy: any);
  cllmInit1(
      factorWeights: Real[][], recoveries: Real[],
      integralType: LatentModelIntegrationType,
      ini: any): ConstantLossLatentmodel;
  cllmInit2(
      mktCorrel: Handle<Quote>, recoveries: Real[],
      integralType: LatentModelIntegrationType, nVariables: Size,
      ini?: any): ConstantLossLatentmodel;
  conditionalRecovery1(d: Date, iName: Size, mktFactors: Real[]): Real;
  conditionalRecovery2(
      uncondDefP: Probability, iName: Size, mktFactors: Real[]): Real;
  conditionalRecoveryInvP(invUncondDefP: Real, iName: Size, mktFactors: Real[]):
      Real;
  conditionalRecovery3(latentVarSample: Real, iName: Size, d: Date): Real;
  recoveries(): Real[];
  expectedRecovery(d: Date, iName: Size, defKeys: DefaultProbKey): Real;
  _recoveries: Real[];
}
export declare class GaussianConstantLossLM extends ConstantLossLatentmodel {
  constructor();
}
export declare class TConstantLossLM extends ConstantLossLatentmodel {
  constructor();
}

declare class ConstantLossLatentmodelDefaultLossModel implements
    Observable, Observer, LatentModel, DefaultLatentModel,
    ConstantLossLatentmodel, DefaultLossModel {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  expectedTrancheLoss(d: Date): Real;
  probOverLoss(d: Date, lossFraction: Real): Probability;
  percentile(d: Date, percentile: Real): Real;
  expectedShortfall(d: Date, percentile: Real): Real;
  splitVaRLevel: (d: Date, loss: Real) => Real[];
  splitESFLevel: (d: Date, loss: Real) => Real[];
  lossDistribution: (d: Date) => Map<Real, Probability>;
  densityTrancheLoss: (d: Date, lossFraction: Real) => Real;
  probsBeingNthEvent: (n: Size, d: Date) => Probability[];
  defaultCorrelation(d: Date, iName: Size, jName: Size): Real;
  probAtLeastNEvents(n: Size, d: Date): Probability;
  expectedRecovery(d: Date, iName: Size, key: DefaultProbKey): Real;
  setBasket: (bskt: Basket) => void;
  resetModel(): void;
  init: (copulaPolicyImpl: any) => LatentModel;
  lmInit1: (factorsWeights: Real[][], ini?: any) => LatentModel;
  lmInit2: (factorsWeight: Real[], ini?: any) => LatentModel;
  lmInit3: (correlSqr: Real, nVariables: Size, ini?: any) => LatentModel;
  lmInit4:
      (singleFactorCorrel: Handle<Quote>, nVariables: Size,
       ini?: any) => LatentModel;
  size: () => Size;
  numFactors: () => Size;
  numTotalFactors: () => Size;
  factorWeights: () => Real[][];
  idiosyncFctrs: () => Real[];
  latentVariableCorrel: (iVar1: Size, iVar2: Size) => Real;
  integration: () => LMIntegration;
  integratedExpectedValue1: (f: UnaryFunction<Real[], Real>) => Real;
  integratedExpectedValue2: (f: UnaryFunction<Real[], Real[]>) => Real[];
  cumulativeY: (val: Real, iVariable: Size) => Probability;
  cumulativeZ: (z: Real) => Probability;
  density: (m: Real[]) => Probability;
  inverseCumulativeDensity: (p: Probability, iFactor: Size) => Real;
  inverseCumulativeY: (p: Probability, iVariable: Size) => Real;
  inverseCumulativeZ: (p: Probability) => Real;
  allFactorCumulInverter: (probs: Real[]) => Real[];
  latentVarValue: (allFactors: Real[], iVar: Size) => Real;
  copula: () => any;
  cllmInit1:
      (factorWeights: Real[][], recoveries: Real[],
       integralType: LatentModelIntegrationType,
       ini?: any) => ConstantLossLatentmodel;
  cllmInit2:
      (mktCorrel: Handle<Quote>, recoveries: Real[],
       integralType: LatentModelIntegrationType, nVariables: Size,
       ini?: any) => ConstantLossLatentmodel;
  conditionalRecovery1: (d: Date, iName: Size, mktFactors: Real[]) => Real;
  conditionalRecovery2:
      (uncondDefP: Probability, iName: Size, mktFactors: Real[]) => Real;
  conditionalRecoveryInvP:
      (invUncondDefP: Real, iName: Size, mktFactors: Real[]) => Real;
  conditionalRecovery3: (latentVarSample: Real, iName: Size, d: Date) => Real;
  recoveries: () => Real[];
  dlmInit1:
      (factorWeights: Real[][], integralType: LatentModelIntegrationType,
       ini?: any) => DefaultLatentModel;
  dlmInit2:
      (mktCorrel: Handle<Quote>, nVariables: Size,
       integralType: LatentModelIntegrationType,
       ini?: any) => DefaultLatentModel;
  resetBasket: (basket: Basket) => void;
  conditionalDefaultProbability1:
      (prob: Probability, iName: Size, mktFactors: Real[]) => Probability;
  conditionalDefaultProbability2:
      (date: Date, iName: Size, mktFactors: Real[]) => Probability;
  conditionalDefaultProbabilityInvP:
      (invCumYProb: Real, iName: Size, m: Real[]) => Probability;
  condProbProduct:
      (invCumYProb1: Real, invCumYProb2: Real, iName1: Size, iName2: Size,
       mktFactors: Real[]) => Probability;
  conditionalProbAtLeastNEvents:
      (n: Size, date: Date, mktFactors: Real[]) => Real;
  probOfDefault: (iName: Size, d: Date) => Probability;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _basket: RelinkableHandle<Basket>;
  basket_: Basket;
  _integration: LMIntegration;
  copulaPolicy: any;
  _factorWeights: Real[][];
  _cachedMktFactor: Handle<Quote>;
  _idiosyncFctrs: Real[];
  _nFactors: Size;
  _nVariables: Size;
  _copula: any;
  _recoveries: Real[];
}

export declare class ConstantLossModel extends
    ConstantLossLatentmodelDefaultLossModel {
  constructor(copulaPolicy: any);
  clmInit1(
      factorWeights: Real[][], recoveries: Real[],
      integralType: LatentModelIntegrationType, ini?: any): ConstantLossModel;
  clmInit2(
      mktCorrel: Handle<Quote>, recoveries: Real[],
      integralType: LatentModelIntegrationType, nVariables: Size,
      ini?: any): ConstantLossModel;
  defaultCorrelation(d: Date, iName: Size, jName: Size): Real;
  probAtLeastNEvents(n: Size, d: Date): Probability;
  expectedRecovery(d: Date, iName: Size, k: DefaultProbKey): Real;
  resetModel(): void;
}

declare class RecoveryRateModelObserver implements RecoveryRateModel,
                                                   Observable, Observer {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  recoveryValue: (defaultDate: Date, defaultKey?: DefaultProbKey) => Real;
  appliesToSeniority(sen: Seniority): boolean;
  recoveryValueImpl(d: Date, defaultKey: DefaultProbKey): Real;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
}

export declare class ConstantRecoveryModel extends RecoveryRateModelObserver {
  crmInit1(quote: Handle<RecoveryRateQuote>): ConstantRecoveryModel;
  crmInit2(recovery: Real, sen?: Seniority): ConstantRecoveryModel;
  update(): void;
  appliesToSeniority(sen: Seniority): boolean;
  recoveryValueImpl(d: Date, key: DefaultProbKey): Real;
  private _quote;
}

export declare class CorrelationTermStructure extends TermStructure {
  ctsInit1(cal: Calendar, bdc: BusinessDayConvention, dc?: DayCounter):
      CorrelationTermStructure;
  ctsInit2(
      referenceDate: Date, cal: Calendar, bdc: BusinessDayConvention,
      dc?: DayCounter): CorrelationTermStructure;
  ctsInit3(
      settlementDays: Natural, cal: Calendar, bdc: BusinessDayConvention,
      dc?: DayCounter): CorrelationTermStructure;
  businessDayConvention(): BusinessDayConvention;
  dateFromTenor(p: Period): Date;
  correlationSize(): Size;
  private _bdc;
}

export declare class DefaultEvent extends Event {
  init1(
      creditEventDate: Date, atomicEvType: DefaultType, curr: Currency,
      bondsSen: Seniority, settleDate?: Date,
      recoveryRates?: Map<Seniority, Real>): DefaultEvent;
  init2(
      creditEventDate: Date, atomicEvType: DefaultType, curr: Currency,
      bondsSen: Seniority, settleDate?: Date,
      recoveryRate?: Real): DefaultEvent;
  date(): Date;
  isRestructuring(): boolean;
  isDefault(): boolean;
  hasSettled(): boolean;
  settlement(): DefaultEvent.DefaultSettlement;
  defaultType(): DefaultType;
  currency(): Currency;
  eventSeniority(): Seniority;
  recoveryRate(seniority: Seniority): Real;
  matchesEventType(contractEvType: DefaultType): boolean;
  matchesDefaultKey(contractKey: DefaultProbKey): boolean;
  accept(v: AcyclicVisitor): void;
  protected _bondsCurrency: Currency;
  protected _defaultDate: Date;
  protected _eventType: DefaultType;
  protected _bondsSeniority: Seniority;
  protected _defSettlement: DefaultEvent.DefaultSettlement;
}
export declare namespace DefaultEvent {
  class DefaultSettlement extends Event {
    init1(date: Date, recoveryRates: Map<Seniority, Real>): DefaultSettlement;
    init2(date?: Date, seniority?: Seniority, recoveryRate?: Real):
        DefaultSettlement;
    date(): Date;
    recoveryRate(sen: Seniority): Real;
    accept(v: AcyclicVisitor): void;
    private _settlementDate;
    private _recoveryRates;
  }
}
export declare class FailureToPayEvent extends DefaultEvent {
  ftpeInit1(
      creditEventDate: Date, curr: Currency, bondsSen: Seniority,
      defaultedAmount: Real, settleDate: Date,
      recoveryRates: Map<Seniority, Real>): DefaultEvent;
  ftpeInit2(
      creditEventDate: Date, curr: Currency, bondsSen: Seniority,
      defaultedAmount: Real, settleDate: Date,
      recoveryRates: Real): DefaultEvent;
  amountDefaulted(): Real;
  matchesEventType(contractEvType: DefaultType): boolean;
  private _defaultedAmount;
}
export declare class BankruptcyEvent extends DefaultEvent {
  beInit1(
      creditEventDate: Date, curr: Currency, bondsSen: Seniority,
      settleDate: Date, recoveryRates: Map<Seniority, Real>): DefaultEvent;
  beInit2(
      creditEventDate: Date, curr: Currency, bondsSen: Seniority,
      settleDate: Date, recoveryRates: Real): DefaultEvent;
  matchesEventType(contractEvType: DefaultType): boolean;
}

export declare class DefaultLossModel extends Observable {
  expectedTrancheLoss(d: Date): Real;
  probOverLoss(d: Date, lossFraction: Real): Probability;
  percentile(d: Date, percentile: Real): Real;
  expectedShortfall(d: Date, percentile: Real): Real;
  splitVaRLevel(d: Date, loss: Real): Real[];
  splitESFLevel(d: Date, loss: Real): Real[];
  lossDistribution(d: Date): Map<Real, Probability>;
  densityTrancheLoss(d: Date, lossFraction: Real): Real;
  probsBeingNthEvent(n: Size, d: Date): Probability[];
  defaultCorrelation(d: Date, iName: Size, jName: Size): Real;
  probAtLeastNEvents(n: Size, d: Date): Probability;
  expectedRecovery(d: Date, iName: Size, key: DefaultProbKey): Real;
  setBasket(bskt: Basket): void;
  resetModel(): void;
  _basket: RelinkableHandle<Basket>;
}

export declare class DefaultProbKey {
  init1(): DefaultProbKey;
  init2(eventTypes: DefaultType[], cur: Currency, sen: Seniority):
      DefaultProbKey;
  currency(): Currency;
  seniority(): Seniority;
  eventTypes(): DefaultType[];
  size(): Size;
  protected _eventTypes: DefaultType[];
  protected _obligationCurrency: Currency;
  protected _seniority: Seniority;
}
export declare namespace DefaultProbKey {
  function equal(lhs: DefaultProbKey, rhs: DefaultProbKey): boolean;
}
export declare class NorthAmericaCorpDefaultKey extends DefaultProbKey {
  constructor(
      currency: Currency, sen: Seniority, graceFailureToPay?: Period,
      amountFailure?: Real, resType?: Restructuring.Type);
}

export declare class DefaultLatentModel extends LatentModel {
  constructor(copulaPolicy: any);
  dlmInit1(
      factorWeights: Real[][], integralType: LatentModelIntegrationType,
      ini?: any): DefaultLatentModel;
  dlmInit2(
      mktCorrel: Handle<Quote>, nVariables: Size,
      integralType: LatentModelIntegrationType, ini?: any): DefaultLatentModel;
  resetBasket(basket: Basket): void;
  conditionalDefaultProbability1(
      prob: Probability, iName: Size, mktFactors: Real[]): Probability;
  conditionalDefaultProbability2(date: Date, iName: Size, mktFactors: Real[]):
      Probability;
  update(): void;
  conditionalDefaultProbabilityInvP(invCumYProb: Real, iName: Size, m: Real[]):
      Probability;
  condProbProduct(
      invCumYProb1: Real, invCumYProb2: Real, iName1: Size, iName2: Size,
      mktFactors: Real[]): Probability;
  conditionalProbAtLeastNEvents(n: Size, date: Date, mktFactors: Real[]): Real;
  integration(): LMIntegration;
  probOfDefault(iName: Size, d: Date): Probability;
  defaultCorrelation(d: Date, iNamei: Size, iNamej: Size): Real;
  probAtLeastNEvents(n: Size, date: Date): Probability;
  basket_: Basket;
  _integration: LMIntegration;
}
export declare class GaussianDefProbLM extends DefaultLatentModel {
  constructor();
}
export declare class TDefProbLM extends DefaultLatentModel {
  constructor();
}

export declare enum Seniority {
  SecDom = 0,
  SnrFor = 1,
  SubLT2 = 2,
  JrSubT2 = 3,
  PrefT1 = 4,
  NoSeniority = 5,
  SeniorSec = 0,
  SeniorUnSec = 1,
  SubTier1 = 4,
  SubUpperTier2 = 3,
  SubLoweTier2 = 2
}
export declare namespace AtomicDefault {
  enum Type {
    Restructuring = 0,
    Bankruptcy = 1,
    FailureToPay = 2,
    RepudiationMoratorium = 3,
    Acceleration = 4,
    Default = 5,
    ObligationAcceleration = 4,
    ObligationDefault = 5,
    CrossDefault = 5,
    Downgrade = 6,
    MergerEvent = 7
  }
}
export declare namespace Restructuring {
  enum Type {
    NoRestructuring = 0,
    ModifiedRestructuring = 1,
    ModifiedModifiedRestructuring = 2,
    FullRestructuring = 3,
    AnyRestructuring = 4,
    XR = 0,
    MR = 1,
    MM = 2,
    CR = 3
  }
}
export declare class DefaultType {
  constructor(defType?: AtomicDefault.Type, restType?: Restructuring.Type);
  defaultType(): AtomicDefault.Type;
  restructuringType(): Restructuring.Type;
  isRestructuring(): boolean;
  containsDefaultType(defType: AtomicDefault.Type): boolean;
  containsRestructuringType(resType: Restructuring.Type): boolean;
  equal(lhs: DefaultType, rhs: DefaultType): boolean;
  protected _defTypes: AtomicDefault.Type;
  protected _restrType: Restructuring.Type;
}
export declare class FailureToPay extends DefaultType {
  constructor(grace: Period, amount?: Real);
  amountRequired(): Real;
  gracePeriod(): Period;
  private _gracePeriod;
  private _amountRequired;
}

export declare class Distribution {
  init(nBuckets: Size, xmin: Real, xmax: Real): Distribution;
  add(value: Real): void;
  addDensity(bucket: Integer, value: Real): void;
  addAverage(bucket: Integer, value: Real): void;
  normalize(): void;
  size(): Size;
  x1(k: Size): Real;
  x2(): Real[];
  dx1(k: Size): Real;
  dx2(): Real[];
  dx3(x: Real): Real;
  density(k: Size): Real;
  cumulative(k: Size): Real;
  excess(k: Size): Real;
  cumulativeExcess(k: Size): Real;
  average(k: Size): Real;
  confidenceLevel(quantil: Real): Real;
  cumulativeDensity(x: Real): Real;
  cumulativeExcessProbability(a: Real, b: Real): Real;
  expectedValue1(): Real;
  trancheExpectedValue(a: Real, d: Real): Real;
  expectedValue2(f: UnaryFunction<Real, Real>): Real;
  tranche(attachmentPoint: Real, detachmentPoint: Real): void;
  locate(x: Real): Size;
  expectedShortfall(percValue: Real): Real;
  private _size;
  _xmin: Real;
  _xmax: Real;
  private _count;
  private _x;
  _dx: Real[];
  _density: Real[];
  _cumulativeDensity: Real[];
  _excessProbability: Real[];
  private _cumulativeExcessProbability;
  private _average;
  private _overFlow;
  private _underFlow;
  private _isNormalized;
}
export declare class ManipulateDistribution {
  static convolve(d1: Distribution, d2: Distribution): Distribution;
}

export declare class FactorSpreadedHazardRateCurve extends HazardRateStructure {
  constructor(
      h: Handle<DefaultProbabilityTermStructure>, spread: Handle<Quote>);
  dayCounter(): DayCounter;
  calendar(): Calendar;
  referenceDate(): Date;
  maxDate(): Date;
  maxTime(): Time;
  hazardRateImpl(t: Time): Real;
  private _originalCurve;
  private _spread;
}

export declare class GaussianLHPLossModel extends DefaultLossModelLatentModel {
  glhpmInit1(
      correlQuote: Handle<Quote>,
      quotes: Array<Handle<RecoveryRateQuote>>): GaussianLHPLossModel;
  glhpmInit2(correlation: Real, recoveries: Real[]): GaussianLHPLossModel;
  glhpmInit3(correlQuote: Handle<Quote>, recoveries: Real[]):
      GaussianLHPLossModel;
  update(): void;
  expectedTrancheLoss(d: Date): Real;
  probOverLoss(d: Date, remainingLossFraction: Real): Real;
  expectedShortfall(d: Date, perctl: Probability): Real;
  percentile(d: Date, perctl: Real): Real;
  averageProb(d: Date): Probability;
  averageRecovery(d: Date): Real;
  protected percentilePortfolioLossFraction(d: Date, perctl: Real): Real;
  expectedRecovery(d: Date, iName: Size, ik: DefaultProbKey): Real;
  resetModel(): void;
  private expectedTrancheLossImpl;
  private _sqrt1minuscorrel;
  private _correl;
  private _rrQuotes;
  private _beta;
  private _biphi;
  static _phi: CumulativeNormalDistribution;
}

export declare class HomogeneousPoolLossModel extends DefaultLossModel {
  constructor(copulaPolicy: any);
  hplmInit(
      copula: ConstantLossLatentmodel, nBuckets: Size, max?: Real, min?: Real,
      nSteps?: Size): HomogeneousPoolLossModel;
  lossDistrib(d: Date): Distribution;
  expectedTrancheLoss(d: Date): Real;
  percentile(d: Date, percentile: Real): Real;
  expectedShortfall(d: Date, percentile: Probability): Real;
  resetModel(): void;
  copulaPolicy: any;
  protected _copula: ConstantLossLatentmodel;
  protected _nBuckets: Size;
  protected _attach: Real;
  protected _detach: Real;
  protected _notional: Real;
  protected _attachAmount: Real;
  protected _detachAmount: Real;
  protected _notionals: Real[];
  _max: Real;
  private _min;
  private _nSteps;
  private _delta;
}
export declare class HomogGaussPoolLossModel extends HomogeneousPoolLossModel {
  constructor();
}
export declare class HomogTPoolLossModel extends HomogeneousPoolLossModel {
  constructor();
}

export declare class InhomogeneousPoolLossModel extends DefaultLossModel {
  constructor(copulaPolicy: any);
  ihplmInit(
      copula: ConstantLossLatentmodel, nBuckets: Size, max?: Real, min?: Real,
      nSteps?: Size): InhomogeneousPoolLossModel;
  lossDistrib(d: Date): Distribution;
  expectedTrancheLoss(d: Date): Real;
  percentile(d: Date, percentile: Real): Real;
  expectedShortfall(d: Date, percentile: Probability): Real;
  resetModel(): void;
  copulaPolicy: any;
  protected _copula: ConstantLossLatentmodel;
  protected _nBuckets: Size;
  protected _attach: Real;
  protected _detach: Real;
  protected _notional: Real;
  protected _attachAmount: Real;
  protected _detachAmount: Real;
  protected _notionals: Real[];
  private _min;
  private _nSteps;
  private _delta;
}
export declare class IHGaussPoolLossModel extends InhomogeneousPoolLossModel {
  constructor();
}
export declare class IHStudentPoolLossModel extends InhomogeneousPoolLossModel {
  constructor();
}

export declare class IntegralCDOEngine extends SyntheticCDOEngine.engine {
  constructor(discountCurve: Handle<YieldTermStructure>, stepSize?: Period);
  calculate(): void;
  protected _stepSize: Period;
  protected _discountCurve: Handle<YieldTermStructure>;
}

export declare class IntegralNtdEngine extends NthToDefault.engine {
  constructor(
      integrationStep: Period, discountCurve: Handle<YieldTermStructure>);
  calculate(): void;
  protected _discountCurve: Handle<YieldTermStructure>;
  protected _integrationStepSize: Period;
}

declare type DefaultEventSet = Set<DefaultEvent>;
export declare class Issuer {
  init1(probabilities?: Issuer.key_curve_pair[], events?: DefaultEventSet):
      Issuer;
  init2(
      eventTypes: DefaultType[][], currencies: Currency[],
      seniorities: Seniority[],
      curves: Array<Handle<DefaultProbabilityTermStructure>>,
      events?: DefaultEventSet): Issuer;
  defaultProbability(key: DefaultProbKey):
      Handle<DefaultProbabilityTermStructure>;
  defaultedBetween(
      start: Date, end: Date, contractKey: DefaultProbKey,
      includeRefDate?: boolean): DefaultEvent;
  defaultsBetween(
      start: Date, end: Date, contractKey: DefaultProbKey,
      includeRefDate: boolean): DefaultEvent[];
  private _probabilities;
  private _events;
}
export declare namespace Issuer {
  type key_curve_pair =
      [DefaultProbKey, Handle<DefaultProbabilityTermStructure>];
}

export declare class Loss {
  constructor(t?: Time, a?: Real);
  lessThan(l1: Loss, l2: Loss): boolean;
  greaterThan(l1: Loss, l2: Loss): boolean;
  equal(l1: Loss, l2: Loss): boolean;
  notEqual(l1: Loss, l2: Loss): boolean;
  time: Time;
  amount: Real;
}

export declare class LossDist implements
    BinaryFunction<Real[], Real[], Distribution> {
  f(volumes: Real[], probabilities: Real[]): Distribution;
  buckets(): Size;
  maximum(): Real;
  static binomialProbabilityOfNEvents(n: Size, p: Real[]): Real;
  static binomialProbabilityOfAtLeastNEvents(n: Size, p: Real[]): Real;
  static probabilityOfNEvents1(p: Real[]): Real[];
  static probabilityOfNEvents2(k: Size, p: Real[]): Real;
  static probabilityOfAtLeastNEvents(k: Size, p: Real[]): Real;
}
export declare class ProbabilityOfNEvents implements
    UnaryFunction<Real[], Real> {
  constructor(n: Size);
  f(p: Real[]): Real;
  private _n;
}
export declare class ProbabilityOfAtLeastNEvents implements
    UnaryFunction<Real[], Real> {
  constructor(n: Size);
  f(p: Real[]): Real;
  private _n;
}
export declare class BinomialProbabilityOfAtLeastNEvents implements
    UnaryFunction<Real[], Real> {
  constructor(n: Size);
  f(p: Real[]): Real;
  private _n;
}
export declare class LossDistBinomial extends LossDist {
  constructor(nBuckets: Size, maximum: Real);
  f1(n: Size, volume: Real, probability: Real): Distribution;
  f(nominals: Real[], probabilities: Real[]): Distribution;
  buckets(): Size;
  maximum(): Real;
  volume(): Real;
  size(): Size;
  probability(): Real[];
  excessProbability(): Real[];
  private _nBuckets;
  private _maximum;
  private _volume;
  private _n;
  private _probability;
  private _excessProbability;
}
export declare class LossDistHomogeneous extends LossDist {
  constructor(nBuckets: Size, maximum: Real);
  f1(volume: Real, p: Real[]): Distribution;
  f(nominals: Real[], probabilities: Real[]): Distribution;
  buckets(): Size;
  maximum(): Real;
  volume(): Real;
  size(): Size;
  probability(): Real[];
  excessProbability(): Real[];
  private _nBuckets;
  private _maximum;
  private _volume;
  private _n;
  private _probability;
  private _excessProbability;
}
export declare class LossDistBucketing extends LossDist {
  constructor(nBuckets: Size, maximum: Real, epsilon?: Real);
  f(nominals: Real[], probabilities: Real[]): Distribution;
  buckets(): Size;
  maximum(): Real;
  private locateTargetBucket;
  private _nBuckets;
  private _maximum;
  private _epsilon;
}
export declare class LossDistMonteCarlo extends LossDist {
  constructor(
      nBuckets: Size, maximum: Real, simulations: Size, seed?: BigNatural,
      epsilon?: Real);
  f(nominals: Real[], probabilities: Real[]): Distribution;
  buckets(): Size;
  maximum(): Real;
  private _nBuckets;
  private _maximum;
  private _simulations;
  private _seed;
  private _epsilon;
}

export declare class MidPointCDOEngine extends SyntheticCDOEngine.engine {
  constructor(discountCurve: Handle<YieldTermStructure>);
  calculate(): void;
  protected _discountCurve: Handle<YieldTermStructure>;
}

export declare class NthToDefault extends Instrument {
  constructor(
      basket: Basket, n: Size, side: Protection.Side, premiumSchedule: Schedule,
      upfrontRate: Rate, premiumRate: Rate, dayCounter: DayCounter,
      nominal: Real, settlePremiumAccrual: boolean);
  premium(): Rate;
  nominal(): Real;
  dayCounter(): DayCounter;
  side(): Protection.Side;
  rank(): Size;
  basketSize(): Size;
  maturity(): Date;
  basket(): Basket;
  fairPremium(): Rate;
  premiumLegNPV(): Real;
  protectionLegNPV(): Real;
  errorEstimate(): Real;
  isExpired(): boolean;
  setupArguments(args: PricingEngine.Arguments): void;
  fetchResults(r: PricingEngine.Results): void;
  setupExpired(): void;
  private _basket;
  private _n;
  private _side;
  private _nominal;
  private _premiumSchedule;
  private _premiumRate;
  private _upfrontRate;
  private _dayCounter;
  private _settlePremiumAccrual;
  private _premiumLeg;
  private _premiumValue;
  private _protectionValue;
  private _upfrontPremiumValue;
  private _fairPremium;
}
export declare namespace NthToDefault {
  class Arguments extends PricingEngine.Arguments {
    constructor();
    validate(): void;
    basket: Basket;
    side: Protection.Side;
    premiumLeg: Leg;
    ntdOrder: Size;
    settlePremiumAccrual: boolean;
    notional: Real;
    premiumRate: Rate;
    upfrontRate: Rate;
  }
  class Results extends Instrument.Results {
    reset(): void;
    premiumValue: Real;
    protectionValue: Real;
    upfrontPremiumValue: Real;
    fairPremium: Real;
    errorEstimate: Real;
  }
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class OneFactorAffineSurvivalStructure extends
    HazardRateStructure {
  ofassInit1(
      model: OneFactorAffineModel, dayCounter?: DayCounter,
      jumps?: Array<Handle<Quote>>,
      jumpDates?: Date[]): OneFactorAffineSurvivalStructure;
  ofassInit2(
      model: OneFactorAffineModel, referenceDate: Date, cal?: Calendar,
      dayCounter?: DayCounter, jumps?: Array<Handle<Quote>>,
      jumpDates?: Date[]): OneFactorAffineSurvivalStructure;
  ofassInit3(
      model: OneFactorAffineModel, settlementDays: Natural, calendar: Calendar,
      dayCounter?: DayCounter, jumps?: Array<Handle<Quote>>,
      jumpDates?: Date[]): OneFactorAffineSurvivalStructure;
  maxDate(): Date;
  conditionalSurvivalProbability1(
      dFwd: Date, dTgt: Date, yVal: Real, extrapolate?: boolean): Probability;
  conditionalSurvivalProbability2(
      tFwd: Time, tgt: Time, yVal: Real, extrapolate?: boolean): Probability;
  hazardRate(t: Time, extrapolate?: boolean): Rate;
  survivalProbabilityImpl(t: Time): Probability;
  defaultDensityImpl(t: Time): Real;
  conditionalSurvivalProbabilityImpl(tFwd: Time, tgt: Time, yVal: Real):
      Probability;
  hazardRateImpl(t: Time): Real;
  protected _model: OneFactorAffineModel;
}

export declare class OneFactorCopula extends LazyObject {
  constructor(
      correlation: Handle<Quote>, maximum?: Real, integrationSteps?: Size,
      minimum?: Real);
  density(m: Real): Real;
  cumulativeZ(z: Real): Real;
  cumulativeY(y: Real): Real;
  inverseCumulativeY(x: Real): Real;
  correlation(): Real;
  conditionalProbability1(p: Real, m: Real): Real;
  conditionalProbability2(prob: Real[], m: Real): Real[];
  integral1(p: Real): Real;
  integral2(f: UnaryFunction<Real[], Real>, probabilities: Real[]): Real;
  integral3(f: LossDist, nominals: Real[], probabilities: Real[]): Distribution;
  checkMoments(tolerance: Real): Integer;
  protected steps(): Size;
  protected dm(i: Size): Real;
  protected m(i: Size): Real;
  protected densitydm(i: Size): Real;
  protected _correlation: Handle<Quote>;
  protected _max: Real;
  protected _steps: Size;
  protected _min: Real;
  protected _y: Real[];
  protected _cumulativeY: Real[];
}

export declare class OneFactorGaussianCopula extends OneFactorCopula {
  constructor(
      correlation: Handle<Quote>, maximum?: Real, integrationSteps?: Size);
  density(m: Real): Real;
  cumulativeZ(z: Real): Real;
  cumulativeY(y: Real): Real;
  testCumulativeY(y: Real): Real;
  inverseCumulativeY(p: Real): Real;
  performCalculations(): void;
  private _density;
  private _cumulative;
  private _inverseCumulative;
}

export declare class OneFactorStudentCopula extends OneFactorCopula {
  constructor(
      correlation: Handle<Quote>, nz: Integer, nm: Integer, maximum?: Real,
      integrationSteps?: Size);
  density(m: Real): Real;
  cumulativeZ(z: Real): Real;
  performCalculations(): void;
  private cumulativeYintegral;
  private _density;
  private _cumulative;
  private _nz;
  private _nm;
  private _scaleM;
  private _scaleZ;
}
export declare class OneFactorGaussianStudentCopula extends OneFactorCopula {
  constructor(
      correlation: Handle<Quote>, nz: Integer, nm: Integer, maximum?: Real,
      integrationSteps?: Size);
  density(m: Real): Real;
  cumulativeZ(z: Real): Real;
  performCalculations(): void;
  private cumulativeYintegral;
  private _density;
  private _cumulative;
  private _nz;
  private _scaleZ;
}
export declare class OneFactorStudentGaussianCopula extends OneFactorCopula {
  constructor(
      correlation: Handle<Quote>, nz: Integer, nm: Integer, maximum?: Real,
      integrationSteps?: Size);
  density(m: Real): Real;
  cumulativeZ(z: Real): Real;
  performCalculations(): void;
  private cumulativeYintegral;
  private _density;
  private _cumulative;
  private _nm;
  private _scaleM;
}

export declare class Pool {
  constructor();
  size(): Size;
  clear(): void;
  has(name: string): boolean;
  add(name: string, issuer: Issuer, contractTrigger?: DefaultProbKey): void;
  get(name: string): Issuer;
  defaultKey(name: string): DefaultProbKey;
  setTime(name: string, time: Time): void;
  getTime(name: string): Time;
  names(): string[];
  defaultKeys(): DefaultProbKey[];
  private _data;
  private _time;
  private _names;
  private _defaultKeys;
}

export declare class RandomLM extends DefaultLossModelLazyObject {
  constructor(derivedRandomLM: any, copulaPolicy: any, USNG?: USG<Real[]>);
  init(
      numFactors: Size, numLMVars: Size, copula: any, nSims: Size,
      seed: BigNatural): void;
  update(): void;
  performCalculations(): void;
  performSimulations(): void;
  getSim(iSim: Size): simEvent[];
  getEventRecovery(evt: simEvent): Real;
  probAtLeastNEvents(n: Size, d: Date): Probability;
  probsBeingNthEvent(n: Size, d: Date): Probability[];
  defaultCorrelation(d: Date, iName: Size, jName: Size): Real;
  expectedTrancheLoss(d: Date): Real;
  expectedTrancheLossInterval(d: Date, confidencePerc: Probability):
      [Real, Real];
  lossDistribution(d: Date): Map<Real, Probability>;
  computeHistogram(d: Date): Histogram;
  expectedShortfall(d: Date, percent: Real): Real;
  percentile(d: Date, percentile: Real): Real;
  percentileAndInterval(d: Date, percentile: Real): [Real, Real, Real];
  splitVaRLevel(date: Date, loss: Real): Real[];
  splitVaRAndError(date: Date, loss: Real, confInterval: Probability): Real[][];
  copulaPolicy: any;
  derivedRandomLM: any;
  USNG: USG<Real[]>;
  protected _numFactors: Size;
  protected _numLMVars: Size;
  protected _nSims: Size;
  protected _simsBuffer: simEvent[][];
  protected _copula: any;
  protected _copulasRng: any;
  _seed: BigNatural;
  protected _maxHorizon: Size;
}
export declare namespace RandomLM {
  class Root {
    constructor(dts: Handle<DefaultProbabilityTermStructure>, pd: Real);
    f(t: Time): Real;
    private _dts;
    private _pd;
    private _curveRef;
  }
}

export declare class RandomDefaultLM extends RandomLM {
  constructor(copulaPolicy: any, USNG?: USG<Real[]>);
  rdlmInit1(
      model: DefaultLatentModel, recoveries?: Real[], nSims?: Size,
      accuracy?: Real, seed?: BigNatural): RandomDefaultLM;
  rdlmInit2(model: any, nSims?: Size, accuracy?: Real, seed?: BigNatural):
      RandomDefaultLM;
  nextSample(values: Real[]): void;
  initDates(): void;
  getEventRecovery(evt: defaultSimEvent): Real;
  expectedRecovery(d: Date, iName: Size, key: DefaultProbKey): Real;
  latentVarValue(factorsSample: Real[], iVar: Size): Real;
  basketSize(): Size;
  resetModel(): void;
  private _model;
  private _recoveries;
  private _accuracy;
  private _horizonDefaultPs;
}
export declare class GaussianRandomDefaultLM extends RandomDefaultLM {
  constructor();
}
export declare class TRandomDefaultLM extends RandomDefaultLM {
  constructor();
}

export declare class RandomDefaultModel extends ObserverObservable {
  constructor(pool: Pool, defaultKeys: DefaultProbKey[]);
  update(): void;
  nextSequence(tmax?: Real): void;
  reset(): void;
  protected _pool: Pool;
  protected _defaultKeys: DefaultProbKey[];
}
export declare class GaussianRandomDefaultModel extends RandomDefaultModel {
  constructor(
      pool: Pool, defaultKeys: DefaultProbKey[],
      copula: Handle<OneFactorCopula>, accuracy: Real, seed: Size);
  nextSequence(tmax?: Real): void;
  reset(): void;
  private _copula;
  private _accuracy;
  private _seed;
  private _rsg;
}

export declare class RandomLossLM extends RandomLM {
  constructor(copulaPolicy: any, USNG?: USG<Real[]>);
  rllmInit(
      copula: SpotRecoveryLatentModel, nSims?: Size, accuracy?: Real,
      seed?: BigNatural): RandomLossLM;
  nextSample(values: Real[]): void;
  initDates(): void;
  getEventRecovery(evt: defaultSimEvent): Real;
  latentVarValue(factorsSample: Real[], iVar: Size): Real;
  basketSize(): Size;
  conditionalRecovery(latentVarSample: Real, iName: Size, d: Date): Real;
  resetModel(): void;
  private _accuracy;
  private _horizonDefaultPs;
}
declare class simEvent {
  constructor(n: Size, d: Size, r: Real);
  lessThan(evt: simEvent): boolean;
  recovery(): Real;
  nameIdx: Size;
  dayFromRef: Size;
  compactRR: Size;
  rrGranular: Real;
}
declare class defaultSimEvent extends simEvent {}
export declare class GaussianRandomLossLM extends RandomLossLM {
  constructor();
}
export declare class TRandomLossLM extends RandomLossLM {
  constructor();
}

export declare class RecoveryRateModel extends Observable {
  recoveryValue(defaultDate: Date, defaultKey?: DefaultProbKey): Real;
  appliesToSeniority(sen: Seniority): boolean;
  recoveryValueImpl(d: Date, defaultKey: DefaultProbKey): Real;
}

export declare class RecoveryRateQuote extends Quote {
  constructor(value?: Real, seniority?: Seniority);
  value(): Real;
  seniority(): Seniority;
  isValid(): boolean;
  setValue(value?: Real): Real;
  reset(): void;
  static makeIsdaMap(arrayIsdaRR: Real[]): Map<Seniority, Real>;
  static IsdaConvRecoveries: Real[];
  private _seniority;
  private _recoveryRate;
}
export declare function makeIsdaConvMap(): Map<Seniority, Real>;

export declare class RecursiveLossModel extends DefaultLossModel {
  constructor(copulaPolicy: any);
  rlmInit(m: ConstantLossLatentmodel, nbuckets?: Size): RecursiveLossModel;
  conditionalLossDistrib(pDefDate: Probability[], mktFactor: Real[]):
      Map<Real, Probability>;
  expectedConditionalLoss(pDefDate: Probability[], mktFactor: Real[]): Real;
  conditionalLossProb(pDefDate: Probability[], mktFactor: Real[]): Real[];
  conditionalLossDistribInvP(invpDefDate: Probability[], mktFactor: Real[]):
      Map<Real, Probability>;
  expectedConditionalLossInvP(invPDefDate: Probability[], mktFactor: Real[]):
      Real;
  resetModel(): void;
  expectedTrancheLoss(date: Date): Real;
  lossProbability(date: Date): Real[];
  lossDistribution(d: Date): Map<Real, Probability>;
  percentile(d: Date, percentile: Real): Real;
  expectedShortfall(d: Date, perctl: Real): Real;
  copulaPolicy: any;
  protected _copula: ConstantLossLatentmodel;
  private _nBuckets;
  private _wk;
  private _lossUnit;
  private _attachAmount;
  private _detachAmount;
  private _remainingBsktSize;
  private _notionals;
}
export declare class RecursiveGaussLossModel extends RecursiveLossModel {
  constructor();
}

export declare class RiskyAssetSwap extends Instrument {
  constructor(
      fixedPayer: boolean, nominal: Real, fixedSchedule: Schedule,
      floatSchedule: Schedule, fixedDayCounter: DayCounter,
      floatDayCounter: DayCounter, spread: Rate, recoveryRate: Rate,
      yieldTS: Handle<YieldTermStructure>,
      defaultTS: Handle<DefaultProbabilityTermStructure>, coupon?: Real);
  fairSpread(): Real;
  floatAnnuity(): Real;
  nominal(): Real;
  spread(): Spread;
  fixedPayer(): boolean;
  setupExpired(): void;
  isExpired(): boolean;
  performCalculations(): void;
  fixedAnnuity(): Real;
  parCoupon(): Real;
  recoveryValue(): Real;
  riskyBondPrice(): Real;
  private _fixedAnnuity;
  private _floatAnnuity;
  private _parCoupon;
  private _recoveryValue;
  private _riskyBondPrice;
  private _fixedPayer;
  private _nominal;
  private _fixedSchedule;
  private _floatSchedule;
  private _fixedDayCounter;
  private _floatDayCounter;
  private _spread;
  private _recoveryRate;
  private _yieldTS;
  private _defaultTS;
  private _coupon;
}
export declare class AssetSwapHelper extends BootstrapHelper {
  constructor(
      spread: Handle<Quote>, tenor: Period, settlementDays: Natural,
      calendar: Calendar, fixedPeriod: Period,
      fixedConvention: BusinessDayConvention, fixedDayCount: DayCounter,
      floatPeriod: Period, floatConvention: BusinessDayConvention,
      floatDayCount: DayCounter, recoveryRate: Real,
      yieldTS: RelinkableHandle<YieldTermStructure>,
      integrationStepSize?: Period);
  impliedQuote(): Real;
  setTermStructure(ts: DefaultProbabilityTermStructure): void;
  update(): void;
  initializeDates(): void;
  private _tenor;
  private _settlementDays;
  private _calendar;
  private _fixedConvention;
  private _fixedPeriod;
  private _fixedDayCount;
  private _floatConvention;
  private _floatPeriod;
  private _floatDayCount;
  private _recoveryRate;
  private _yieldTS;
  private _evaluationDate;
  private _asw;
  private _probability;
}

export declare class RiskyAssetSwapOption extends Instrument {
  constructor(
      asw: RiskyAssetSwap, expiry: Date, marketSpread: Rate,
      spreadVolatility: Volatility);
  isExpired(): boolean;
  performCalculations(): void;
  private _asw;
  private _expiry;
  private _marketSpread;
  private _spreadVolatility;
}

export declare class RiskyBond extends Instrument {
  constructor(
      name: string, ccy: Currency, recoveryRate: Real,
      defaultTS: Handle<DefaultProbabilityTermStructure>,
      yieldTS: Handle<YieldTermStructure>, settlementDays?: Natural,
      calendar?: Calendar);
  cashflows(): CashFlow[];
  expectedCashflows(): CashFlow[];
  notional(date?: Date): Real;
  effectiveDate(): Date;
  maturityDate(): Date;
  interestFlows(): CashFlow[];
  notionalFlows(): CashFlow[];
  riskfreeNPV(): Real;
  totalFutureFlows(): Real;
  name(): string;
  ccy(): Currency;
  yieldTS(): Handle<YieldTermStructure>;
  defaultTS(): Handle<DefaultProbabilityTermStructure>;
  recoveryRate(): Real;
  isExpired(): boolean;
  setupExpired(): void;
  performCalculations(): void;
  protected _settlementDays: Natural;
  protected _calendar: Calendar;
  private _name;
  private _ccy;
  private _recoveryRate;
  private _defaultTS;
  private _yieldTS;
}
export declare class RiskyFixedBond extends RiskyBond {
  constructor(
      name: string, ccy: Currency, recoveryRate: Real,
      defaultTS: Handle<DefaultProbabilityTermStructure>, schedule: Schedule,
      rate: Real, dayCounter: DayCounter,
      paymentConvention: BusinessDayConvention, notionals: Real[],
      yieldTS: Handle<YieldTermStructure>, settlementDays?: Natural);
  cashflows(): CashFlow[];
  notional(date?: Date): Real;
  effectiveDate(): Date;
  maturityDate(): Date;
  interestFlows(): CashFlow[];
  notionalFlows(): CashFlow[];
  private _schedule;
  private _rate;
  private _dayCounter;
  private _notionals;
  private _leg;
  private _interestLeg;
  private _redemptionLeg;
}
export declare class RiskyFloatingBond extends RiskyBond {
  constructor(
      name: string, ccy: Currency, recoveryRate: Real,
      defaultTS: Handle<DefaultProbabilityTermStructure>, schedule: Schedule,
      index: IborIndex, fixingDays: Integer, spread: Real, notionals: Real[],
      yieldTS: Handle<YieldTermStructure>, settlementDays?: Natural);
  cashflows(): CashFlow[];
  notional(date?: Date): Real;
  effectiveDate(): Date;
  maturityDate(): Date;
  interestFlows(): CashFlow[];
  notionalFlows(): CashFlow[];
  private _schedule;
  private _index;
  private _fixingDays;
  private _spread;
  private _notionals;
  private _leg;
  private _interestLeg;
  private _redemptionLeg;
}

export declare class SaddlePointLossModel extends DefaultLossModel {}

export declare class SpotRecoveryLatentModel extends LatentModel {
  constructor(copulaPolicy: any);
  srlmInit(
      factorWeights: Real[][], recoveries: Real[], modelA: Real,
      integralType: LatentModelIntegrationType,
      ini?: any): SpotRecoveryLatentModel;
  resetBasket(basket: Basket): void;
  conditionalDefaultProbability1(date: Date, iName: Size, mktFactors: Real[]):
      Probability;
  conditionalDefaultProbability2(
      prob: Probability, iName: Size, mktFactors: Real[]): Probability;
  conditionalDefaultProbabilityInvP(invCumYProb: Real, iName: Size, m: Real[]):
      Probability;
  expCondRecovery(d: Date, iName: Size, mktFactors: Real[]): Real;
  expCondRecoveryP(uncondDefP: Real, iName: Size, mktFactors: Real[]): Real;
  expCondRecoveryInvPinvRR(
      invUncondDefP: Real, invUncondRR: Real, iName: Size,
      mktFactors: Real[]): Real;
  conditionalRecovery(latentVarSample: Real, iName: Size, d: Date): Real;
  latentRRVarValue(allFactors: Real[], iName: Size): Real;
  conditionalExpLossRR(d: Date, iName: Size, mktFactors: Real[]): Real;
  conditionalExpLossRRInv(
      invP: Real, invRR: Real, iName: Size, mktFactors: Real[]): Real;
  expectedLoss(d: Date, iName: Size): Real;
  integration(): LMIntegration;
  private _recoveries;
  private _modelA;
  private _crossIdiosyncFctrs;
  private _numNames;
  private _basket;
  private _integration;
}
export declare class GaussianSpotLossLM extends SpotRecoveryLatentModel {
  constructor();
}
export declare class TSpotLossLM extends SpotRecoveryLatentModel {
  constructor();
}

export declare class SpreadedHazardRateCurve extends HazardRateStructure {
  constructor(
      h: Handle<DefaultProbabilityTermStructure>, spread: Handle<Quote>);
  dayCounter(): DayCounter;
  calendar(): Calendar;
  referenceDate(): Date;
  maxDate(): Date;
  maxTime(): Time;
  hazardRateImpl(t: Time): Real;
  private _originalCurve;
  private _spread;
}

export declare class SyntheticCDO extends Instrument {
  constructor(
      basket: Basket, side: Protection.Side, schedule: Schedule,
      upfrontRate: Rate, runningRate: Rate, dayCounter: DayCounter,
      paymentConvention: BusinessDayConvention, notional?: Real);
  basket(): Basket;
  isExpired(): boolean;
  fairPremium(): Rate;
  fairUpfrontPremium(): Rate;
  premiumValue(): Rate;
  protectionValue(): Rate;
  premiumLegNPV(): Real;
  protectionLegNPV(): Real;
  remainingNotional(): Real;
  leverageFactor(): Real;
  maturity(): Date;
  implicitCorrelation(
      recoveries: Real[], discountCurve: Handle<YieldTermStructure>,
      targetNPV?: Real, accuracy?: Real): Real;
  expectedTrancheLoss(): Real[];
  error(): Real;
  setupArguments(args: PricingEngine.Arguments): void;
  fetchResults(r: PricingEngine.Results): void;
  setupExpired(): void;
  private _basket;
  private _side;
  private _normalizedLeg;
  private _upfrontRate;
  private _runningRate;
  private _leverageFactor;
  private _dayCounter;
  private _paymentConvention;
  private _premiumValue;
  private _protectionValue;
  private _upfrontPremiumValue;
  private _remainingNotional;
  private _error;
  private _expectedTrancheLoss;
}

export declare namespace SyntheticCDOEngine {
  class Arguments extends PricingEngine.Arguments {
    constructor();
    validate(): void;
    basket: Basket;
    side: Protection.Side;
    normalizedLeg: Leg;
    upfrontRate: Rate;
    runningRate: Rate;
    leverageFactor: Real;
    dayCounter: DayCounter;
    paymentConvention: BusinessDayConvention;
  }
  class Results extends Instrument.Results {
    reset(): void;
    premiumValue: Real;
    protectionValue: Real;
    upfrontPremiumValue: Real;
    remainingNotional: Real;
    xMin: Real;
    xMax: Real;
    error: Real;
    expectedTrancheLoss: Real[];
  }
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class AnalyticAmericanMargrabeEngine extends
    MargrabeOption.engine {
  constructor(
      process1: GeneralizedBlackScholesProcess,
      process2: GeneralizedBlackScholesProcess, correlation: Real);
  calculate(): void;
  private _process1;
  private _process2;
  private _rho;
}

export declare class AnalyticComplexChooserEngine extends
    ComplexChooserOption.engine {
  constructor(process: GeneralizedBlackScholesProcess);
  calculate(): void;
  private strike;
  private choosingTime;
  private putMaturity;
  private callMaturity;
  private volatility;
  private dividendYield;
  private dividendDiscount;
  private riskFreeRate;
  private riskFreeDiscount;
  private bsCalculator;
  private CriticalValueChooser;
  private ComplexChooser;
  private _process;
}

export declare class AnalyticCompoundOptionEngine extends
    CompoundOption.engine {
  constructor(process: GeneralizedBlackScholesProcess);
  calculate(): void;
  private residualTimeMother;
  private residualTimeDaughter;
  private residualTimeMotherDaughter;
  private maturityMother;
  private maturityDaughter;
  private dPlus;
  private dMinus;
  private dPlusTau12;
  private strikeDaughter;
  private strikeMother;
  private spot;
  private volatilityDaughter;
  private volatilityMother;
  private riskFreeRateDaughter;
  private dividendRateDaughter;
  private stdDeviationDaughter;
  private stdDeviationMother;
  private typeDaughter;
  private typeMother;
  private transformX;
  private e;
  private riskFreeDiscountDaughter;
  private riskFreeDiscountMother;
  private riskFreeDiscountMotherDaughter;
  private dividendDiscountDaughter;
  private dividendDiscountMother;
  private dividendDiscountMotherDaughter;
  private payoffMother;
  private payoffDaughter;
  private _N;
  private _n;
  private _process;
}

export declare class AnalyticEuropeanMargrabeEngine extends
    MargrabeOption.engine {
  constructor(
      process1: GeneralizedBlackScholesProcess,
      process2: GeneralizedBlackScholesProcess, correlation: Real);
  calculate(): void;
  private _process1;
  private _process2;
  private _rho;
}

export declare class AnalyticHolderExtensibleOptionEngine extends
    HolderExtensibleOption.engine {
  constructor(process: GeneralizedBlackScholesProcess);
}

export declare class AnalyticPartialTimeBarrierOptionEngine extends
    PartialTimeBarrierOption.engine {
  constructor(process: GeneralizedBlackScholesProcess);
  calculate(): void;
  underlying(): Real;
  strike(): Real;
  residualTime(): Time;
  coverEventTime(): Time;
  volatility(t: Time): Volatility;
  barrier(): Real;
  rebate(): Real;
  stdDeviation(): Real;
  riskFreeRate(): Rate;
  riskFreeDiscount(): DiscountFactor;
  dividendYield(): Rate;
  dividendDiscount(): DiscountFactor;
  M(a: Real, b: Real, rho: Real): Real;
  d1(): Real;
  d2(): Real;
  e1(): Real;
  e2(): Real;
  e3(): Real;
  e4(): Real;
  f1(): Real;
  f2(): Real;
  rho(): Real;
  mu(): Rate;
  CoB2(barrierType: Barrier.Type): Real;
  CoB1(): Real;
  CA(eta: Integer): Real;
  CIA(eta: Integer): Real;
  g1(): Real;
  g2(): Real;
  g3(): Real;
  g4(): Real;
  HS(S: Real, H: Real, power: Real): Real;
  private _process;
}

export declare class AnalyticPDFHestonEngine extends GenericModelEngine<
    HestonModel, VanillaOptionEngine.Arguments, VanillaOptionEngine.Results> {
  constructor(
      model: HestonModel, integrationEps?: Real,
      maxIntegrationIterations?: Size);
  calculate(): void;
  Pv(x_t: Real, t: Time): Real;
  cdf(s: Real, t: Time): Real;
  private weightedPayoff;
  private _maxIntegrationIterations;
  private _integrationEps;
  private _model1;
}

export declare class AnalyticSimpleChooserEngine extends
    SimpleChooserOption.engine {
  constructor(process: GeneralizedBlackScholesProcess);
  calculate(): void;
  private _process;
}

export declare class AnalyticTwoAssetBarrierEngine extends
    TwoAssetBarrierOption.engine {
  constructor(
      process1: GeneralizedBlackScholesProcess,
      process2: GeneralizedBlackScholesProcess, rho: Handle<Quote>);
  calculate(): void;
  underlying1(): Real;
  underlying2(): Real;
  strike(): Real;
  residualTime(): Time;
  volatility1(): Volatility;
  volatility2(): Volatility;
  barrier(): Real;
  rho(): Real;
  riskFreeRate(): Rate;
  dividendYield1(): Rate;
  dividendYield2(): Rate;
  costOfCarry1(): Rate;
  costOfCarry2(): Rate;
  mu(b: Real, vol: Real): Real;
  d1(): Real;
  d2(): Real;
  d3(): Real;
  d4(): Real;
  e1(): Real;
  e2(): Real;
  e3(): Real;
  e4(): Real;
  call(): Real;
  put(): Real;
  A(eta: Real, phi: Real): Real;
  B(eta: Real, phi: Real): Real;
  M(m_a: Real, m_b: Real, rho: Real): Real;
  private _process1;
  private _process2;
  private _rho;
}

export declare class AnalyticTwoAssetCorrelationEngine extends
    TwoAssetCorrelationOption.engine {
  constructor(
      p1: GeneralizedBlackScholesProcess, p2: GeneralizedBlackScholesProcess,
      correlation: Handle<Quote>);
  calculate(): void;
  private _p1;
  private _p2;
  private _correlation;
}

export declare class AnalyticWriterExtensibleOptionEngine extends
    WriterExtensibleOption.engine {
  constructor(process: GeneralizedBlackScholesProcess);
}

export declare class ComplexChooserOption extends OneAssetOption {
  constructor(
      choosingDate: Date, strikeCall: Real, strikePut: Real,
      exerciseCall: Exercise, exercisePut: Exercise);
  setupArguments(args: PricingEngine.Arguments): void;
  protected _choosingDate: Date;
  protected _strikeCall: Real;
  protected _strikePut: Real;
  protected _exerciseCall: Exercise;
  protected _exercisePut: Exercise;
}
export declare namespace ComplexChooserOption {
  class Arguments extends OneAssetOption.Arguments {
    constructor();
    validate(): void;
    choosingDate: Date;
    strikeCall: Real;
    strikePut: Real;
    exerciseCall: Exercise;
    exercisePut: Exercise;
  }
  class Results extends OneAssetOption.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class CompoundOption extends OneAssetOption {
  constructor(
      motherPayoff: StrikedTypePayoff, motherExercise: Exercise,
      daughterPayoff: StrikedTypePayoff, daughterExercise: Exercise);
  setupArguments(args: PricingEngine.Arguments): void;
  private _daughterPayoff;
  private _daughterExercise;
}
export declare namespace CompoundOption {
  class Arguments extends OneAssetOption.Arguments {
    validate(): void;
    daughterPayoff: StrikedTypePayoff;
    daughterExercise: Exercise;
  }
  class Results extends OneAssetOption.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class ContinuousArithmeticAsianLevyEngine extends
    ContinuousAveragingAsianOption.engine {
  constructor(
      process: GeneralizedBlackScholesProcess, currentAverage: Handle<Quote>,
      startDate: Date);
  calculate(): void;
  private _process;
  private _currentAverage;
  private _startDate;
}

export declare class ContinuousArithmeticAsianVecerEngine extends
    ContinuousAveragingAsianOption.engine {
  constructor(
      process: GeneralizedBlackScholesProcess, currentAverage: Handle<Quote>,
      startDate: Date, timeSteps?: Size, assetSteps?: Size, z_min?: Real,
      z_max?: Real);
  calculate(): void;
  protected cont_strategy(t: Time, T1: Time, T2: Time, v: Real, r: Real): Real;
  private _process;
  private _currentAverage;
  private _startDate;
  private _z_min;
  private _z_max;
  private _timeSteps;
  private _assetSteps;
}

export declare class EverestOption extends MultiAssetOption {
  constructor(notional: Real, guarantee: Rate, exercise: Exercise);
  yield(): Rate;
  setupArguments(args: PricingEngine.Arguments): void;
  fetchResults(r: PricingEngine.Results): void;
  private _notional;
  private _guarantee;
  private _yield;
}
export declare namespace EverestOption {
  class Arguments extends MultiAssetOption.Arguments {
    constructor();
    validate(): void;
    notional: Real;
    guarantee: Rate;
  }
  class Results extends MultiAssetOption.Results {
    reset(): void;
    yield: Rate;
  }
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class HimalayaOption extends MultiAssetOption {
  constructor(fixingDates: Date[], strike: Real);
  setupArguments(args: PricingEngine.Arguments): void;
  private _fixingDates;
}
export declare namespace HimalayaOption {
  class Arguments extends MultiAssetOption.Arguments {
    validate(): void;
    fixingDates: Date[];
  }
  class Results extends MultiAssetOption.Results {
    reset(): void;
  }
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class HolderExtensibleOption extends OneAssetOption {
  constructor(
      type: Option.Type, premium: Real, secondExpiryDate: Date,
      secondStrike: Real, payoff: StrikedTypePayoff, exercise: Exercise);
  setupArguments(args: PricingEngine.Arguments): void;
  protected _premium: Real;
  protected _secondExpiryDate: Date;
  protected _secondStrike: Real;
}
export declare namespace HolderExtensibleOption {
  class Arguments extends OneAssetOption.Arguments {
    constructor();
    validate(): void;
    premium: Real;
    secondExpiryDate: Date;
    secondStrike: Real;
  }
  class Results extends OneAssetOption.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class KirkSpreadOptionEngine extends SpreadOption.engine {
  constructor(
      process1: BlackProcess, process2: BlackProcess,
      correlation: Handle<Quote>);
  calculate(): void;
  private _process1;
  private _process2;
  private _rho;
}

export declare class MargrabeOption extends MultiAssetOption {
  constructor(Q1: Integer, Q2: Integer, exercise: Exercise);
  delta1(): Real;
  delta2(): Real;
  gamma1(): Real;
  gamma2(): Real;
  setupArguments(args: PricingEngine.Arguments): void;
  fetchResults(r: PricingEngine.Results): void;
  protected _Q1: Integer;
  protected _Q2: Integer;
  protected _delta1: Real;
  protected _delta2: Real;
  protected _gamma1: Real;
  protected _gamma2: Real;
}
export declare namespace MargrabeOption {
  class Arguments extends MultiAssetOption.Arguments {
    constructor();
    validate(): void;
    Q1: Integer;
    Q2: Integer;
  }
  class Results extends MultiAssetOption.Results {
    constructor();
    reset(): void;
    delta1: Real;
    delta2: Real;
    gamma1: Real;
    gamma2: Real;
  }
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class MCEverestEngine extends EverestOptionEngineMcSimulation {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  mceeInit(
      processes: StochasticProcessArray, timeSteps: Size,
      timeStepsPerYear: Size, brownianBridge: boolean,
      antitheticVariate: boolean, requiredSamples: Size,
      requiredTolerance: Real, maxSamples: Size,
      seed: BigNatural): MCEverestEngine;
  timeGrid(): TimeGrid;
  pathGenerator(): MultiPathGenerator;
  pathPricer(): PathPricer<MultiPath>;
  calculate(): void;
  private endDiscount;
  private _processes;
  private _timeSteps;
  private _timeStepsPerYear;
  private _requiredSamples;
  private _maxSamples;
  private _requiredTolerance;
  private _brownianBridge;
  private _seed;
}
export declare class MakeMCEverestEngine implements
    NullaryFunction<PricingEngine> {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  mmceeInit(processes: StochasticProcessArray): MakeMCEverestEngine;
  withSteps(steps: Size): MakeMCEverestEngine;
  withStepsPerYear(steps: Size): MakeMCEverestEngine;
  withBrownianBridge(b?: boolean): MakeMCEverestEngine;
  withAntitheticVariate(b?: boolean): MakeMCEverestEngine;
  withSamples(samples: Size): MakeMCEverestEngine;
  withAbsoluteTolerance(tolerance: Real): MakeMCEverestEngine;
  withMaxSamples(samples: Size): MakeMCEverestEngine;
  withSeed(seed: BigNatural): MakeMCEverestEngine;
  f(): PricingEngine;
  RNG: MonteCarloModel.rng_traits;
  S: any;
  private _processes;
  private _brownianBridge;
  private _antithetic;
  private _steps;
  private _stepsPerYear;
  private _samples;
  private _maxSamples;
  private _tolerance;
  private _seed;
}
export declare class EverestMultiPathPricer extends PathPricer<MultiPath> {
  constructor(notional: Real, guarantee: Rate, discount: DiscountFactor);
  f(multiPath: MultiPath): Real;
  private _notional;
  private _guarantee;
  private _discount;
}

export declare class MCHimalayaEngine extends HimalayaOptionEngineMcSimulation {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  mcheInit(
      processes: StochasticProcessArray, brownianBridge: boolean,
      antitheticVariate: boolean, requiredSamples: Size,
      requiredTolerance: Real, maxSamples: Size,
      seed: BigNatural): MCHimalayaEngine;
  timeGrid(): TimeGrid;
  pathGenerator(): MultiPathGenerator;
  pathPricer(): PathPricer<MultiPath>;
  calculate(): void;
  private _processes;
  private _requiredSamples;
  private _maxSamples;
  private _requiredTolerance;
  private _brownianBridge;
  private _seed;
}
export declare class MakeMCHimalayaEngine implements
    NullaryFunction<PricingEngine> {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  mmcheInit(processes: StochasticProcessArray): MakeMCHimalayaEngine;
  withBrownianBridge(b?: boolean): MakeMCHimalayaEngine;
  withAntitheticVariate(b?: boolean): MakeMCHimalayaEngine;
  withSamples(samples: Size): MakeMCHimalayaEngine;
  withAbsoluteTolerance(tolerance: Real): MakeMCHimalayaEngine;
  withMaxSamples(samples: Size): MakeMCHimalayaEngine;
  withSeed(seed: BigNatural): MakeMCHimalayaEngine;
  f(): PricingEngine;
  RNG: MonteCarloModel.rng_traits;
  S: any;
  private _processes;
  private _brownianBridge;
  private _antithetic;
  private _samples;
  private _maxSamples;
  private _tolerance;
  private _seed;
}
export declare class HimalayaMultiPathPricer extends PathPricer<MultiPath> {
  constructor(payoff: Payoff, discount: DiscountFactor);
  f(multiPath: MultiPath): Real;
  private _payoff;
  private _discount;
}

declare class PagodaOptionEngineMcSimulation implements
    Observable, Observer, PricingEngine,
    GenericEngine<PagodaOption.Arguments, PagodaOption.Results>,
    PagodaOption.engine, McSimulation {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update: () => void;
  deepUpdate: () => void;
  getArguments: () => PagodaOption.Arguments;
  getResults: () => PagodaOption.Results;
  reset: () => void;
  calculate(): void;
  mcsInit:
      (antitheticVariate: boolean, controlVariate: boolean) => McSimulation;
  value: (tolerance: Real, maxSamples: Size, minSamples: Size) => Real;
  valueWithSamples: (samples: Size) => Real;
  errorEstimate: () => Real;
  sampleAccumulator: () => RiskStatistics;
  calculate1:
      (requiredTolerance: Real, requiredSamples: Size,
       maxSamples: Size) => void;
  pathPricer(): PathPricer<Path|MultiPath>;
  pathGenerator(): MultiPathGenerator;
  timeGrid(): TimeGrid;
  controlPathPricer: () => PathPricer<Path|MultiPath>;
  controlPathGenerator: () => PathGenerator;
  controlPricingEngine: () => PricingEngine;
  controlVariateValue: () => Real;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _mcModel: MonteCarloModel;
  _antitheticVariate: boolean;
  _controlVariate: boolean;
  MC: MonteCarloModel.mc_traits;
  RNG: MonteCarloModel.rng_traits;
  S: any;
  _arguments: PagodaOption.Arguments;
  _results: PagodaOption.Results;
}

export declare class MCPagodaEngine extends PagodaOptionEngineMcSimulation {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  mcpeInit(
      processes: StochasticProcessArray, brownianBridge: boolean,
      antitheticVariate: boolean, requiredSamples: Size,
      requiredTolerance: Real, maxSamples: Size,
      seed: BigNatural): MCPagodaEngine;
  calculate(): void;
  timeGrid(): TimeGrid;
  pathGenerator(): MultiPathGenerator;
  pathPricer(): PathPricer<MultiPath>;
  private _processes;
  private _requiredSamples;
  private _maxSamples;
  private _requiredTolerance;
  private _brownianBridge;
  private _seed;
}
export declare class MakeMCPagodaEngine implements
    NullaryFunction<PricingEngine> {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  mmcpeInit(processes: StochasticProcessArray): MakeMCPagodaEngine;
  withBrownianBridge(b?: boolean): MakeMCPagodaEngine;
  withAntitheticVariate(b?: boolean): MakeMCPagodaEngine;
  withSamples(samples: Size): MakeMCPagodaEngine;
  withAbsoluteTolerance(tolerance: Real): MakeMCPagodaEngine;
  withMaxSamples(samples: Size): MakeMCPagodaEngine;
  withSeed(seed: BigNatural): MakeMCPagodaEngine;
  f(): PricingEngine;
  RNG: MonteCarloModel.rng_traits;
  S: any;
  private _processes;
  private _brownianBridge;
  private _antithetic;
  private _samples;
  private _maxSamples;
  private _tolerance;
  private _seed;
}
export declare class PagodaMultiPathPricer {
  constructor(roof: Real, fraction: Real, discount: DiscountFactor);
  f(multiPath: MultiPath): Real;
  private _discount;
  private _roof;
  private _fraction;
}

export declare class PagodaOption extends MultiAssetOption {
  constructor(fixingDates: Date[], roof: Real, fraction: Real);
  setupArguments(args: PricingEngine.Arguments): void;
  protected _fixingDates: Date[];
  protected _roof: Real;
  protected _fraction: Real;
}
export declare namespace PagodaOption {
  class Arguments extends MultiAssetOption.Arguments {
    constructor();
    validate(): void;
    fixingDates: Date[];
    roof: Real;
    fraction: Real;
  }
  class Results extends MultiAssetOption.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare namespace PartialBarrier {
  enum Range { Start = 0, End = 1, EndB1 = 2, EndB2 = 3 }
}
export declare class PartialTimeBarrierOption extends OneAssetOption {
  constructor(
      barrierType: Barrier.Type, barrierRange: PartialBarrier.Range,
      barrier: Real, rebate: Real, coverEventDate: Date,
      payoff: StrikedTypePayoff, exercise: Exercise);
  setupArguments(args: PricingEngine.Arguments): void;
  protected _barrierType: Barrier.Type;
  protected _barrierRange: PartialBarrier.Range;
  protected _barrier: Real;
  protected _rebate: Real;
  protected _coverEventDate: Date;
}
export declare namespace PartialTimeBarrierOption {
  class Arguments extends OneAssetOption.Arguments {
    constructor();
    validate(): void;
    barrierType: Barrier.Type;
    barrierRange: PartialBarrier.Range;
    barrier: Real;
    rebate: Real;
    coverEventDate: Date;
  }
  class Results extends OneAssetOption.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class SimpleChooserOption extends OneAssetOption {
  constructor(choosingDate: Date, strike: Real, exercise: Exercise);
  setupArguments(args: PricingEngine.Arguments): void;
  protected _choosingDate: Date;
}
export declare namespace SimpleChooserOption {
  class Arguments extends OneAssetOption.Arguments {
    constructor();
    validate(): void;
    choosingDate: Date;
  }
  class Results extends OneAssetOption.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class SpreadOption extends MultiAssetOption {
  constructor(payoff: PlainVanillaPayoff, exercise: Exercise);
}
export declare namespace SpreadOption {
  class Arguments extends MultiAssetOption.Arguments {}
  class Results extends MultiAssetOption.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class TwoAssetBarrierOption extends Option {
  constructor(
      barrierType: Barrier.Type, barrier: Real, payoff: StrikedTypePayoff,
      exercise: Exercise);
  isExpired(): boolean;
  setupArguments(args: PricingEngine.Arguments): void;
  protected _barrierType: Barrier.Type;
  protected _barrier: Real;
}
export declare namespace TwoAssetBarrierOption {
  class Arguments extends Option.Arguments {
    constructor();
    validate(): void;
    barrierType: Barrier.Type;
    barrier: Real;
  }
  class Results extends Option.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
    triggered(underlying: Real): boolean;
  }
}

export declare class TwoAssetCorrelationOption extends MultiAssetOption {
  constructor(
      type: Option.Type, strike1: Real, strike2: Real, exercise: Exercise);
  setupArguments(args: PricingEngine.Arguments): void;
  protected _X2: Real;
}
export declare namespace TwoAssetCorrelationOption {
  class Arguments extends MultiAssetOption.Arguments {
    constructor();
    validate(): void;
    X2: Real;
  }
  class Results extends MultiAssetOption.Results {}
  class engine extends GenericEngine<Arguments, Results> {}
}

export declare class WriterExtensibleOption extends OneAssetOption {
  constructor(
      payoff1: PlainVanillaPayoff, exercise1: Exercise,
      payoff2: PlainVanillaPayoff, exercise2: Exercise);
  payoff2(): Payoff;
  exercise2(): Exercise;
  isExpired(): boolean;
  setupArguments(args: PricingEngine.Arguments): void;
  private _payoff2;
  private _exercise2;
}
export declare namespace WriterExtensibleOption {
  class Arguments extends OneAssetOption.Arguments {
    constructor();
    validate(): void;
    payoff2: Payoff;
    exercise2: Exercise;
  }
  class Results extends OneAssetOption.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class BSMRNDCalculator extends RiskNeutralDensityCalculator {
  constructor(process: GeneralizedBlackScholesProcess);
  pdf(x: Real, t: Time): Real;
  cdf(x: Real, t: Time): Real;
  invcdf(x: Real, t: Time): Real;
  private distributionParams;
  private _process;
}

export declare class DynProgVPPIntrinsicValueEngine extends
    GenericEngine<VanillaVPPOption.Arguments, VanillaVPPOption.Results> {
  constructor(
      fuelPrices: Real[], powerPrices: Real[], fuelCostAddon: Real,
      rTS: YieldTermStructure);
  calculate(): void;
  private _fuelPrices;
  private _powerPrices;
  private _fuelCostAddon;
}

export declare class FdExtOUJumpVanillaEngine extends
    GenericEngine<VanillaOptionEngine.Arguments, VanillaOptionEngine.Results> {
  constructor(
      process: ExtOUWithJumpsProcess, rTS: YieldTermStructure, tGrid?: Size,
      xGrid?: Size, yGrid?: Size, schemeDesc?: FdmSchemeDesc);
  calculate(): void;
  private _process;
  private _rTS;
  private _tGrid;
  private _xGrid;
  private _yGrid;
  private _schemeDesc;
}

export declare class FdHestonDoubleBarrierEngine extends GenericModelEngine<
    HestonModel, DoubleBarrierOptionEngine.Arguments,
    DoubleBarrierOptionEngine.Results> {
  constructor(
      model: HestonModel, tGrid?: Size, xGrid?: Size, vGrid?: Size,
      dampingSteps?: Size, schemeDesc?: FdmSchemeDesc,
      leverageFct?: LocalVolTermStructure);
}

export declare class FdKlugeExtOUSpreadEngine extends
    GenericEngine<VanillaOptionEngine.Arguments, VanillaOptionEngine.Results> {
  constructor(
      klugeOUProcess: KlugeExtOUProcess, rTS: YieldTermStructure, tGrid?: Size,
      xGrid?: Size, yGrid?: Size, uGrid?: Size, gasShape?: GasShape,
      powerShape?: PowerShape, schemeDesc?: FdmSchemeDesc);
  calculate(): void;
  private _klugeOUProcess;
  private _rTS;
  private _tGrid;
  private _xGrid;
  private _yGrid;
  private _uGrid;
  private _gasShape;
  private _powerShape;
  private _schemeDesc;
}
declare type GasShape = FdmExtOUJumpModelInnerValue.Shape;
declare type PowerShape = FdmExtOUJumpModelInnerValue.Shape;

export declare class FdmBlackScholesFwdOp extends FdmLinearOpComposite {
  constructor(
      mesher: FdmMesher, bsProcess: GeneralizedBlackScholesProcess,
      strike: Real, localVol?: boolean, illegalLocalVolOverwrite?: Real,
      direction?: Size);
  size(): Size;
  setTime(t1: Time, t2: Time): void;
  apply(u: Real[]): Real[];
  apply_mixed(r: Real[]): Real[];
  apply_direction(direction: Size, r: Real[]): Real[];
  solve_splitting(direction: Size, r: Real[], dt: Real): Real[];
  preconditioner(r: Real[], dt: Real): Real[];
  private _mesher;
  private _rTS;
  private _qTS;
  private _volTS;
  private _localVol;
  private _x;
  private _dxMap;
  private _dxxMap;
  private _mapT;
  private _strike;
  private _illegalLocalVolOverwrite;
  private _direction;
}

export declare class FdmDupire1dOp extends FdmLinearOpComposite {
  constructor(mesher: FdmMesher, localVolatility: Real[]);
  size(): Size;
  setTime(t1: Time, t2: Time): void;
  apply(u: Real[]): Real[];
  apply_mixed(r: Real[]): Real[];
  apply_direction(direction: Size, r: Real[]): Real[];
  solve_splitting(direction: Size, r: Real[], dt: Real): Real[];
  preconditioner(r: Real[], dt: Real): Real[];
  _mesher: FdmMesher;
  _localVolatility: Real[];
  private _mapT;
}

export declare class FdmExpExtOUInnerValueCalculator extends
    FdmInnerValueCalculator {
  constructor(
      payoff: Payoff, mesher: FdmMesher,
      shape?: FdmExpExtOUInnerValueCalculator.Shape, direction?: Size);
  innerValue(iter: FdmLinearOpIterator, t: Time): Real;
  avgInnerValue(iter: FdmLinearOpIterator, t: Time): Real;
  private _direction;
  private _payoff;
  private _mesher;
  private _shape;
}
export declare namespace FdmExpExtOUInnerValueCalculator {
  type Shape = Array<[Time, Real]>;
}

export declare class FdmExtendedOrnsteinUhlenbeckOp extends
    FdmLinearOpComposite {
  constructor(
      mesher: FdmMesher, process: ExtendedOrnsteinUhlenbeckProcess,
      rTS: YieldTermStructure, bcSet: FdmBoundaryConditionSet,
      direction?: Size);
  size(): Size;
  setTime(t1: Time, t2: Time): void;
  apply(u: Real[]): Real[];
  apply_mixed(r: Real[]): Real[];
  apply_direction(direction: Size, r: Real[]): Real[];
  solve_splitting(direction: Size, r: Real[], dt: Real): Real[];
  preconditioner(r: Real[], dt: Real): Real[];
  private _mesher;
  private _process;
  private _rTS;
  _bcSet: FdmBoundaryConditionSet;
  private _direction;
  private _x;
  private _dxMap;
  private _dxxMap;
  private _mapX;
}

export declare class FdmExtOUJumpModelInnerValue extends
    FdmInnerValueCalculator {
  constructor(
      payoff: Payoff, mesher: FdmMesher,
      shape?: FdmExtOUJumpModelInnerValue.Shape);
  innerValue(iter: FdmLinearOpIterator, t: Time): Real;
  private _payoff;
  private _mesher;
  private _shape;
}
export declare namespace FdmExtOUJumpModelInnerValue {
  type Shape = Array<[Time, Real]>;
}

export declare class FdmExtOUJumpOp extends FdmLinearOpComposite {
  constructor(
      mesher: FdmMesher, process: ExtOUWithJumpsProcess,
      rTS: YieldTermStructure, bcSet: FdmBoundaryConditionSet,
      integroIntegrationOrder: Size);
  size(): Size;
  setTime(t1: Time, t2: Time): void;
  apply(r: Real[]): Real[];
  apply_mixed(r: Real[]): Real[];
  apply_direction(direction: Size, r: Real[]): Real[];
  solve_splitting(direction: Size, r: Real[], a: Real): Real[];
  preconditioner(r: Real[], dt: Real): Real[];
  integro(r: Real[]): Real[];
  private _mesher;
  private _process;
  _rTS: YieldTermStructure;
  private _bcSet;
  private _gaussLaguerreIntegration;
  _x: Real[];
  private _ouOp;
  private _dyMap;
  private _integroPart;
}

export declare class FdmExtOUJumpSolver extends LazyObject {
  constructor(
      process: Handle<ExtOUWithJumpsProcess>, rTS: YieldTermStructure,
      solverDesc: FdmSolverDesc, schemeDesc?: FdmSchemeDesc);
  valueAt(x: Real, y: Real): Real;
  performCalculations(): void;
  private _process;
  private _rTS;
  private _solverDesc;
  private _schemeDesc;
  private _solver;
}

export declare class FdmHestonFwdOp extends FdmLinearOpComposite {
  constructor(
      mesher: FdmMesher, process: HestonProcess,
      type?: FdmSquareRootFwdOp.TransformationType,
      leverageFct?: LocalVolTermStructure);
  size(): Size;
  setTime(t1: Time, t2: Time): void;
  apply(u: Real[]): Real[];
  apply_mixed(u: Real[]): Real[];
  apply_direction(direction: Size, u: Real[]): Real[];
  solve_splitting(direction: Size, u: Real[], s: Real): Real[];
  preconditioner(u: Real[], dt: Real): Real[];
  private getLeverageFctSlice;
  private _type;
  private _kappa;
  private _theta;
  private _sigma;
  private _rho;
  _v0: Real;
  private _rTS;
  private _qTS;
  private _varianceValues;
  private _dxMap;
  private _dxxMap;
  private _boundary;
  private _L;
  private _mapX;
  private _mapY;
  private _correlation;
  private _leverageFct;
  private _mesher;
  _x: Real[];
}

export declare class FdmHestonGreensFct {
  constructor(
      mesher: FdmMesher, process: HestonProcess,
      trafoType: FdmSquareRootFwdOp.TransformationType, l0?: Real);
  get(t: Time, algorithm: FdmHestonGreensFct.Algorithm): Real[];
  private _l0;
  private _mesher;
  private _process;
  private _trafoType;
}
export declare namespace FdmHestonGreensFct {
  enum Algorithm { ZeroCorrelation = 0, Gaussian = 1, SemiAnalytical = 2 }
}

export declare class FdmKlugeExtOUOp extends FdmLinearOpComposite {
  constructor(
      mesher: FdmMesher, klugeOUProcess: KlugeExtOUProcess,
      rTS: YieldTermStructure, bcSet: FdmBoundaryConditionSet,
      integroIntegrationOrder: Size);
  size(): Size;
  setTime(t1: Time, t2: Time): void;
  apply(r: Real[]): Real[];
  apply_mixed(r: Real[]): Real[];
  apply_direction(direction: Size, r: Real[]): Real[];
  solve_splitting(direction: Size, r: Real[], a: Real): Real[];
  preconditioner(r: Real[], dt: Real): Real[];
  private _mesher;
  private _kluge;
  private _extOU;
  private _klugeOp;
  private _ouOp;
  private _corrMap;
}

export declare class FdmKlugeExtOUSolver extends LazyObject {
  constructor(N?: Size);
  fdmkeousInit(
      klugeOUProcess: Handle<KlugeExtOUProcess>, rTS: YieldTermStructure,
      solverDesc: FdmSolverDesc,
      schemeDesc?: FdmSchemeDesc): FdmKlugeExtOUSolver;
  valueAt(x: Real[]): Real;
  performCalculations(): void;
  N: Size;
  private _klugeOUProcess;
  private _rTS;
  private _solverDesc;
  private _schemeDesc;
  private _solver;
}

export declare class FdmLocalVolFwdOp extends FdmLinearOpComposite {
  constructor(
      mesher: FdmMesher, spot: Quote, rTS: YieldTermStructure,
      qTS: YieldTermStructure, localVol: LocalVolTermStructure,
      direction?: Size);
  size(): Size;
  setTime(t1: Time, t2: Time): void;
  apply(u: Real[]): Real[];
  apply_mixed(r: Real[]): Real[];
  apply_direction(direction: Size, r: Real[]): Real[];
  solve_splitting(direction: Size, r: Real[], dt: Real): Real[];
  preconditioner(r: Real[], dt: Real): Real[];
  private _mesher;
  private _rTS;
  private _qTS;
  private _localVol;
  private _x;
  private _dxMap;
  private _dxxMap;
  private _mapT;
  private _direction;
}

export declare class FdmSimple2dExtOUSolver extends LazyObject {
  constructor(
      process: Handle<ExtendedOrnsteinUhlenbeckProcess>,
      rTS: YieldTermStructure, solverDesc: FdmSolverDesc,
      schemeDesc?: FdmSchemeDesc);
  valueAt(x: Real, y: Real): Real;
  performCalculations(): void;
  private _process;
  private _rTS;
  private _solverDesc;
  private _schemeDesc;
  private _solver;
}

export declare class FdmSimple3dExtOUJumpSolver extends LazyObject {
  constructor(
      process: Handle<ExtOUWithJumpsProcess>, rTS: YieldTermStructure,
      solverDesc: FdmSolverDesc, schemeDesc?: FdmSchemeDesc);
  valueAt(x: Real, y: Real, z: Real): Real;
  performCalculations(): void;
  private _process;
  private _rTS;
  private _solverDesc;
  private _schemeDesc;
  private _solver;
}

export declare class FdmSpreadPayoffInnerValue extends FdmInnerValueCalculator {
  constructor(
      payoff: BasketPayoff, calc1: FdmInnerValueCalculator,
      calc2: FdmInnerValueCalculator);
  innerValue(iter: FdmLinearOpIterator, t: Time): Real;
  avgInnerValue(iter: FdmLinearOpIterator, t: Time): Real;
  private _payoff;
  private _calc1;
  private _calc2;
}

export declare class FdmSquareRootFwdOp extends FdmLinearOpComposite {
  constructor(
      mesher: FdmMesher, kappa: Real, theta: Real, sigma: Real, direction: Size,
      transform?: FdmSquareRootFwdOp.TransformationType);
  size(): Size;
  setTime(t1: Time, t2: Time): void;
  apply(p: Real[]): Real[];
  apply_mixed(r: Real[]): Real[];
  apply_direction(direction: Size, r: Real[]): Real[];
  solve_splitting(direction: Size, r: Real[], dt: Real): Real[];
  preconditioner(r: Real[], dt: Real): Real[];
  lowerBoundaryFactor(transform?: FdmSquareRootFwdOp.TransformationType): Real;
  upperBoundaryFactor(transform?: FdmSquareRootFwdOp.TransformationType): Real;
  v(i: Size): Real;
  private setLowerBC;
  private setUpperBC;
  private getCoeff;
  private getCoeffPlain;
  private getCoeffPower;
  private getCoeffLog;
  private f0Plain;
  private f1Plain;
  private f0Power;
  private f1Power;
  private f0Log;
  private f1Log;
  private h;
  private zetam;
  private zeta;
  private zetap;
  private mu;
  private _direction;
  private _kappa;
  private _theta;
  private _sigma;
  private _transform;
  private _mapX;
  private _v;
}
export declare namespace FdmSquareRootFwdOp {
  enum TransformationType { Plain = 0, Power = 1, Log = 2 }
}

export declare class FdmVPPStartLimitStepCondition extends FdmVPPStepCondition {
  constructor(
      params: FdmVPPStepConditionParams, nStarts: Size,
      mesh: FdmVPPStepConditionMesher, gasPrice: FdmInnerValueCalculator,
      sparkSpreadPrice: FdmInnerValueCalculator);
  static nStates(tMinUp: Size, tMinDown: Size, nStarts: Size): Size;
  maxValue(states: Real[]): Real;
  changeState(gasPrice: Real, state: Real[], t: Time): Real[];
  private _nStarts;
}

export declare class FdmVPPStepConditionParams {
  constructor(
      heatRate: Real, pMin: Real, pMax: Real, tMinUp: Size, tMinDown: Size,
      startUpFuel: Real, startUpFixCost: Real, fuelCostAddon: Real);
  heatRate: Real;
  pMin: Real;
  pMax: Real;
  tMinUp: Size;
  tMinDown: Size;
  startUpFuel: Real;
  startUpFixCost: Real;
  fuelCostAddon: Real;
}
export declare class FdmVPPStepConditionMesher {
  constructor(stateDirection: Size, mesher: FdmMesher);
  stateDirection: Size;
  mesher: FdmMesher;
}
export declare class FdmVPPStepCondition extends StepCondition {
  constructor(
      params: FdmVPPStepConditionParams, nStates: Size,
      mesh: FdmVPPStepConditionMesher, gasPrice: FdmInnerValueCalculator,
      sparkSpreadPrice: FdmInnerValueCalculator);
  nStates(): Size;
  applyTo(a: Real[], t: Time): void;
  maxValue(states: Real[]): Real;
  evolveAtPMin(sparkSpread: Real): Real;
  evolveAtPMax(sparkSpread: Real): Real;
  evolve(iter: FdmLinearOpIterator, t: Time): Real;
  changeState(gasPrice: Real, state: Real[], t: Time): Real[];
  protected _heatRate: Real;
  protected _pMin: Real;
  protected _pMax: Real;
  protected _tMinUp: Size;
  protected _tMinDown: Size;
  protected _startUpFuel: Real;
  protected _startUpFixCost: Real;
  protected _fuelCostAddon: Real;
  protected _stateDirection: Size;
  protected _nStates: Size;
  protected _mesher: FdmMesher;
  protected _gasPrice: FdmInnerValueCalculator;
  protected _sparkSpreadPrice: FdmInnerValueCalculator;
  protected _stateEvolveFcts: Array<UnaryFunction<Real, Real>>;
}

export declare class FdmVPPStepConditionFactory {
  constructor(args: VanillaVPPOption.Arguments);
  stateMesher(): Fdm1dMesher;
  build(
      mesh: FdmVPPStepConditionMesher, fuelCostAddon: Real,
      fuel: FdmInnerValueCalculator,
      spark: FdmInnerValueCalculator): FdmVPPStepCondition;
  private _type;
  private _args;
}
export declare namespace FdmVPPStepConditionFactory {
  enum Type { Vanilla = 0, StartLimit = 1, RunningHourLimit = 2 }
}

export declare class FdmZabrUnderlyingPart {
  constructor(mesher: FdmMesher, beta: Real, nu: Real, rho: Real, gamma: Real);
  setTime(t1: Time, t2: Time): void;
  getMap(): TripleBandLinearOp;
  protected _volatilityValues: Real[];
  protected _forwardValues: Real[];
  protected _mapT: TripleBandLinearOp;
  protected _mesher: FdmMesher;
}
export declare class FdmZabrVolatilityPart {
  constructor(mesher: FdmMesher, beta: Real, nu: Real, rho: Real, gamma: Real);
  setTime(t1: Time, t2: Time): void;
  getMap(): TripleBandLinearOp;
  protected _volatilityValues: Real[];
  protected _forwardValues: Real[];
  protected _mapT: TripleBandLinearOp;
  protected _mesher: FdmMesher;
}
export declare class FdmZabrOp extends FdmLinearOpComposite {
  constructor(mesher: FdmMesher, beta: Real, nu: Real, rho: Real, gamma?: Real);
  size(): Size;
  setTime(t1: Time, t2: Time): void;
  apply(u: Real[]): Real[];
  apply_mixed(r: Real[]): Real[];
  apply_direction(direction: Size, r: Real[]): Real[];
  solve_splitting(direction: Size, r: Real[], a: Real): Real[];
  preconditioner(r: Real[], dt: Real): Real[];
  toMatrixDecomp(): SparseMatrix[];
  private _volatilityValues;
  private _forwardValues;
  private _dxyMap;
  private _dxMap;
  private _dyMap;
}

export declare class FdOrnsteinUhlenbeckVanillaEngine extends
    DividendVanillaOptionEngine.engine {
  constructor(
      process: OrnsteinUhlenbeckProcess, rTS: YieldTermStructure, tGrid?: Size,
      xGrid?: Size, dampingSteps?: Size, epsilon?: Real,
      schemeDesc?: FdmSchemeDesc);
  calculate(): void;
  private _process;
  private _rTS;
  private _tGrid;
  private _xGrid;
  private _dampingSteps;
  private _epsilon;
  private _schemeDesc;
}

export declare class FdSimpleExtOUJumpSwingEngine extends
    GenericEngine<VanillaSwingOption.Arguments, VanillaSwingOption.Results> {
  constructor(
      process: ExtOUWithJumpsProcess, rTS: YieldTermStructure, tGrid?: Size,
      xGrid?: Size, yGrid?: Size, shape?: FdmExtOUJumpModelInnerValue.Shape,
      schemeDesc?: FdmSchemeDesc);
  calculate(): void;
  private _process;
  private _rTS;
  private _shape;
  private _tGrid;
  private _xGrid;
  private _yGrid;
  private _schemeDesc;
}

export declare class FdSimpleExtOUStorageEngine extends GenericEngine<
    VanillaStorageOption.Arguments, VanillaStorageOption.Results> {
  constructor(
      process: ExtendedOrnsteinUhlenbeckProcess, rTS: YieldTermStructure,
      tGrid?: Size, xGrid?: Size, yGrid?: Size,
      shape?: FdmExpExtOUInnerValueCalculator.Shape,
      schemeDesc?: FdmSchemeDesc);
  calculate(): void;
  private _process;
  private _rTS;
  private _tGrid;
  private _xGrid;
  private _yGrid;
  private _shape;
  private _schemeDesc;
}

export declare class FdSimpleKlugeExtOUVPPEngine extends
    GenericEngine<VanillaVPPOption.Arguments, VanillaVPPOption.Results> {
  constructor(
      process: KlugeExtOUProcess, rTS: YieldTermStructure,
      fuelShape: FdSimpleKlugeExtOUVPPEngine.Shape,
      powerShape: FdSimpleKlugeExtOUVPPEngine.Shape, fuelCostAddon: Real,
      tGrid?: Size, xGrid?: Size, yGrid?: Size, gGrid?: Size,
      schemeDesc?: FdmSchemeDesc);
  calculate(): void;
  private _process;
  private _rTS;
  private _fuelCostAddon;
  private _fuelShape;
  private _powerShape;
  private _tGrid;
  private _xGrid;
  private _yGrid;
  private _gGrid;
  private _schemeDesc;
}
export declare namespace FdSimpleKlugeExtOUVPPEngine {
  type Shape = FdmExtOUJumpModelInnerValue.Shape;
}

export declare class GBSMRNDCalculator extends RiskNeutralDensityCalculator {
  constructor(process: GeneralizedBlackScholesProcess);
  pdf(k: Real, t: Time): Real;
  cdf(k: Real, t: Time): Real;
  invcdf(q: Real, t: Time): Real;
  private _process;
}

export declare class Glued1dMesher extends Fdm1dMesher {
  constructor(leftMesher: Fdm1dMesher, rightMesher: Fdm1dMesher);
  private _commonPoint;
}

export declare class HestonRNDCalculator extends RiskNeutralDensityCalculator {
  constructor(
      hestonProcess: HestonProcess, integrationEps?: Real,
      maxIntegrationIterations?: Size);
  pdf(x: Real, t: Time): Real;
  cdf(x: Real, t: Time): Real;
  invcdf(p: Real, t: Time): Real;
  private x_t;
  private _hestonProcess;
  private _x0;
  private _integrationEps;
  private _maxIntegrationIterations;
}

export declare class RiskNeutralDensityCalculatorLazyObject implements
    Observable, Observer, RiskNeutralDensityCalculator, LazyObject {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  pdf(x: Real, t: Time): Real;
  cdf(x: Real, t: Time): Real;
  invcdf(p: Real, t: Time): Real;
  recalculate: () => void;
  freeze: () => void;
  unfreeze: () => void;
  alwaysForwardNotifications: () => void;
  calculate: () => void;
  performCalculations(): void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _calculated: boolean;
  _frozen: boolean;
  _alwaysForward: boolean;
}

export declare class LocalVolRNDCalculator extends
    RiskNeutralDensityCalculatorLazyObject {
  lvrndcInit1(
      spot: Quote, rTS: YieldTermStructure, qTS: YieldTermStructure,
      localVol: LocalVolTermStructure, xGrid?: Size, tGrid?: Size,
      x0Density?: Real, eps?: Real, maxIter?: Size,
      gaussianStepSize?: Time): LocalVolRNDCalculator;
  lvrndcInit2(
      spot: Quote, rTS: YieldTermStructure, qTS: YieldTermStructure,
      localVol: LocalVolTermStructure, timeGrid: TimeGrid, xGrid?: Size,
      x0Density?: Real, eps?: Real, maxIter?: Size,
      gaussianStepSize?: Time): LocalVolRNDCalculator;
  pdf(x: Real, t: Time): Real;
  cdf(x: Real, t: Time): Real;
  invcdf(p: Real, t: Time): Real;
  timeGrid(): TimeGrid;
  mesher(t: Time): Fdm1dMesher;
  rescaleTimeSteps(): Size[];
  performCalculations(): void;
  probabilityInterpolation(idx: Size, x: Real): Real;
  rescalePDF(x: Real[], p: Real[]): Real[];
  private _xGrid;
  private _tGrid;
  private _x0Density;
  private _localVolProbEps;
  private _maxIter;
  private _gaussianStepSize;
  private _spot;
  private _localVol;
  private _rTS;
  private _qTS;
  private _timeGrid;
  private _xm;
  private _pm;
  private _rescaleTimeSteps;
  private _pFct;
}

export declare class ModTripleBandLinearOp extends TripleBandLinearOp {
  mtblopInit1(direction: Size, mesher: FdmMesher): ModTripleBandLinearOp;
  mtblopInit2(m: TripleBandLinearOp): ModTripleBandLinearOp;
  lower(): Real[];
  diag(): Real[];
  upper(): Real[];
}

export declare class RiskNeutralDensityCalculator {
  pdf(x: Real, t: Time): Real;
  cdf(x: Real, t: Time): Real;
  invcdf(p: Real, t: Time): Real;
}
export declare namespace RiskNeutralDensityCalculator {
  class InvCDFHelper {
    constructor(
        calculator: RiskNeutralDensityCalculator, guess: Real, accuracy: Real,
        maxEvaluations: Size);
    inverseCDF(p: Real, t: Time): Real;
    private _calculator;
    private _guess;
    private _accuracy;
    private _maxEvaluations;
  }
}

export declare class SquareRootProcessRNDCalculator extends
    RiskNeutralDensityCalculator {
  constructor(v0: Real, kappa: Real, theta: Real, sigma: Real);
  pdf(v: Real, t: Time): Real;
  cdf(v: Real, t: Time): Real;
  invcdf(q: Real, t: Time): Real;
  stationary_pdf(v: Real): Real;
  stationary_cdf(v: Real): Real;
  stationary_invcdf(q: Real): Real;
  private _v0;
  private _kappa;
  private _theta;
  private _d;
  private _df;
}

export declare class VanillaVPPOption extends MultiAssetOption {
  constructor(
      heatRate: Real, pMin: Real, pMax: Real, tMinUp: Size, tMinDown: Size,
      startUpFuel: Real, startUpFixCost: Real, exercise: SwingExercise,
      nStarts?: Size, nRunningHours?: Size);
  isExpired(): boolean;
  setupArguments(args: PricingEngine.Arguments): void;
  private _heatRate;
  private _pMin;
  private _pMax;
  private _tMinUp;
  private _tMinDown;
  private _startUpFuel;
  private _startUpFixCost;
  private _nStarts;
  private _nRunningHours;
}
export declare namespace VanillaVPPOption {
  class Arguments extends MultiAssetOption.Arguments {
    constructor();
    validate(): void;
    heatRate: Real;
    pMin: Real;
    pMax: Real;
    tMinUp: Size;
    tMinDown: Size;
    startUpFuel: Real;
    startUpFixCost: Real;
    nStarts: Size;
    nRunningHours: Size;
  }
  class Results extends MultiAssetOption.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class BlackDeltaCalculator {
  constructor(
      ot: Option.Type, dt: DeltaVolQuote.DeltaType, spot: Real,
      dDiscount: DiscountFactor, fDiscount: DiscountFactor, stdDev: Real);
  deltaFromStrike(strike: Real): Real;
  strikeFromDelta(delta: Real): Real;
  cumD1(strike: Real): Real;
  cumD2(strike: Real): Real;
  nD1(strike: Real): Real;
  nD2(strike: Real): Real;
  setDeltaType(dt: DeltaVolQuote.DeltaType): void;
  setOptionType(ot: Option.Type): void;
  atmStrike(atmT: DeltaVolQuote.AtmType): Real;
  private strikeFromDelta_;
  private _dt;
  private _ot;
  private _dDiscount;
  private _fDiscount;
  private _stdDev;
  private _spot;
  private _forward;
  private _phi;
  private _fExpPos;
  private _fExpNeg;
}

export declare class DeltaVolQuote extends QuoteObserver {
  init1(
      delta: Real, vol: Handle<Quote>, maturity: Time,
      deltaType: DeltaVolQuote.DeltaType): DeltaVolQuote;
  init2(
      vol: Handle<Quote>, deltaType: DeltaVolQuote.DeltaType, maturity: Time,
      atmType: DeltaVolQuote.AtmType): DeltaVolQuote;
  update(): void;
  value(): Real;
  delta(): Real;
  maturity(): Time;
  atmType(): DeltaVolQuote.AtmType;
  deltaType(): DeltaVolQuote.DeltaType;
  isValid(): boolean;
  private _delta;
  private _vol;
  private _deltaType;
  private _maturity;
  private _atmType;
}
export declare namespace DeltaVolQuote {
  enum DeltaType { Spot = 0, Fwd = 1, PaSpot = 2, PaFwd = 3 }
  enum AtmType {
    AtmNull = 0,
    AtmSpot = 1,
    AtmFwd = 2,
    AtmDeltaNeutral = 3,
    AtmVegaMax = 4,
    AtmGammaMax = 5,
    AtmPutCall50 = 6
  }
}

export declare class InterpolatingCPICapFloorEngine extends CPICapFloor.engine {
  constructor(priceSurf: Handle<CPICapFloorTermPriceSurface>);
  calculate(): void;
  name(): string;
  protected _priceSurf: Handle<CPICapFloorTermPriceSurface>;
}

export declare class CPICapFloorTermPriceSurface extends
    InflationTermStructure {
  cpicftpsInit(
      nominal: Real, baseRate: Real, observationLag: Period, cal: Calendar,
      bdc: BusinessDayConvention, dc: DayCounter,
      zii: Handle<ZeroInflationIndex>, yts: Handle<YieldTermStructure>,
      cStrikes: Rate[], fStrikes: Rate[], cfMaturities: Period[],
      cPrice: Matrix, fPrice: Matrix): CPICapFloorTermPriceSurface;
  observationLag(): Period;
  baseDate(): Date;
  zeroInflationIndex(): Handle<ZeroInflationIndex>;
  nominal(): Real;
  businessDayConvention(): BusinessDayConvention;
  price1(d: Period, k: Rate): Real;
  capPrice1(d: Period, k: Rate): Real;
  floorPrice1(d: Period, k: Rate): Real;
  price2(d: Date, k: Rate): Real;
  capPrice2(d: Date, k: Rate): Real;
  floorPrice2(d: Date, k: Rate): Real;
  strikes(): Rate[];
  capStrikes(): Rate[];
  floorStrikes(): Rate[];
  maturities(): Period[];
  capPrices(): Matrix;
  floorPrices(): Matrix;
  minStrike(): Rate;
  maxStrike(): Rate;
  minDate(): Date;
  maxDate(): Date;
  cpiOptionDateFromTenor(p: Period): Date;
  protected checkStrike(K: Rate): boolean;
  protected checkMaturity(d: Date): boolean;
  protected _zii: Handle<ZeroInflationIndex>;
  protected _cStrikes: Rate[];
  protected _fStrikes: Rate[];
  protected _cfMaturities: Period[];
  protected _cfMaturityTimes: Real[];
  protected _cPrice: Matrix;
  protected _fPrice: Matrix;
  protected _cfStrikes: Rate[];
  private _nominal;
  private _bdc;
}
export declare class InterpolatedCPICapFloorTermPriceSurface extends
    CPICapFloorTermPriceSurface {
  constructor(interpolator: Interpolator2D);
  icpicftpsInit(
      nominal: Real, startRate: Rate, observationLag: Period, cal: Calendar,
      bdc: BusinessDayConvention, dc: DayCounter,
      zii: Handle<ZeroInflationIndex>, yts: Handle<YieldTermStructure>,
      cStrikes: Rate[], fStrikes: Rate[], cfMaturities: Period[],
      cPrice: Matrix, fPrice: Matrix,
      interpolator2d?: Interpolator2D): InterpolatedCPICapFloorTermPriceSurface;
  performCalculations(): void;
  price2(d: Date, k: Rate): Real;
  capPrice2(d: Date, k: Rate): Real;
  floorPrice2(d: Date, k: Rate): Real;
  protected _cPriceB: Matrix;
  protected _fPriceB: Matrix;
  protected _capPrice: Interpolation2D;
  protected _floorPrice: Interpolation2D;
  protected _interpolator2d: Interpolator2D;
}

export declare class GenericRegion extends Region {
  constructor();
}
export declare class GenericCPI extends ZeroInflationIndex {
  constructor(
      frequency: Frequency, revised: boolean, interpolated: boolean,
      lag: Period, ccy: Currency, ts?: Handle<ZeroInflationTermStructure>);
}
export declare class YYGenericCPI extends YoYInflationIndex {
  constructor(
      frequency: Frequency, revised: boolean, interpolated: boolean,
      lag: Period, ccy: Currency, ts?: Handle<YoYInflationTermStructure>);
}
export declare class YYGenericCPIr extends YoYInflationIndex {
  constructor(
      frequency: Frequency, revised: boolean, interpolated: boolean,
      lag: Period, ccy: Currency, ts?: Handle<YoYInflationTermStructure>);
}

export declare class InterpolatedYoYOptionletStripper extends
    YoYOptionletStripper {
  constructor(interpolator: Interpolator);
}

export declare class KInterpolatedYoYOptionletVolatilitySurface extends
    YoYOptionletVolatilitySurface {
  constructor(interpolator: Interpolator);
  kiyoyovsInit(
      settlementDays: Natural, cal: Calendar, bdc: BusinessDayConvention,
      dc: DayCounter, lag: Period, capFloorPrices: YoYCapFloorTermPriceSurface,
      pricer: YoYInflationCapFloorEngine,
      yoyOptionletStripper: YoYOptionletStripper, slope: Real,
      interpolator?: Interpolator): KInterpolatedYoYOptionletVolatilitySurface;
  minStrike(): Real;
  maxStrike(): Real;
  maxDate(): Date;
  Dslice(d: Date): [Rate[], Volatility[]];
  volatilityImpl1(d: Date, strike: Rate): Volatility;
  volatilityImpl2(length: Time, strike: Rate): Volatility;
  performCalculations(): void;
  private updateSlice;
  protected _capFloorPrices: YoYCapFloorTermPriceSurface;
  protected _yoyInflationCouponPricer: YoYInflationCapFloorEngine;
  protected _yoyOptionletStripper: YoYOptionletStripper;
  protected _factory1D: Interpolator;
  protected _slope: Real;
  protected _lastDateisSet: boolean;
  protected _lastDate: Date;
  protected _tempKinterpolation: Interpolation;
  protected _slice: [Rate[], Volatility[]];
}

declare class YoYOptionletVolatilitySurfaceInterpolatedCurve implements
    Observable, Observer, Extrapolator, TermStructure, VolatilityTermStructure,
    YoYOptionletVolatilitySurface, InterpolatedCurve {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update: () => void;
  deepUpdate: () => void;
  enableExtrapolation: (b: boolean) => void;
  disableExtrapolation: (b: boolean) => void;
  allowsExtrapolation: () => boolean;
  tsInit1: (dc: DayCounter) => TermStructure;
  tsInit2:
      (referenceDate: Date, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  tsInit3:
      (settlementDays: Natural, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  dayCounter: () => DayCounter;
  timeFromReference: (date: Date) => Time;
  maxDate(): Date;
  maxTime: () => Time;
  referenceDate: () => Date;
  calendar: () => Calendar;
  settlementDays: () => Natural;
  checkRange1: (d: Date, extrapolate: boolean) => void;
  checkRange2: (t: Time, extrapolate: boolean) => void;
  vtsInit1:
      (bdc: BusinessDayConvention, dc?: DayCounter) => VolatilityTermStructure;
  vtsInit2:
      (referenceDate: Date, cal: Calendar, bdc: BusinessDayConvention,
       dc?: DayCounter) => VolatilityTermStructure;
  vtsInit3:
      (settlementDays: Natural, cal: Calendar, bdc: BusinessDayConvention,
       dc?: DayCounter) => VolatilityTermStructure;
  businessDayConvention: () => BusinessDayConvention;
  optionDateFromTenor: (p: Period) => Date;
  minStrike(): Rate;
  maxStrike(): Rate;
  checkStrike: (k: Rate, extrapolate: boolean) => void;
  yoyovsInit:
      (settlementDays: Natural, cal: Calendar, bdc: BusinessDayConvention,
       dc: DayCounter, observationLag: Period, frequency: Frequency,
       indexIsInterpolated: boolean) => YoYOptionletVolatilitySurface;
  volatility1:
      (maturityDate: Date, strike: Rate, obsLag?: Period,
       extrapolate?: boolean) => Volatility;
  volatility2:
      (optionTenor: Period, strike: Rate, obsLag?: Period,
       extrapolate?: boolean) => Volatility;
  totalVariance1:
      (maturityDate: Date, strike: Rate, obsLag?: Period,
       extrapolate?: boolean) => Volatility;
  totalVariance2:
      (tenor: Period, strike: Rate, obsLag?: Period,
       extrapolate?: boolean) => Volatility;
  observationLag: () => Period;
  frequency: () => Frequency;
  indexIsInterpolated: () => boolean;
  baseDate: () => Date;
  timeFromBase: (maturityDate: Date, obsLag?: Period) => Time;
  baseLevel: () => Volatility;
  checkRange3: (d: Date, strike: Rate, extrapolate: boolean) => void;
  checkRange4: (t: Time, strike: Rate, extrapolate: boolean) => void;
  volatilityImpl(length: Time, strike: Rate): Volatility;
  setBaseLevel: (v: Volatility) => void;
  icInit1: (times: Time[], data: Real[], i: Interpolator) => InterpolatedCurve;
  icInit2: (times: Time[], i: Interpolator) => InterpolatedCurve;
  icInit3: (n: Size, i: Interpolator) => InterpolatedCurve;
  icInit4: (i: Interpolator) => InterpolatedCurve;
  icInit5: (i: InterpolatedCurve) => InterpolatedCurve;
  setupInterpolation: () => void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _extrapolate: boolean;
  _moving: boolean;
  _updated: boolean;
  _calendar: Calendar;
  _referenceDate: Date;
  _settlementDays: Natural;
  _dayCounter: DayCounter;
  _bdc: BusinessDayConvention;
  _baseLevel: Volatility;
  _observationLag: Period;
  _frequency: Frequency;
  _indexIsInterpolated: boolean;
  _times: Time[];
  _data: Real[];
  _interpolation: Interpolation;
  _interpolator: Interpolator;
  _maxDate: Date;
}

declare class InterpolatedYoYOptionletVolatilityCurveLazyObject implements
    Observable, Observer, Extrapolator, TermStructure, VolatilityTermStructure,
    InterpolatedCurve, YoYOptionletVolatilitySurface,
    YoYOptionletVolatilitySurfaceInterpolatedCurve,
    InterpolatedYoYOptionletVolatilityCurve, LazyObject {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  enableExtrapolation: (b: boolean) => void;
  disableExtrapolation: (b: boolean) => void;
  allowsExtrapolation: () => boolean;
  tsInit1: (dc: DayCounter) => TermStructure;
  tsInit2:
      (referenceDate: Date, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  tsInit3:
      (settlementDays: Natural, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  dayCounter: () => DayCounter;
  timeFromReference: (date: Date) => Time;
  maxDate(): Date;
  maxTime: () => Time;
  referenceDate: () => Date;
  calendar: () => Calendar;
  settlementDays: () => Natural;
  checkRange1: (d: Date, extrapolate: boolean) => void;
  checkRange2: (t: Time, extrapolate: boolean) => void;
  vtsInit1:
      (bdc: BusinessDayConvention, dc?: DayCounter) => VolatilityTermStructure;
  vtsInit2:
      (referenceDate: Date, cal: Calendar, bdc: BusinessDayConvention,
       dc?: DayCounter) => VolatilityTermStructure;
  vtsInit3:
      (settlementDays: Natural, cal: Calendar, bdc: BusinessDayConvention,
       dc?: DayCounter) => VolatilityTermStructure;
  businessDayConvention: () => BusinessDayConvention;
  optionDateFromTenor: (p: Period) => Date;
  minStrike(): Rate;
  maxStrike(): Rate;
  checkStrike: (k: Rate, extrapolate: boolean) => void;
  yoyovsInit:
      (settlementDays: Natural, cal: Calendar, bdc: BusinessDayConvention,
       dc: DayCounter, observationLag: Period, frequency: Frequency,
       indexIsInterpolated: boolean) => YoYOptionletVolatilitySurface;
  volatility1:
      (maturityDate: Date, strike: Rate, obsLag?: Period,
       extrapolate?: boolean) => Volatility;
  volatility2:
      (optionTenor: Period, strike: Rate, obsLag?: Period,
       extrapolate?: boolean) => Volatility;
  totalVariance1:
      (maturityDate: Date, strike: Rate, obsLag?: Period,
       extrapolate?: boolean) => Volatility;
  totalVariance2:
      (tenor: Period, strike: Rate, obsLag?: Period,
       extrapolate?: boolean) => Volatility;
  observationLag: () => Period;
  frequency: () => Frequency;
  indexIsInterpolated: () => boolean;
  baseDate(): Date;
  timeFromBase: (maturityDate: Date, obsLag?: Period) => Time;
  baseLevel: () => Volatility;
  checkRange3: (d: Date, strike: Rate, extrapolate: boolean) => void;
  checkRange4: (t: Time, strike: Rate, extrapolate: boolean) => void;
  volatilityImpl(length: Time, strike: Rate): Volatility;
  setBaseLevel: (v: Volatility) => void;
  curveInit1:
      (settlementDays: Natural, cal: Calendar, bdc: BusinessDayConvention,
       dc: DayCounter, lag: Period, frequency: Frequency,
       indexIsInterpolated: boolean, d: Date[], v: Volatility[],
       minStrike: Rate, maxStrike: Rate,
       i?: Interpolator) => InterpolatedYoYOptionletVolatilityCurve;
  curveInit2:
      (settlementDays: Natural, cal: Calendar, bdc: BusinessDayConvention,
       dc: DayCounter, lag: Period, frequency: Frequency,
       indexIsInterpolated: boolean, minStrike: Rate, maxStrike: Rate,
       baseYoYVolatility: Volatility,
       i?: Interpolator) => InterpolatedYoYOptionletVolatilityCurve;
  icInit1: (times: Time[], data: Real[], i?: Interpolator) => InterpolatedCurve;
  icInit2: (times: Time[], i?: Interpolator) => InterpolatedCurve;
  icInit3: (n: Size, i?: Interpolator) => InterpolatedCurve;
  icInit4: (i?: Interpolator) => InterpolatedCurve;
  icInit5: (i: InterpolatedCurve) => InterpolatedCurve;
  setupInterpolation: () => void;
  data(): Real[];
  times(): Time[];
  dates(): Date[];
  nodes(): Array<[Date, Real]>;
  recalculate: () => void;
  freeze: () => void;
  unfreeze: () => void;
  alwaysForwardNotifications: () => void;
  calculate: () => void;
  performCalculations(): void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _extrapolate: boolean;
  _moving: boolean;
  _updated: boolean;
  _calendar: Calendar;
  _referenceDate: Date;
  _settlementDays: Natural;
  _dayCounter: DayCounter;
  _bdc: BusinessDayConvention;
  _baseLevel: Volatility;
  _observationLag: Period;
  _frequency: Frequency;
  _indexIsInterpolated: boolean;
  _dates: Date[];
  _nodes: Array<[Date, Real]>;
  _minStrike: Rate;
  _maxStrike: Rate;
  _times: Time[];
  _data: Real[];
  _interpolation: Interpolation;
  _interpolator: Interpolator;
  _maxDate: Date;
  _calculated: boolean;
  _frozen: boolean;
  _alwaysForward: boolean;
}

export declare class YoYInflationVolatilityTraits {
  static initialDate(s: YoYOptionletVolatilitySurface): Date;
  static initialValue(s: YoYOptionletVolatilitySurface): Real;
  static guess(i: Size, c: InflationCurve, validData: boolean, s: Size): Real;
  static minValueAfter(i: Size, c: InflationCurve, validData: boolean, s: Size):
      Real;
  static maxValueAfter(i: Size, c: InflationCurve, validData: boolean, s: Size):
      Real;
  static updateGuess(vols: Real[], level: Real, i: Size): void;
  static maxIterations(): Size;
}
export declare namespace YoYInflationVolatilityTraits {
  class curve {
    type: InterpolatedYoYOptionletVolatilityCurve;
  }
}
export declare class PiecewiseYoYOptionletVolatilityCurve extends
    InterpolatedYoYOptionletVolatilityCurveLazyObject {
  constructor(
      interpolator: Interpolator, traits?: Traits,
      bootstrap?: IterativeBootstrap|LocalBootstrap);
  pyoyovcInit(
      settlementDays: Natural, cal: Calendar, bdc: BusinessDayConvention,
      dc: DayCounter, lag: Period, frequency: Frequency,
      indexIsInterpolated: boolean, minStrike: Rate, maxStrike: Rate,
      baseYoYVolatility: Volatility, instruments: BootstrapHelper[],
      accuracy?: Real,
      interpolator?: Interpolator): PiecewiseYoYOptionletVolatilityCurve;
  baseDate(): Date;
  maxDate(): Date;
  times(): Time[];
  dates(): Date[];
  data(): Real[];
  nodes(): Array<[Date, Real]>;
  update(): void;
  performCalculations(): void;
  _base_curve: VolatilityCurve;
  _traits: Traits;
  _interpolator: Interpolator;
  _bootstrap: IterativeBootstrap|LocalBootstrap;
  _instruments: BootstrapHelper[];
  _accuracy: Real;
}

export declare class Polynomial2DSplineImpl extends
    Interpolation2D.templateImpl {
  constructor(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size, yEnd: Size,
      zData: Matrix);
  calculate(): void;
  value(x: Real, y: Real): Real;
  private _polynomials;
}
export declare class Polynomial2DSpline extends Interpolation2D {
  constructor(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size, yEnd: Size,
      zData: Matrix);
}
export declare class Polynomial {
  interpolate(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size, yEnd: Size,
      zData: Matrix): Interpolation2D;
}

export declare class YoYCapFloorTermPriceSurface extends
    InflationTermStructure {
  yoycftpsInit(
      fixingDays: Natural, lag: Period, yii: YoYInflationIndex, baseRate: Rate,
      nominal: Handle<YieldTermStructure>, dc: DayCounter, cal: Calendar,
      bdc: BusinessDayConvention, cStrikes: Rate[], fStrikes: Rate[],
      cfMaturities: Period[], cPrice: Matrix,
      fPrice: Matrix): YoYCapFloorTermPriceSurface;
  atmYoYSwapTimeRates(): [Time[], Rate[]];
  atmYoYSwapDateRates(): [Date[], Rate[]];
  YoYTS(): YoYInflationTermStructure;
  yoyIndex(): YoYInflationIndex;
  businessDayConvention(): BusinessDayConvention;
  fixingDays(): Natural;
  price1(d: Period, k: Rate): Real;
  capPrice1(d: Period, k: Rate): Real;
  floorPrice1(d: Period, k: Rate): Real;
  atmYoYSwapRate1(d: Period, extrapolate?: boolean): Rate;
  atmYoYRate1(d: Period, obsLag?: Period, extrapolate?: boolean): Rate;
  price2(d: Date, k: Rate): Real;
  capPrice2(d: Date, k: Rate): Real;
  floorPrice2(d: Date, k: Rate): Real;
  atmYoYSwapRate2(d: Date, extrapolate?: boolean): Rate;
  atmYoYRate2(d: Date, obsLag?: Period, extrapolate?: boolean): Rate;
  strikes(): Rate[];
  capStrikes(): Rate[];
  floorStrikes(): Rate[];
  maturities(): Period[];
  minStrike(): Rate;
  maxStrike(): Rate;
  minMaturity(): Date;
  maxMaturity(): Date;
  checkStrike(K: Rate): boolean;
  checkMaturity(d: Date): boolean;
  yoyOptionDateFromTenor(p: Period): Date;
  protected _fixingDays: Natural;
  protected _bdc: BusinessDayConvention;
  protected _yoyIndex: YoYInflationIndex;
  protected _cStrikes: Rate[];
  protected _fStrikes: Rate[];
  protected _cfMaturities: Period[];
  protected _cfMaturityTimes: Real[];
  protected _cPrice: Matrix;
  protected _fPrice: Matrix;
  protected _cfStrikes: Rate[];
  protected _yoy: YoYInflationTermStructure;
  protected _atmYoYSwapTimeRates: [Time[], Rate[]];
  protected _atmYoYSwapDateRates: [Date[], Rate[]];
}
export declare class InterpolatedYoYCapFloorTermPriceSurface extends
    YoYCapFloorTermPriceSurface {
  constructor(interpolator2d: Interpolator2D, interpolator1d: Interpolator);
  iyoycftpsInit(
      fixingDays: Natural, yyLag: Period, yii: YoYInflationIndex,
      baseRate: Rate, nominal: Handle<YieldTermStructure>, dc: DayCounter,
      cal: Calendar, bdc: BusinessDayConvention, cStrikes: Rate[],
      fStrikes: Rate[], cfMaturities: Period[], cPrice: Matrix, fPrice: Matrix,
      interpolator2d?: Interpolator2D,
      interpolator1d?: Interpolator): InterpolatedYoYCapFloorTermPriceSurface;
  maxDate(): Date;
  baseDate(): Date;
  fixingDays(): Natural;
  atmYoYSwapTimeRates(): [Time[], Rate[]];
  atmYoYSwapDateRates(): [Date[], Rate[]];
  YoYTS(): YoYInflationTermStructure;
  price2(d: Date, k: Rate): Real;
  capPrice2(d: Date, k: Rate): Real;
  floorPrice2(d: Date, k: Rate): Real;
  atmYoYSwapRate2(d: Date, extrapolate?: boolean): Rate;
  atmYoYRate2(d: Date, obsLag?: Period, extrapolate?: boolean): Rate;
  update(): void;
  performCalculations(): void;
  protected intersect(): void;
  protected calculateYoYTermStructure(): void;
  protected _cStrikesB: Rate[];
  protected _fStrikesB: Rate[];
  protected _cPriceB: Matrix;
  protected _fPriceB: Matrix;
  protected _capPrice: Interpolation2D;
  protected _floorPrice: Interpolation2D;
  protected _floorPrice2: Interpolation2D;
  protected _interpolator2d: Interpolator2D;
  protected _atmYoYSwapRateCurve: Interpolation;
  protected _interpolator1d: Interpolator;
}

export declare class InterpolatedYoYOptionletVolatilityCurve extends
    YoYOptionletVolatilitySurfaceInterpolatedCurve implements VolatilityCurve {
  constructor(interpolator?: Interpolator);
  curveInit1(
      settlementDays: Natural, cal: Calendar, bdc: BusinessDayConvention,
      dc: DayCounter, lag: Period, frequency: Frequency,
      indexIsInterpolated: boolean, d: Date[], v: Volatility[], minStrike: Rate,
      maxStrike: Rate, i?: Interpolator): VolatilityCurve;
  curveInit2(
      settlementDays: Natural, cal: Calendar, bdc: BusinessDayConvention,
      dc: DayCounter, lag: Period, frequency: Frequency,
      indexIsInterpolated: boolean, minStrike: Rate, maxStrike: Rate,
      baseYoYVolatility: Volatility, i?: Interpolator): VolatilityCurve;
  minStrike(): Real;
  maxStrike(): Real;
  maxDate(): Date;
  times(): Time[];
  dates(): Date[];
  data(): Real[];
  nodes(): Array<[Date, Real]>;
  volatilityImpl(t: Time, r: Rate): Volatility;
  _dates: Date[];
  _nodes: Array<[Date, Real]>;
  _minStrike: Rate;
  _maxStrike: Rate;
}

export declare class YoYOptionletHelper extends BootstrapHelper {
  constructor(
      price: Handle<Quote>, notional: Real,
      capFloorType: YoYInflationCapFloor.Type, lag: Period,
      yoyDayCounter: DayCounter, paymentCalendar: Calendar, fixingDays: Natural,
      index: YoYInflationIndex, strike: Rate, n: Size,
      pricer: YoYInflationCapFloorEngine);
  setTermStructure(v: YoYOptionletVolatilitySurface): void;
  impliedQuote(): Real;
  protected _notional: Real;
  protected _capFloorType: YoYInflationCapFloor.Type;
  protected _lag: Period;
  protected _fixingDays: Natural;
  protected _index: YoYInflationIndex;
  protected _strike: Rate;
  protected _n: Size;
  protected _yoyDayCounter: DayCounter;
  protected _calendar: Calendar;
  protected _pricer: YoYInflationCapFloorEngine;
  protected _yoyCapFloor: YoYInflationCapFloor;
}

export declare class YoYOptionletStripper {
  initialize(
      s: YoYCapFloorTermPriceSurface, p: YoYInflationCapFloorEngine,
      slope: Real): void;
  minStrike(): Rate;
  maxStrike(): Rate;
  strikes(): Rate[];
  slice(d: Date): [Rate[], Volatility[]];
  protected _YoYCapFloorTermPriceSurface: YoYCapFloorTermPriceSurface;
  protected _p: YoYInflationCapFloorEngine;
  protected _lag: Period;
  protected _frequency: Frequency;
  protected _indexIsInterpolated: boolean;
}

export declare class ExtendedBinomialTree<T extends TreeImpl> extends Tree<T> {
  ebtInit(process: StochasticProcess1D, end: Time, steps: Size):
      ExtendedBinomialTree<T>;
  size(i: Size): Size;
  descendant(x: Size, index: Size, branch: Size): Size;
  protected driftStep(driftTime: Time): Real;
  protected _x0: Real;
  protected _driftPerStep: Real;
  protected _dt: Time;
  protected _treeProcess: StochasticProcess1D;
}
export declare class ExtendedEqualProbabilitiesBinomialTree<T extends TreeImpl>
    extends ExtendedBinomialTree<T> {
  underlying(i: Size, index: Size): Real;
  probability(i: Size, index: Size, branch: Size): Real;
  protected upStep(stepTime: Time): Real;
  protected _up: Real;
}
export declare class ExtendedEqualJumpsBinomialTree<T extends TreeImpl> extends
    ExtendedBinomialTree<T> {
  underlying(i: Size, index: Size): Real;
  probability(i: Size, index: Size, branch: Size): Real;
  protected probUp(stepTime: Time): Real;
  protected dxStep(stepTime: Time): Real;
  protected _dx: Real;
  protected _pu: Real;
  protected _pd: Real;
}
export declare class ExtendedJarrowRudd extends
    ExtendedEqualProbabilitiesBinomialTree<ExtendedJarrowRudd> {
  treeInit(process: StochasticProcess1D, end: Time, steps: Size, strike: Real):
      ExtendedJarrowRudd;
  upStep(stepTime: Time): Real;
}
export declare class ExtendedCoxRossRubinstein extends
    ExtendedEqualJumpsBinomialTree<ExtendedCoxRossRubinstein> {
  treeInit(process: StochasticProcess1D, end: Time, steps: Size, strike: Real):
      ExtendedCoxRossRubinstein;
  dxStep(stepTime: Time): Real;
  probUp(stepTime: Time): Real;
}
export declare class ExtendedAdditiveEQPBinomialTree extends
    ExtendedEqualProbabilitiesBinomialTree<ExtendedAdditiveEQPBinomialTree> {
  treeInit(process: StochasticProcess1D, end: Time, steps: Size, strike: Real):
      ExtendedAdditiveEQPBinomialTree;
  upStep(stepTime: Time): Real;
}
export declare class ExtendedTrigeorgis extends
    ExtendedEqualJumpsBinomialTree<ExtendedTrigeorgis> {
  treeInit(process: StochasticProcess1D, end: Time, steps: Size, strike: Real):
      ExtendedTrigeorgis;
  dxStep(stepTime: Time): Real;
  probUp(stepTime: Time): Real;
}
export declare class ExtendedTian extends ExtendedBinomialTree<ExtendedTian> {
  treeInit(process: StochasticProcess1D, end: Time, steps: Size, strike: Real):
      ExtendedTian;
  underlying(i: Size, index: Size): Real;
  probability(i: Size, index: Size, branch: Size): Real;
  protected _up: Real;
  protected _down: Real;
  protected _pu: Real;
  protected _pd: Real;
}
export declare class ExtendedLeisenReimer extends
    ExtendedBinomialTree<ExtendedLeisenReimer> {
  treeInit(process: StochasticProcess1D, end: Time, steps: Size, strike: Real):
      ExtendedLeisenReimer;
  underlying(i: Size, index: Size): Real;
  probability(i: Size, index: Size, branch: Size): Real;
  protected _end: Time;
  protected _oddSteps: Size;
  protected _strike: Real;
  protected _up: Real;
  protected _down: Real;
  protected _pu: Real;
  protected _pd: Real;
}
export declare class ExtendedJoshi4 extends
    ExtendedBinomialTree<ExtendedJoshi4> {
  treeInit(process: StochasticProcess1D, end: Time, steps: Size, strike: Real):
      ExtendedJoshi4;
  computeUpProb(k: Real, dj: Real): Real;
  underlying(i: Size, index: Size): Real;
  probability(i: Size, index: Size, branch: Size): Real;
  protected _end: Time;
  protected _oddSteps: Size;
  protected _strike: Real;
  protected _up: Real;
  protected _down: Real;
  protected _pu: Real;
  protected _pd: Real;
}

export declare class ClaytonCopulaRng {
  constructor(uniformGenerator: RNG<Real>, theta: Real);
  next(): Sample<Real[]>;
  private _theta;
  private _uniformGenerator;
}

export declare class CumulativeBehrensFisher implements
    UnaryFunction<Real, Probability> {
  constructor(degreesFreedom?: Integer[], factors?: Real[]);
  degreeFreedom(): Integer[];
  factors(): Real[];
  f(x: Real): Probability;
  density(x: Real): Probability;
  private polynCharactT;
  private convolveVectorPolynomials;
  private _degreesFreedom;
  private _factors;
  private _polynCharFnc;
  private _polyConvolved;
  private _a;
  private _a2;
}
export declare class InverseCumulativeBehrensFisher implements
    UnaryFunction<Probability, Real> {
  constructor(degreesFreedom?: Integer[], factors?: Real[], accuracy?: Real);
  f(q: Probability): Real;
  private _normSqr;
  private _accuracy;
  private _distrib;
}

export declare function Expm(M: Matrix, t?: Real, tol?: Real): Matrix;

export declare class FarlieGumbelMorgensternCopulaRng {
  constructor(uniformGenerator: RNG<Real>, theta: Real);
  next(): Sample<Real[]>;
  private _theta;
  private _uniformGenerator;
}

declare class variate_generator {
  constructor(e: any, d: any);
  f(): any;
  f1(value: any): any;
  engine(): any;
  distribution(): any;
  private eng;
  private dist;
}

export declare class FireflyAlgorithm extends OptimizationMethod {
  constructor(
      M: Size, intensity: FireflyAlgorithm.Intensity,
      randomWalk: FireflyAlgorithm.RandomWalk, Mde?: Size,
      mutationFactor?: Real, crossoverFactor?: Real, seed?: Size);
  startState(P: Problem, endCriteria: EndCriteria): void;
  minimize(P: Problem, endCriteria: EndCriteria): EndCriteria.Type;
  _x: Real[][];
  _xI: Real[][];
  _xRW: Real[][];
  _values: Array<[Real, Size]>;
  _lX: Real[];
  _uX: Real[];
  _mutation: Real;
  _crossover: Real;
  _M: Size;
  _N: Size;
  _Mde: Size;
  _Mfa: Size;
  protected _intensity: FireflyAlgorithm.Intensity;
  protected _randomWalk: FireflyAlgorithm.RandomWalk;
  protected _drawIndex: variate_generator;
  protected _rng: MersenneTwisterUniformRng;
}
export declare namespace FireflyAlgorithm {
  class Intensity {
    init(fa: FireflyAlgorithm): void;
    findBrightest(): void;
    protected intensityImpl(valueX: Real, valueY: Real, distance: Real): Real;
    protected distance(x: Real[], y: Real[]): Real;
    protected _Mfa: Size;
    protected _N: Size;
    protected _x: Real[][];
    protected _values: Array<[Real, Size]>;
    protected _xI: Real[][];
  }
  class RandomWalk {
    init(fa: FireflyAlgorithm): void;
    walk(): void;
    protected walkImpl(xRW: Real[]): void;
    protected _Mfa: Size;
    protected _N: Size;
    protected _x: Real[][];
    protected _values: Array<[Real, Size]>;
    protected _xRW: Real[][];
    protected _lX: Real[];
    protected _uX: Real[];
  }
}
export declare class ExponentialIntensity extends FireflyAlgorithm.Intensity {
  constructor(beta0: Real, betaMin: Real, gamma: Real);
  protected intensityImpl(valueX: Real, valueY: Real, d: Real): Real;
  protected _beta0: Real;
  protected _betaMin: Real;
  protected _gamma: Real;
}
export declare class InverseLawSquareIntensity extends
    FireflyAlgorithm.Intensity {
  constructor(beta0: Real, betaMin: Real);
  protected intensityImpl(valueX: Real, valueY: Real, d: Real): Real;
  protected _beta0: Real;
  protected _betaMin: Real;
}
export declare class DistributionRandomWalk extends
    FireflyAlgorithm.RandomWalk {
  constructor(dist: any, delta?: Real, seed?: Size);
  init(fa: FireflyAlgorithm): void;
  protected walkImpl(xRW: Real[]): void;
  protected _walkRandom: IsotropicRandomWalk;
  protected _delta: Real;
}
export declare class GaussianWalk extends DistributionRandomWalk {
  constructor(sigma: Real, delta?: Real, seed?: Size);
}
export declare class LevyFlightWalk extends DistributionRandomWalk {
  constructor(alpha: Real, xm?: Real, delta?: Real, seed?: Size);
}
export declare class DecreasingGaussianWalk extends GaussianWalk {
  constructor(sigma: Real, delta?: Real, seed?: Size);
  init(fa: FireflyAlgorithm): void;
  protected walkImpl(xRW: Real[]): void;
  private _delta0;
  private _iteration;
}

export declare class FrankCopulaRng {
  constructor(uniformGenerator: RNG<Real>, theta: Real);
  next(): Sample<Real[]>;
  private _theta;
  private _uniformGenerator;
}

export declare class GaussianCopulaPolicy {
  constructor(factorWeights?: Real[][], dummy?: Integer);
  numFactors(): Size;
  getInitTraits(): Integer;
  cumulativeY(val: Real, iVariable: Size): Probability;
  cumulativeZ(z: Real): Probability;
  density(m: Real[]): Probability;
  inverseCumulativeY(p: Probability, iVariable: Size): Real;
  inverseCumulativeZ(p: Probability): Real;
  inverseCumulativeDensity(p: Probability, iFactor: Size): Real;
  allFactorCumulInverter(probs: Real[]): Real[];
  private _numFactors;
  static _density: NormalDistribution;
  static _cumulative: CumulativeNormalDistribution;
}

export declare class GaussNonCentralChiSquaredPolynomial extends
    GaussianOrthogonalPolynomial {
  constructor(nu: Real, lambda: Real);
  mu_0(): Real;
  alpha(u: Size): Real;
  beta(u: Size): Real;
  w(x: Real): Real;
  private _alpha;
  private _beta;
  private z;
  private _nu;
  private _lambda;
  private _b;
  private _c;
  private _z;
}

export declare class HybridSimulatedAnnealing extends OptimizationMethod {
  constructor(
      Sampler: any, Probability: any, Temperature: any, Reannealing?: any,
      startTemperature?: Real, endTemperature?: Real, reAnnealSteps?: Size,
      resetScheme?: HybridSimulatedAnnealing.ResetScheme, resetSteps?: Size,
      localOptimizer?: OptimizationMethod,
      optimizeScheme?: HybridSimulatedAnnealing.LocalOptimizeScheme);
}
export declare namespace HybridSimulatedAnnealing {
  enum LocalOptimizeScheme {
    NoLocalOptimize = 0,
    EveryNewPoint = 1,
    EveryBestPoint = 2
  }
  enum ResetScheme {
    NoResetScheme = 0,
    ResetToBestPoint = 1,
    ResetToOrigin = 2
  }
}
export declare class GaussianSimulatedAnnealing extends
    HybridSimulatedAnnealing {
  constructor(
      Sampler: any, Probability: any, Temperature: any, Reannealing?: any,
      startTemperature?: Real, endTemperature?: Real, reAnnealSteps?: Size,
      resetScheme?: HybridSimulatedAnnealing.ResetScheme, resetSteps?: Size,
      localOptimizer?: OptimizationMethod,
      optimizeScheme?: HybridSimulatedAnnealing.LocalOptimizeScheme);
}
export declare class LogNormalSimulatedAnnealing extends
    HybridSimulatedAnnealing {
  constructor(
      Sampler: any, Probability: any, Temperature: any, Reannealing?: any,
      startTemperature?: Real, endTemperature?: Real, reAnnealSteps?: Size,
      resetScheme?: HybridSimulatedAnnealing.ResetScheme, resetSteps?: Size,
      localOptimizer?: OptimizationMethod,
      optimizeScheme?: HybridSimulatedAnnealing.LocalOptimizeScheme);
}
export declare class MirrorGaussianSimulatedAnnealing extends
    HybridSimulatedAnnealing {
  constructor(
      Sampler: any, Probability: any, Temperature: any, Reannealing?: any,
      startTemperature?: Real, endTemperature?: Real, reAnnealSteps?: Size,
      resetScheme?: HybridSimulatedAnnealing.ResetScheme, resetSteps?: Size,
      localOptimizer?: OptimizationMethod,
      optimizeScheme?: HybridSimulatedAnnealing.LocalOptimizeScheme);
}
export declare class GaussianSimulatedReAnnealing extends
    HybridSimulatedAnnealing {
  constructor(
      Sampler: any, Probability: any, Temperature: any, Reannealing?: any,
      startTemperature?: Real, endTemperature?: Real, reAnnealSteps?: Size,
      resetScheme?: HybridSimulatedAnnealing.ResetScheme, resetSteps?: Size,
      localOptimizer?: OptimizationMethod,
      optimizeScheme?: HybridSimulatedAnnealing.LocalOptimizeScheme);
}
export declare class VeryFastSimulatedAnnealing extends
    HybridSimulatedAnnealing {
  constructor(
      Sampler: any, Probability: any, Temperature: any, Reannealing?: any,
      startTemperature?: Real, endTemperature?: Real, reAnnealSteps?: Size,
      resetScheme?: HybridSimulatedAnnealing.ResetScheme, resetSteps?: Size,
      localOptimizer?: OptimizationMethod,
      optimizeScheme?: HybridSimulatedAnnealing.LocalOptimizeScheme);
}
export declare class VeryFastSimulatedReAnnealing extends
    HybridSimulatedAnnealing {
  constructor(
      Sampler: any, Probability: any, Temperature: any, Reannealing?: any,
      startTemperature?: Real, endTemperature?: Real, reAnnealSteps?: Size,
      resetScheme?: HybridSimulatedAnnealing.ResetScheme, resetSteps?: Size,
      localOptimizer?: OptimizationMethod,
      optimizeScheme?: HybridSimulatedAnnealing.LocalOptimizeScheme);
}

export declare class SamplerLogNormal {}
export declare class SamplerGaussian {
  constructor(seed?: Size);
}
export declare class SamplerRingGaussian {}
export declare class SamplerMirrorGaussian {}
export declare class SamplerCauchy {}
export declare class SamplerVeryFastAnnealing {}
export declare class ProbabilityAlwaysDownhill {}
export declare class ProbabilityBoltzmann {}
export declare class ProbabilityBoltzmannDownhill {
  constructor(seed?: Size);
}
export declare class TemperatureBoltzmann {}
export declare class TemperatureCauchy {}
export declare class TemperatureCauchy1D {}
export declare class TemperatureExponential {
  init(initialTemp: Real, dimension: Size, power?: Real):
      TemperatureExponential;
}
export declare class TemperatureVeryFastAnnealing {}
export declare class ReannealingTrivial {}
export declare class ReannealingFiniteDifferences {}

export declare class IsotropicRandomWalk {
  constructor(eng: any, dist: any, dim: Size, weights?: Real[], seed?: Size);
  nextReal(input: Real[], first?: Size): void;
  setDimension1(dim: Size): void;
  setDimension2(dim: Size, weights: Real[]): void;
  setDimension3(dim: Size, lowerBound: Real[], upperBound: Real[]): void;
  protected _variate: variate_generator;
  protected _rng: MersenneTwisterUniformRng;
  protected _weights: Real[];
  protected _dim: Size;
}

export declare function laplaceInterpolation(A: Matrix, relTol?: Real): void;

export declare class LMIntegration {
  integrate(f: UnaryFunction<Real[], Real>): Real;
  integrateV(f: UnaryFunction<Real[], Real[]>): Real[];
}
export declare class IntegrationBase extends LMIntegration {
  ibInit1(dimension: Size, quadOrder: Size, mu?: Real): IntegrationBase;
  ibInit2(integrators: Integrator[], a: Real, b: Real): IntegrationBase;
  integrate(f: UnaryFunction<Real[], Real>): Real;
  integrateV(f: UnaryFunction<Real[], Real[]>): Real[];
  I: any;
  _a: Real[];
  _b: Real[];
}
export declare enum LatentModelIntegrationType {
  GaussianQuadrature = 0,
  Trapezoid = 1
}
export declare class LatentModel extends ObserverObservable {
  init(copulaPolicyImpl: any): LatentModel;
  lmInit1(factorWeights: Real[][], ini?: any): LatentModel;
  lmInit2(factorWeights: Real[], ini?: any): LatentModel;
  lmInit3(correlSqr: Real, nVariables: Size, ini?: any): LatentModel;
  lmInit4(singleFactorCorrel: Handle<Quote>, nVariables: Size, ini?: any):
      LatentModel;
  size(): Size;
  numFactors(): Size;
  numTotalFactors(): Size;
  factorWeights(): Real[][];
  idiosyncFctrs(): Real[];
  latentVariableCorrel(iVar1: Size, iVar2: Size): Real;
  integration(): LMIntegration;
  integratedExpectedValue1(f: UnaryFunction<Real[], Real>): Real;
  integratedExpectedValue2(f: UnaryFunction<Real[], Real[]>): Real[];
  cumulativeY(val: Real, iVariable: Size): Probability;
  cumulativeZ(z: Real): Probability;
  density(m: Real[]): Probability;
  inverseCumulativeDensity(p: Probability, iFactor: Size): Real;
  inverseCumulativeY(p: Probability, iVariable: Size): Real;
  inverseCumulativeZ(p: Probability): Real;
  allFactorCumulInverter(probs: Real[]): Real[];
  latentVarValue(allFactors: Real[], iVar: Size): Real;
  copula(): any;
  update(): void;
  copulaPolicy: any;
  _factorWeights: Real[][];
  _cachedMktFactor: Handle<Quote>;
  _idiosyncFctrs: Real[];
  _nFactors: Size;
  _nVariables: Size;
  _copula: any;
}
export declare namespace LatentModel {
  class IntegrationFactory {
    static createLMIntegration(
        dimension: Size, type?: LatentModelIntegrationType): LMIntegration;
  }
  class FactorSampler {
    constructor(USNG: USG<Real[]>);
    init(copula: any, seed?: BigNatural): FactorSampler;
    nextSequence(): Sample<Real[]>;
    USNG: USG<Real[]>;
    private _sequenceGen;
    private _x;
    private _copula;
  }
}

export declare class LevyFlightDistribution {}

export declare function moorePenroseInverse(A: Matrix, tol?: Real): Matrix;

export declare class MultidimIntegral implements
    TernaryFunction<UnaryFunction<Real[], Real>, Real[], Real[], Real> {
  constructor(integrators: Integrator[]);
  f(f: UnaryFunction<Real[], Real>, a: Real[], b: Real[]): Real;
  private spawnFcts;
  private vectorBinder;
  private integrate;
  private _integrators;
  private _integrationLevelEntries;
  private _varBuffer;
}

export declare class GaussianQuadMultidimIntegrator {
  constructor(dimension: Size, quadOrder: Size, mu?: Real);
  order(): Size;
  f2(uf: UnaryFunction<Real[], Real[]>): Real[];
  f1(uf: UnaryFunction<Real[], Real>): Real;
  integrate1(uf: UnaryFunction<Real[], Real>): Real;
  integrate2(uf: UnaryFunction<Real[], Real[]>): Real[];
  spawnFcts(levelSpawn: Size): void;
  scalarIntegrator(
      intgDepth: Integer, f: UnaryFunction<Real[], Real>, mFctr: Real): Real;
  vectorIntegratorVR(
      intgDepth: Integer, f: UnaryFunction<Real[], Real[]>,
      mFctr: Real): Real[];
  private _integral;
  private _integralV;
  private _integrationEntries;
  private _integrationEntriesVR;
  private _dimension;
  private _varBuffer;
}
export declare namespace GaussianQuadMultidimIntegrator {
  class VectorIntegrator extends GaussHermiteIntegration {
    constructor(n: Size, mu?: Real);
    f2(f: UnaryFunction<Real, Real[]>): Real[];
  }
}

export declare class ParticleSwarmOptimization extends OptimizationMethod {
  init1(
      M: Size, topology: ParticleSwarmOptimization.Topology,
      inertia: ParticleSwarmOptimization.Inertia, c1?: Real, c2?: Real,
      seed?: Size): ParticleSwarmOptimization;
  init2(
      M: Size, topology: ParticleSwarmOptimization.Topology,
      inertia: ParticleSwarmOptimization.Inertia, omega: Real, c1: Real,
      c2: Real, seed?: Size): ParticleSwarmOptimization;
}
export declare namespace ParticleSwarmOptimization {
  class Inertia {}
  class Topology {}
}
export declare class TrivialInertia extends ParticleSwarmOptimization.Inertia {}
export declare class SimpleRandomInertia extends
    ParticleSwarmOptimization.Inertia {}
export declare class DecreasingInertia extends
    ParticleSwarmOptimization.Inertia {}
export declare class AdaptiveInertia extends ParticleSwarmOptimization.Inertia {
}
export declare class LevyFlightInertia extends
    ParticleSwarmOptimization.Inertia {
  constructor(alpha: Real, threshhold: Size, seed?: Size);
}
export declare class GlobalTopology extends ParticleSwarmOptimization.Topology {
}
export declare class KNeighbors extends ParticleSwarmOptimization.Topology {
  constructor(K?: Size);
}
export declare class ClubsTopology extends ParticleSwarmOptimization.Topology {}

export declare function QL_PIECEWISE_FUNCTION(
    X: Real[], Y: Real[], x: Real): Real;

export declare class PiecewiseIntegral extends Integrator {
  constructor(
      integrator: Integrator, criticalPoints: Real[],
      avoidCriticalPoints?: boolean);
  protected integrate(f: UnaryFunction<Real, Real>, a: Real, b: Real): Real;
  private integrate_h;
  private _integrator;
  private _criticalPoints;
  private _eps;
}

export declare class PolarStudentTRng {
  constructor(URNG: RNG<Real>);
  pstInit1(degFreedom: Real, seed?: BigNatural): PolarStudentTRng;
  pstInit1(degFreedom: Real, urng: RNG<Real>): PolarStudentTRng;
  next(): Sample<Real>;
  private _uniformGenerator;
  private _degFreedom;
}

export declare class TCopulaPolicy {
  init(factorWeights?: Real[][], vals?: any): TCopulaPolicy;
  numFactors(): Size;
  getInitTraits(): any;
  varianceFactors(): Real[];
  cumulativeY(val: Real, iVariable: Size): Probability;
  cumulativeZ(z: Real): Probability;
  density(m: Real[]): Probability;
  inverseCumulativeY(p: Probability, iVariable: Size): Real;
  inverseCumulativeZ(p: Probability): Real;
  inverseCumulativeDensity(p: Probability, iFactor: Size): Real;
  allFactorCumulInverter(probs: Real[]): Real[];
  private _distributions;
  private _varianceFactors;
  private _latentVarsCumul;
  private _latentVarsInverters;
}
export declare namespace TCopulaPolicy {
  class initTraits {
    tOrders: Integer[];
  }
}

export declare class ZigguratRng {
  constructor(seed?: Size);
  next(): Sample<Real>;
  private nextGaussian;
  private _mt32;
}
export declare class Ziggurat {
  static make_sequence_generator(dimension: Size, seed: BigNatural):
      RandomSequenceGenerator;
}
export declare namespace Ziggurat {
  type rng_type = ZigguratRng;
  type rsg_type = RandomSequenceGenerator;
  const allowsErrorEstimate = 1;
}

export declare class AdaptedPathPayoff extends PathPayoff {}

export declare class LongstaffSchwartzMultiPathPricer extends PathPricer {}

export declare class MCAmericanPathEngine extends
    MCLongstaffSchwartzPathEngine {}

export declare class MCLongstaffSchwartzPathEngine {}

export declare class MCPathBasketEngine {}

export declare class PathMultiAssetOption extends Instrument {}

export declare class PathPayoff {}

export declare class HestonSLVFokkerPlanckFdmParams {
  constructor(
      xGrid: Size, vGrid: Size, tMaxStepsPerYear: Size, tMinStepsPerYear: Size,
      tStepNumberDecay: Real, nRannacherTimeSteps: Size,
      predictionCorretionSteps: Size, x0Density: Real, localVolEpsProb: Real,
      maxIntegrationIterations: Size, vLowerEps: Real, vUpperEps: Real,
      vMin: Real, v0Density: Real, vLowerBoundDensity: Real,
      vUpperBoundDensity: Real, leverageFctPropEps: Real,
      greensAlgorithm: FdmHestonGreensFct.Algorithm,
      trafoType: FdmSquareRootFwdOp.TransformationType,
      schemeDesc: FdmSchemeDesc);
  xGrid: Size;
  vGrid: Size;
  tMaxStepsPerYear: Size;
  tMinStepsPerYear: Size;
  tStepNumberDecay: Real;
  nRannacherTimeSteps: Size;
  predictionCorretionSteps: Size;
  x0Density: Real;
  localVolEpsProb: Real;
  maxIntegrationIterations: Size;
  vLowerEps: Real;
  vUpperEps: Real;
  vMin: Real;
  v0Density: Real;
  vLowerBoundDensity: Real;
  vUpperBoundDensity: Real;
  leverageFctPropEps: Real;
  greensAlgorithm: FdmHestonGreensFct.Algorithm;
  trafoType: FdmSquareRootFwdOp.TransformationType;
  schemeDesc: FdmSchemeDesc;
}
export declare class HestonSLVFDMModel extends LazyObject {
  constructor(
      localVol: Handle<LocalVolTermStructure>, hestonModel: Handle<HestonModel>,
      endDate: Date, params: HestonSLVFokkerPlanckFdmParams, logging?: boolean,
      mandatoryDates?: Date[]);
  hestonProcess(): HestonProcess;
  localVol(): LocalVolTermStructure;
  leverageFunction(): LocalVolTermStructure;
  logEntries(): HestonSLVFDMModel.LogEntry[];
  performCalculations(): void;
  protected _localVol: Handle<LocalVolTermStructure>;
  protected _hestonModel: Handle<HestonModel>;
  protected _endDate: Date;
  protected _params: HestonSLVFokkerPlanckFdmParams;
  protected _mandatoryDates: Date[];
  protected _leverageFunction: LocalVolTermStructure;
  protected _logging: boolean;
  protected _logEntries: HestonSLVFDMModel.LogEntry[];
}
export declare namespace HestonSLVFDMModel {
  class LogEntry {
    constructor(t: Time, prob: Real[], mesher: FdmMesherComposite);
    t: Time;
    prob: Real[];
    mesher: FdmMesherComposite;
  }
}

export declare class HestonSLVMCModel extends LazyObject {
  constructor(
      localVol: Handle<LocalVolTermStructure>, hestonModel: Handle<HestonModel>,
      brownianGeneratorFactory: BrownianGeneratorFactory, endDate: Date,
      timeStepsPerYear?: Size, nBins?: Size, calibrationPaths?: Size,
      mandatoryDates?: Date[]);
  hestonProcess(): HestonProcess;
  localVol(): LocalVolTermStructure;
  leverageFunction(): LocalVolTermStructure;
  performCalculations(): void;
  private _localVol;
  private _hestonModel;
  private _brownianGeneratorFactory;
  private _nBins;
  private _calibrationPaths;
  private _timeGrid;
  private _leverageFunction;
}

export declare class NormalCLVModel extends LazyObject {
  constructor(
      bsProcess: GeneralizedBlackScholesProcess,
      ouProcess: OrnsteinUhlenbeckProcess, maturityDates: Date[],
      lagrangeOrder: Size, pMax?: Real, pMin?: Real);
  cdf(d: Date, k: Real): Real;
  invCDF(d: Date, q: Real): Real;
  collocationPointsX(d: Date): Real[];
  collocationPointsY(d: Date): Real[];
  g(): BinaryFunction<Time, Real, Real>;
  performCalculations(): void;
  _x: Real[];
  _sigma: Volatility;
  _bsProcess: GeneralizedBlackScholesProcess;
  _ouProcess: OrnsteinUhlenbeckProcess;
  _maturityDates: Date[];
  _rndCalculator: GBSMRNDCalculator;
  _maturityTimes: Time[];
  _g: BinaryFunction<Time, Real, Real>;
}
export declare namespace NormalCLVModel {
  class MappingFunction implements BinaryFunction<Time, Real, Real> {
    constructor(model: NormalCLVModel);
    f(t: Time, x: Real): Real;
    private _y;
    private _sigma;
    private _ouProcess;
    private _data;
  }
  namespace MappingFunction {
    class InterpolationData {
      constructor(model: NormalCLVModel);
      _s: Matrix;
      _interpl: LinearInterpolation[];
      _x: Real[];
      _t: Time[];
      _lagrangeInterpl: LagrangeInterpolation;
    }
  }
}

export declare class SquareRootCLVModel extends LazyObject {
  constructor(
      bsProcess: GeneralizedBlackScholesProcess, sqrtProcess: SquareRootProcess,
      maturityDates: Date[], lagrangeOrder: Size, pMax?: Real, pMin?: Real);
  cdf(d: Date, k: Real): Real;
  invCDF(d: Date, q: Real): Real;
  collocationPointsX(d: Date): Real[];
  collocationPointsY(d: Date): Real[];
  g(): BinaryFunction<Time, Real, Real>;
  performCalculations(): void;
  nonCentralChiSquaredParams(d: Date): [Real, Real];
  _pMax: Real;
  _pMin: Real;
  _bsProcess: GeneralizedBlackScholesProcess;
  _sqrtProcess: SquareRootProcess;
  _maturityDates: Date[];
  _lagrangeOrder: Size;
  _rndCalculator: GBSMRNDCalculator;
  _g: BinaryFunction<Time, Real, Real>;
}

export declare class ExtendedBlackScholesMertonProcess extends
    GeneralizedBlackScholesProcess {
  constructor(
      x0: Handle<Quote>, dividendTS: Handle<YieldTermStructure>,
      riskFreeTS: Handle<YieldTermStructure>,
      blackVolTS: Handle<BlackVolTermStructure>,
      d?: StochasticProcess.discretization,
      evolDisc?: ExtendedBlackScholesMertonProcess.Discretization);
  drift2(t: Time, x: Real): Real;
  diffusion2(t: Time, x: Real): Real;
  evolve2(t0: Time, x0: Real, dt: Time, dw: Real): Real;
  private discretization_;
}
export declare namespace ExtendedBlackScholesMertonProcess {
  enum Discretization { Euler = 0, Milstein = 1, PredictorCorrector = 2 }
}

export declare class ExtendedOrnsteinUhlenbeckProcess extends
    StochasticProcess1D {
  constructor(
      speed: Real, vol: Volatility, x0: Real, b: UnaryFunction<Real, Real>,
      discretization?: ExtendedOrnsteinUhlenbeckProcess.Discretization,
      intEps?: Real);
  x0(): Real;
  speed(): Real;
  volatility(): Real;
  drift2(t: Time, x: Real): Real;
  diffusion2(t: Real, x: Real): Real;
  expectation2(t0: Time, x0: Real, dt: Time): Real;
  stdDeviation2(t0: Time, x0: Real, dt: Time): Real;
  variance(t0: Time, x0: Real, dt: Time): Real;
  private _speed;
  private _vol;
  private _b;
  private _intEps;
  private _ouProcess;
  private discretization_;
}
export declare namespace ExtendedOrnsteinUhlenbeckProcess {
  enum Discretization { MidPoint = 0, Trapezodial = 1, GaussLobatto = 2 }
}

export declare class ExtOUWithJumpsProcess extends StochasticProcess {
  constructor(
      process: ExtendedOrnsteinUhlenbeckProcess, Y0: Real, beta: Real,
      jumpIntensity: Real, eta: Real);
  size(): Size;
  factors(): Size;
  initialValues(): Real[];
  drift1(t: Time, x: Real[]): Real[];
  diffusion1(t: Time, x: Real[]): Matrix;
  evolve1(t0: Time, x0: Real[], dt: Time, dw: Real[]): Real[];
  getExtendedOrnsteinUhlenbeckProcess(): ExtendedOrnsteinUhlenbeckProcess;
  beta(): Real;
  eta(): Real;
  jumpIntensity(): Real;
  private _Y0;
  private _beta;
  private _jumpIntensity;
  private _eta;
  private _ouProcess;
  private _cumNormalDist;
}

export declare class GemanRoncoroniProcess extends StochasticProcess1D {
  constructor(
      x0: Real, alpha: Real, beta: Real, gamma: Real, delta: Real, eps: Real,
      zeta: Real, d: Real, k: Real, tau: Real, sig2: Real, a: Real, b: Real,
      theta1: Real, theta2: Real, theta3: Real, psi: Real);
  x0(): Real;
  drift2(t: Time, x: Real): Real;
  diffusion2(t: Time, x: Real): Real;
  stdDeviation2(t0: Time, x0: Real, dt: Time): Real;
  evolve2(t0: Time, x0: Real, dt: Time, dw: Time): Real;
  evolve3(t0: Time, x0: Real, dt: Time, dw: Real, du: Real[]): Real;
  private _x0;
  private _alpha;
  private _beta;
  private _gamma;
  private _delta;
  private _eps;
  private _zeta;
  private _d;
  private _k;
  private _tau;
  private _sig2;
  private _a;
  private _b;
  private _theta1;
  private _theta2;
  private _theta3;
  private _psi;
  private _urng;
}

export declare class HestonSLVProcess extends StochasticProcess {
  constructor(hestonProcess: HestonProcess, leverageFct: LocalVolTermStructure);
  size(): Size;
  factors(): Size;
  update(): void;
  initialValues(): Real[];
  apply1(x0: Real[], dx: Real[]): Real[];
  drift1(t: Time, x: Real[]): Real[];
  diffusion1(t: Time, x: Real[]): Matrix;
  evolve1(t0: Time, x0: Real[], dt: Time, dw: Real[]): Real[];
  v0(): Real;
  rho(): Real;
  kappa(): Real;
  theta(): Real;
  sigma(): Real;
  leverageFct(): LocalVolTermStructure;
  s0(): Handle<Quote>;
  dividendYield(): Handle<YieldTermStructure>;
  riskFreeRate(): Handle<YieldTermStructure>;
  time(d: Date): Time;
  private _kappa;
  private _theta;
  private _sigma;
  private _rho;
  private _v0;
  private _hestonProcess;
  private _leverageFct;
}

export declare class KlugeExtOUProcess extends StochasticProcess {
  constructor(
      rho: Real, klugeProcess: ExtOUWithJumpsProcess,
      ouProcess: ExtendedOrnsteinUhlenbeckProcess);
  size(): Size;
  factors(): Size;
  initialValues(): Real[];
  drift1(t: Time, x: Real[]): Real[];
  diffusion1(t: Time, x: Real[]): Matrix;
  evolve1(t0: Time, x0: Real[], dt: Time, dw: Real[]): Real[];
  getKlugeProcess(): ExtOUWithJumpsProcess;
  getExtOUProcess(): ExtendedOrnsteinUhlenbeckProcess;
  rho(): Real;
  private _rho;
  private _sqrtMRho;
  private _klugeProcess;
  private _ouProcess;
}

export declare class VegaStressedBlackScholesProcess extends
    GeneralizedBlackScholesProcess {
  constructor(
      x0: Handle<Quote>, dividendTS: Handle<YieldTermStructure>,
      riskFreeTS: Handle<YieldTermStructure>,
      blackVolTS: Handle<BlackVolTermStructure>,
      lowerTimeBorderForStressTest?: Time, upperTimeBorderForStressTest?: Time,
      lowerAssetBorderForStressTest?: Time,
      upperAssetBorderForStressTest?: Time, stressLevel?: Real,
      d?: StochasticProcess.discretization);
  diffusion2(t: Time, x: Real): Real;
  getLowerTimeBorderForStressTest(): Real;
  setLowerTimeBorderForStressTest(LTB: Time): void;
  getUpperTimeBorderForStressTest(): Real;
  setUpperTimeBorderForStressTest(UTB: Time): void;
  getLowerAssetBorderForStressTest(): Real;
  setLowerAssetBorderForStressTest(LAB: Time): void;
  getUpperAssetBorderForStressTest(): Real;
  setUpperAssetBorderForStressTest(UBA: Time): void;
  getStressLevel(): Real;
  setStressLevel(SL: Real): void;
  private _lowerTimeBorderForStressTest;
  private _upperTimeBorderForStressTest;
  private _lowerAssetBorderForStressTest;
  private _upperAssetBorderForStressTest;
  private _stressLevel;
}

export declare class CreditRiskPlus {
  constructor(
      exposure: Real[], defaultProbability: Real[], sector: Size[],
      relativeDefaultVariance: Real[], correlation: Matrix, unit: Real);
  loss(): Real[];
  marginalLoss(): Real[];
  exposure(): Real;
  expectedLoss(): Real;
  unexpectedLoss(): Real;
  relativeDefaultVariance(): Real;
  sectorExposures(): Real[];
  sectorExpectedLoss(): Real[];
  sectorUnexpectedLoss(): Real[];
  lossQuantile(p: Real): Real;
  private compute;
  private _exposure;
  private _pd;
  private _sector;
  private _relativeDefaultVariance;
  private _correlation;
  private _unit;
  private _n;
  private _m;
  private _sectorExposure;
  private _sectorEl;
  private _sectorUl;
  private _marginalLoss;
  private _loss;
  private _exposureSum;
  private _el;
  private _el2;
  private _ul;
  private _upperIndex;
}

export declare enum SensitivityAnalysis {OneSide = 0, Centered = 1}

export declare class GeneralizedHullWhite {}

export declare class GeneralizedOrnsteinUhlenbeckProcess extends
    StochasticProcess1D {}

export declare class HaganIrregularSwaptionEngine extends
    GenericEngine<IrregularSwaption.Arguments, IrregularSwaption.Results> {}

export declare class IrregularSwap extends Swap {}

export declare class IrregularSettlement {}
export declare class IrregularSwaption extends Option {}
export declare namespace IrregularSwaption {
  class Arguments extends Option.Arguments {}
  class Results extends Option.Results {}
}

export declare class MultiCurveSensitivities extends LazyObject {}

export declare class VarianceGammaEngine extends VanillaOption.engine {
  constructor(process: VarianceGammaProcess, absoluteError?: Real);
  calculate(): void;
  private _process;
  private _absErr;
}

export declare class FFTEngine extends VanillaOptionEngine.engine {
  constructor(process: StochasticProcess1D, logStrikeSpacing: Real);
  calculate(): void;
  update(): void;
  precalculate(optionList: Instrument[]): void;
  clone(): FFTEngine;
  protected precalculateExpiry(d: Date): void;
  protected complexFourierTransform(u: Complex): Complex;
  protected discountFactor(d: Date): Real;
  protected dividendYield(d: Date): Real;
  protected calculateUncached(payoff: StrikedTypePayoff, exercise: Exercise):
      void;
  protected _process: StochasticProcess1D;
  protected _lambda: Real;
  private _resultMap;
}

export declare class FFTVanillaEngine extends FFTEngine {
  constructor(process: GeneralizedBlackScholesProcess, logStrikeSpacing?: Real);
  clone(): FFTVanillaEngine;
  precalculateExpiry(d: Date): void;
  complexFourierTransform(u: Complex): Complex;
  discountFactor(d: Date): Real;
  dividendYield(d: Date): Real;
  private _dividendDiscount;
  private _riskFreeDiscount;
  private _t;
  private _var;
}

export declare class FFTVarianceGammaEngine extends FFTEngine {
  constructor(process: VarianceGammaProcess, logStrikeSpacing?: Real);
  clone(): FFTEngine;
  protected precalculateExpiry(d: Date): void;
  protected complexFourierTransform(u: Complex): Complex;
  protected discountFactor(d: Date): Real;
  protected dividendYield(d: Date): Real;
  private _dividendDiscount;
  private _riskFreeDiscount;
  private _t;
  private _sigma;
  private _nu;
  private _theta;
}

export declare class VarianceGammaModel extends CalibratedModel {
  constructor(process: VarianceGammaProcess);
  sigma(): Real;
  nu(): Real;
  theta(): Real;
  process(): VarianceGammaProcess;
  generateArguments(): void;
  protected _process: VarianceGammaProcess;
}

export declare class VarianceGammaProcess extends StochasticProcess1D {
  constructor(
      s0: Handle<Quote>, dividendYield: Handle<YieldTermStructure>,
      riskFreeRate: Handle<YieldTermStructure>, sigma: Real, nu: Real,
      theta: Real);
  x0(): Real;
  drift2(t: Time, x: Real): Real;
  diffusion2(t: Time, x: Real): Real;
  sigma(): Real;
  nu(): Real;
  theta(): Real;
  s0(): Handle<Quote>;
  dividendYield(): Handle<YieldTermStructure>;
  riskFreeRate(): Handle<YieldTermStructure>;
  private _s0;
  private _dividendYield;
  private _riskFreeRate;
  private _sigma;
  private _nu;
  private _theta;
}

export declare class IntegralHestonVarianceOptionEngine extends
    VarianceOption.engine {
  constructor(process: HestonProcess);
  calculate(): void;
  private _process;
}

export declare class VarianceOption extends Instrument {
  constructor(
      payoff: Payoff, notional: Real, startDate: Date, maturityDate: Date);
  isExpired(): boolean;
  startDate(): Date;
  maturityDate(): Date;
  notional(): Real;
  payoff(): Payoff;
  setupArguments(args: PricingEngine.Arguments): void;
  protected _payoff: Payoff;
  protected _notional: Real;
  protected _startDate: Date;
  protected _maturityDate: Date;
}
export declare namespace VarianceOption {
  class Arguments extends PricingEngine.Arguments {
    constructor();
    validate(): void;
    payoff: Payoff;
    notional: Real;
    startDate: Date;
    maturityDate: Date;
  }
  class Results extends Instrument.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

declare class BlackAtmVolCurveLazyObject implements Observable, Observer,
                                                    Extrapolator, TermStructure,
                                                    VolatilityTermStructure,
                                                    BlackAtmVolCurve,
                                                    LazyObject {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  enableExtrapolation: (b: boolean) => void;
  disableExtrapolation: (b: boolean) => void;
  allowsExtrapolation: () => boolean;
  tsInit1: (dc: DayCounter) => TermStructure;
  tsInit2:
      (referenceDate: Date, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  tsInit3:
      (settlementDays: Natural, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  dayCounter: () => DayCounter;
  timeFromReference: (date: Date) => Time;
  maxDate(): Date;
  maxTime: () => Time;
  referenceDate: () => Date;
  calendar: () => Calendar;
  settlementDays: () => Natural;
  checkRange1: (d: Date, extrapolate: boolean) => void;
  checkRange2: (t: Time, extrapolate: boolean) => void;
  vtsInit1:
      (bdc: BusinessDayConvention, dc?: DayCounter) => VolatilityTermStructure;
  vtsInit2:
      (referenceDate: Date, cal: Calendar, bdc: BusinessDayConvention,
       dc?: DayCounter) => VolatilityTermStructure;
  vtsInit3:
      (settlementDays: Natural, cal: Calendar, bdc: BusinessDayConvention,
       dc?: DayCounter) => VolatilityTermStructure;
  businessDayConvention: () => BusinessDayConvention;
  optionDateFromTenor: (p: Period) => Date;
  minStrike(): Rate;
  maxStrike(): Rate;
  checkStrike: (k: Rate, extrapolate: boolean) => void;
  bavcInit1: (bdc?: BusinessDayConvention, dc?: DayCounter) => BlackAtmVolCurve;
  bavcInit2:
      (referenceDate: Date, cal?: Calendar, bdc?: BusinessDayConvention,
       dc?: DayCounter) => BlackAtmVolCurve;
  bavcInit3:
      (settlementDays: Natural, cal: Calendar, bdc?: BusinessDayConvention,
       dc?: DayCounter) => BlackAtmVolCurve;
  atmVol1: (optionTenor: Period, extrapolate?: boolean) => Volatility;
  atmVol2: (d: Date, extrapolate?: boolean) => Volatility;
  atmVol3: (t: Time, extrapolate?: boolean) => Volatility;
  atmVariance1: (optionTenor: Period, extrapolate?: boolean) => Real;
  atmVariance2: (d: Date, extrapolate?: boolean) => Real;
  atmVariance3: (t: Time, extrapolate?: boolean) => Real;
  atmVarianceImpl: (t: Time) => Real;
  atmVolImpl: (t: Time) => Volatility;
  accept: (v: AcyclicVisitor) => void;
  recalculate: () => void;
  freeze: () => void;
  unfreeze: () => void;
  alwaysForwardNotifications: () => void;
  calculate: () => void;
  performCalculations(): void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _extrapolate: boolean;
  _moving: boolean;
  _updated: boolean;
  _calendar: Calendar;
  _referenceDate: Date;
  _settlementDays: Natural;
  _dayCounter: DayCounter;
  _bdc: BusinessDayConvention;
  _calculated: boolean;
  _frozen: boolean;
  _alwaysForward: boolean;
}

export declare class AbcdAtmVolCurve extends BlackAtmVolCurveLazyObject {}

export declare class BlackAtmVolCurve extends VolatilityTermStructure {}

export declare class BlackVolSurface extends BlackAtmVolCurve {}

export declare class EquityFXVolSurface extends BlackVolSurface {}

export declare class ExtendedBlackVarianceCurve extends
    BlackVarianceTermStructure {}

export declare class ExtendedBlackVarianceSurface extends
    BlackVarianceTermStructure {}

export declare class InterestRateVolSurface extends BlackVolSurface {}

export declare class NoArbSabrModel {
  constructor(
      expiryTime: Real, forward: Real, alpha: Real, beta: Real, nu: Real,
      rho: Real);
  optionPrice(strike: Real): Real;
  digitalOptionPrice(strike: Real): Real;
  density(strike: Real): Real;
  forward(): Real;
  numericalForward(): Real;
  expiryTime(): Real;
  alpha(): Real;
  beta(): Real;
  nu(): Real;
  rho(): Real;
  absorptionProbability(): Real;
  p(f: Real): Real;
  private forwardError;
  private _expiryTime;
  private _externalForward;
  private _alpha;
  private _beta;
  private _nu;
  private _rho;
  private _absProb;
  private _fmin;
  private _fmax;
  private _forward;
  private _numericalIntegralOverP;
  private _numericalForward;
  private _integrator;
}
export declare namespace NoArbSabrModel {
  const beta_min: Real;
  const beta_max: Real;
  const expiryTime_max: Real;
  const sigmaI_min: Real;
  const sigmaI_max: Real;
  const nu_min: Real;
  const nu_max: Real;
  const rho_min: Real;
  const rho_max: Real;
  const phiByTau_cutoff: Real;
  const nsim: Real;
  const tiny_prob: Real;
  const strike_min: Real;
  const i_accuracy: Real;
  const i_max_iterations: Size;
  const forward_accuracy: Real;
  const forward_search_step: Real;
  const density_lower_bound: Real;
  const density_threshold: Real;
}
export declare class D0Interpolator {
  constructor(
      forward: Real, expiryTime: Time, alpha: Real, beta: Real, nu: Real,
      rho: Real);
  f(): Real;
  private phi;
  private d0;
  private _forward;
  private _expiryTime;
  private _alpha;
  private _beta;
  private _nu;
  private _rho;
  private _gamma;
  private _sigmaI;
  private _tauG;
  private _sigmaIG;
  private _rhoG;
  private _nuG;
  private _betaG;
}

export declare class NoArbSabrInterpolatedSmileSection extends
    SmileSectionLazyObject {}

export declare type NoArbSabrWrapper = NoArbSabrSmileSection;
export declare class NoArbSabrSpecs {
  dimension(): Size;
  eps(): Real;
  defaultValues(
      params: Real[], paramIsFixed: boolean[], forward: Real, expiryTime: Real,
      addParams: Real[]): void;
  guess(
      values: Real[], paramIsFixed: boolean[], forward: Real, expiryTime: Real,
      r: Real[], x: Real[]): void;
  inverse(y: Real[], paramIsFixed: boolean[], params: Real[], forward: Real):
      Real[];
  direct(x: Real[], paramIsFixed: boolean[], params: Real[], forward: Real):
      Real[];
  weight(strike: Real, forward: Real, stdDev: Real, addParams: Real[]): Real;
  instance(t: Time, forward: Real, params: Real[], addParams: Real[]):
      NoArbSabrWrapper;
}
export declare class NoArbSabrInterpolation extends Interpolation {
  constructor(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size, t: Time,
      forward: Real, alpha: Real, beta: Real, nu: Real, rho: Real,
      alphaIsFixed: boolean, betaIsFixed: boolean, nuIsFixed: boolean,
      rhoIsFixed: boolean, vegaWeighted?: boolean, endCriteria?: EndCriteria,
      optMethod?: OptimizationMethod, errorAccept?: Real, useMaxError?: boolean,
      maxGuesses?: Size, shift?: Real);
  expiry(): Real;
  forward(): Real;
  alpha(): Real;
  beta(): Real;
  nu(): Real;
  rho(): Real;
  rmsError(): Real;
  maxError(): Real;
  interpolationWeights(): Real[];
  endCriteria(): EndCriteria.Type;
  private _coeffs;
}
export declare class NoArbSabr {
  constructor(
      t: Time, forward: Real, alpha: Real, beta: Real, nu: Real, rho: Real,
      alphaIsFixed: boolean, betaIsFixed: boolean, nuIsFixed: boolean,
      rhoIsFixed: boolean, vegaWeighted?: boolean, endCriteria?: EndCriteria,
      optMethod?: OptimizationMethod, errorAccept?: Real, useMaxError?: boolean,
      maxGuesses?: Size);
  interpolate(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size):
      Interpolation;
  static global: boolean;
  private _t;
  private _forward;
  private _alpha;
  private _beta;
  private _nu;
  private _rho;
  private _alphaIsFixed;
  private _betaIsFixed;
  private _nuIsFixed;
  private _rhoIsFixed;
  private _vegaWeighted;
  private _endCriteria;
  private _optMethod;
  private _errorAccept;
  private _useMaxError;
  private _maxGuesses;
}

export declare class NoArbSabrSmileSection extends SmileSection {
  nasssInit1(
      timeToExpiry: Time, forward: Rate, sabrParameters: Real[],
      shift?: Real): NoArbSabrSmileSection;
  nasssInit2(
      d: Date, forward: Rate, sabrParameters: Real[], dc?: DayCounter,
      shift?: Real): NoArbSabrSmileSection;
  minStrike(): Real;
  maxStrike(): Real;
  atmLevel(): Real;
  optionPrice(strike: Rate, type?: Option.Type, discount?: Real): Real;
  digitalOptionPrice(
      strike: Rate, type?: Option.Type, discount?: Real, gap?: Real): Real;
  density(strike: Rate, discount?: Real, gap?: Real): Real;
  model(): NoArbSabrModel;
  volatilityImpl(strike: Rate): Volatility;
  private init;
  private _model;
  private _forward;
  private _params;
}

export declare class SabrVolSurface extends InterestRateVolSurface {}

export declare class SABRVolTermStructure extends BlackVolatilityTermStructure {
  constructor(
      alpha: Real, beta: Real, gamma: Real, rho: Real, s0: Real, r: Real,
      referenceDate: Date, dc: DayCounter);
  maxDate(): Date;
  minStrike(): Rate;
  maxStrike(): Rate;
  blackVolImpl(t: Time, strike: Real): Volatility;
  private _alpha;
  private _beta;
  private _gamma;
  private _rho;
  private _s0;
  private _r;
}

export declare class SviInterpolatedSmileSection extends
    SmileSectionLazyObject {}

export declare class SviSpecs {}
export declare class SviInterpolation extends Interpolation {}
export declare class Svi {}

export declare class SviSmileSection extends SmileSection {}

export declare class SwaptionVolCubeNoArbSabrModel {}

export declare class VolatilityCube {
  constructor(
      surfaces: Array<Handle<InterestRateVolSurface>>,
      curves: Array<Handle<AbcdAtmVolCurve>>);
  minIndexTenor(): Period;
  maxIndexTenor(): Period;
  surfaces(): Array<Handle<InterestRateVolSurface>>;
  curves(): Array<Handle<AbcdAtmVolCurve>>;
  protected _surfaces: Array<Handle<InterestRateVolSurface>>;
  protected _curves: Array<Handle<AbcdAtmVolCurve>>;
}

export declare class ZabrModel {
  constructor(
      expiryTime: Real, forward: Real, alpha: Real, beta: Real, nu: Real,
      rho: Real, gamma: Real);
  localVolatility1(f: Real): Real;
  localVolatility2(f: Real[]): Real[];
  fdPrice1(strike: Real): Real;
  fdPrice2(strikes: Real[]): Real[];
  fullFdPrice(strike: Real): Real;
  lognormalVolatility1(strike: Real): Real;
  lognormalVolatility2(strikes: Real[]): Real[];
  normalVolatility1(strike: Real): Real;
  normalVolatility2(strikes: Real[]): Real[];
  forward(): Real;
  expiryTime(): Real;
  alpha(): Real;
  beta(): Real;
  nu(): Real;
  rho(): Real;
  gamma(): Real;
  protected x1(strike: Real): Real;
  private x2;
  private y;
  private F;
  private lognormalVolatilityHelper;
  private normalVolatilityHelper;
  private localVolatilityHelper;
  private _expiryTime;
  private _forward;
  private _alpha;
  private _beta;
  private _nu;
  private _rho;
  private _gamma;
}

export declare class ZabrInterpolatedSmileSection extends
    SmileSectionLazyObject {}

export declare class ZabrInterpolation extends Interpolation {}

export declare class ZabrShortMaturityLognormal {}
export declare class ZabrShortMaturityNormal {}
export declare class ZabrLocalVolatility {}
export declare class ZabrFullFd {}
export declare class ZabrSmileSection extends SmileSection {
  constructor(Evaluation: ZabrShortMaturityLognormal|ZabrShortMaturityNormal|
              ZabrLocalVolatility|ZabrFullFd);
  zssInit1(
      timeToExpiry: Time, forward: Rate, zabrParameters: Real[],
      moneyness?: Real[], fdRefinement?: Size): ZabrSmileSection;
  zssInit2(
      d: Date, forward: Rate, zabrParameters: Real[], dc?: DayCounter,
      moneyness?: Real[], fdRefinement?: Size): ZabrSmileSection;
  Evaluation: ZabrShortMaturityLognormal|ZabrShortMaturityNormal|
      ZabrLocalVolatility|ZabrFullFd;
}

export declare class ContinuousAveragingAsianOption extends OneAssetOption {
  constructor(
      averageType: Average.Type, payoff: StrikedTypePayoff, exercise: Exercise);
  setupArguments(args: PricingEngine.Arguments): void;
  protected _averageType: Average.Type;
}
export declare class DiscreteAveragingAsianOption extends OneAssetOption {
  constructor(
      averageType: Average.Type, runningAccumulator: Real, pastFixings: Size,
      fixingDates: Date[], payoff: StrikedTypePayoff, exercise: Exercise);
  setupArguments(args: PricingEngine.Arguments): void;
  protected _averageType: Average.Type;
  protected _runningAccumulator: Real;
  protected _pastFixings: Size;
  protected _fixingDates: Date[];
}
export declare namespace ContinuousAveragingAsianOption {
  class Arguments extends OneAssetOption.Arguments {
    constructor();
    validate(): void;
    averageType: Average.Type;
  }
  class Results extends OneAssetOption.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}
export declare namespace DiscreteAveragingAsianOption {
  class Arguments extends OneAssetOption.Arguments {
    constructor();
    validate(): void;
    averageType: Average.Type;
    runningAccumulator: Real;
    pastFixings: Size;
    fixingDates: Date[];
  }
  class Results extends OneAssetOption.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class AssetSwap extends Swap {
  asInit1(
      payBondCoupon: boolean, bond: Bond, bondCleanPrice: Real,
      iborIndex: IborIndex, spread: Spread, floatSchedule?: Schedule,
      floatingDayCounter?: DayCounter, parAssetSwap?: boolean): AssetSwap;
  asInit2(
      parAssetSwap: boolean, bond: Bond, bondCleanPrice: Real,
      nonParRepayment: Real, gearing: Real, iborIndex: IborIndex,
      spread?: Spread, floatingDayCounter?: DayCounter, dealMaturity?: Date,
      payBondCoupon?: boolean): AssetSwap;
  fairSpread(): Spread;
  floatingLegBPS(): Real;
  floatingLegNPV(): Real;
  fairCleanPrice(): Real;
  fairNonParRepayment(): Real;
  parSwap(): boolean;
  spread(): Spread;
  cleanPrice(): Real;
  nonParRepayment(): Real;
  bond(): Bond;
  payBondCoupon(): boolean;
  bondLeg(): Leg;
  floatingLeg(): Leg;
  setupArguments(args: PricingEngine.Arguments): void;
  fetchResults(r: PricingEngine.Results): void;
  setupExpired(): void;
  private _bond;
  private _bondCleanPrice;
  private _nonParRepayment;
  private _spread;
  private _parSwap;
  private _upfrontDate;
  private _fairSpread;
  private _fairCleanPrice;
  private _fairNonParRepayment;
}
export declare namespace AssetSwap {
  class Arguments extends Swap.Arguments {
    validate(): void;
    fixedResetDates: Date[];
    fixedPayDates: Date[];
    fixedCoupons: Real[];
    floatingAccrualTimes: Time[];
    floatingResetDates: Date[];
    floatingFixingDates: Date[];
    floatingPayDates: Date[];
    floatingSpreads: Spread[];
  }
  class Results extends Swap.Results {
    reset(): void;
    fairSpread: Spread;
    fairCleanPrice: Real;
    fairNonParRepayment: Real;
  }
}

export declare namespace Average {
  enum Type { Arithmetic = 0, Geometric = 1 }
}

export declare class BarrierOption extends OneAssetOption {
  constructor(
      barrierType: Barrier.Type, barrier: Real, rebate: Real,
      payoff: StrikedTypePayoff, exercise: Exercise);
  setupArguments(args: PricingEngine.Arguments): void;
  impliedVolatility(
      targetValue: Real, process: GeneralizedBlackScholesProcess,
      accuracy?: Real, maxEvaluations?: Size, minVol?: Volatility,
      maxVol?: Volatility): Volatility;
  protected _barrierType: Barrier.Type;
  protected _barrier: Real;
  protected _rebate: Real;
}

export declare namespace BarrierOptionEngine {
  class Arguments extends OneAssetOption.Arguments {
    constructor();
    validate(): void;
    barrierType: Barrier.Type;
    barrier: Real;
    rebate: Real;
  }
  class Results extends OneAssetOption.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
    triggered(underlying: Real): boolean;
  }
}

export declare namespace Barrier {
  enum Type { DownIn = 0, UpIn = 1, DownOut = 2, UpOut = 3 }
}

export declare class BasketPayoff extends Payoff {
  init(p: Payoff): BasketPayoff;
  name(): string;
  description(): string;
  f(price: Real): Real;
  f1(a: Real[]): Real;
  accumulate(a: Real[]): Real;
  basePayoff(): Payoff;
  private _basePayoff;
}
export declare class MinBasketPayoff extends BasketPayoff {
  accumulate(a: Real[]): Real;
}
export declare class MaxBasketPayoff extends BasketPayoff {
  accumulate(a: Real[]): Real;
}
export declare class AverageBasketPayoff extends BasketPayoff {
  abpInit1(p: Payoff, a: Real[]): AverageBasketPayoff;
  abpInit2(p: Payoff, n: Size): AverageBasketPayoff;
  accumulate(a: Real[]): Real;
  private _weights;
}
export declare class SpreadBasketPayoff extends BasketPayoff {
  accumulate(a: Real[]): Real;
}
export declare class BasketOption extends MultiAssetOption {
  constructor(payoff: BasketPayoff, exercise: Exercise);
}
export declare namespace BasketOption {
  class Arguments extends MultiAssetOption.Arguments {}
  class Results extends MultiAssetOption.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class BMASwap extends Swap {
  constructor(
      type: BMASwap.Type, nominal: Real, liborSchedule: Schedule,
      liborFraction: Real, liborSpread: Spread, liborIndex: IborIndex,
      liborDayCount: DayCounter, bmaSchedule: Schedule, bmaIndex: BMAIndex,
      bmaDayCount: DayCounter);
  liborFraction(): Real;
  liborSpread(): Spread;
  nominal(): Real;
  type(): BMASwap.Type;
  liborleg(): Leg;
  bmaleg(): Leg;
  liborLegBPS(): Real;
  liborLegNPV(): Real;
  fairLiborFraction(): Real;
  fairLiborSpread(): Spread;
  bmaLegBPS(): Real;
  bmaLegNPV(): Real;
  private _type;
  private _nominal;
  private _liborFraction;
  private _liborSpread;
}
export declare namespace BMASwap {
  enum Type { Receiver = -1, Payer = 1 }
}

export declare class Bond extends Instrument {
  init1(
      settlementDays: Natural, calendar: Calendar, issueDate?: Date,
      coupons?: Leg): Bond;
  init2(
      settlementDays: Natural, calendar: Calendar, faceAmount: Real,
      maturityDate: Date, issueDate?: Date, cashflows?: Leg): Bond;
  isExpired(): boolean;
  settlementDays(): Natural;
  calendar(): Calendar;
  notionals(): Real[];
  notional(d?: Date): Real;
  cashflows(): Leg;
  redemptions(): Leg;
  redemption(): CashFlow;
  startDate(): Date;
  maturityDate(): Date;
  issueDate(): Date;
  isTradable(d?: Date): boolean;
  settlementDate(d?: Date): Date;
  cleanPrice1(): Real;
  dirtyPrice1(): Real;
  settlementValue1(): Real;
  yield1(
      dc: DayCounter, comp: Compounding, freq: Frequency, accuracy?: Real,
      maxEvaluations?: Size): Rate;
  cleanPrice2(
      y: Rate, dc: DayCounter, comp: Compounding, freq: Frequency,
      settlement?: Date): Real;
  dirtyPrice2(
      y: Rate, dc: DayCounter, comp: Compounding, freq: Frequency,
      settlement?: Date): Real;
  settlementValue2(cleanPrice: Real): Real;
  yield2(
      cleanPrice: Real, dc: DayCounter, comp: Compounding, freq: Frequency,
      settlement?: Date, accuracy?: Real, maxEvaluations?: Size): Rate;
  accruedAmount(settlement?: Date): Real;
  nextCouponRate(settlement?: Date): Rate;
  previousCouponRate(settlement?: Date): Rate;
  nextCashFlowDate(settlement?: Date): Date;
  previousCashFlowDate(settlement?: Date): Date;
  setupExpired(): void;
  setupArguments(args: PricingEngine.Arguments): void;
  fetchResults(r: PricingEngine.Results): void;
  deepUpdate(): void;
  protected addRedemptionsToCashflows(redemptions?: Real[]): void;
  protected setSingleRedemption1(notional: Real, redemption: Real, date: Date):
      void;
  protected setSingleRedemption2(notional: Real, redemption: CashFlow): void;
  protected calculateNotionalsFromCashflows(): void;
  protected _settlementDays: Natural;
  protected _calendar: Calendar;
  protected _notionalSchedule: Date[];
  protected _notionals: Real[];
  protected _cashflows: Leg;
  protected _redemptions: Leg;
  protected _maturityDate: Date;
  protected _issueDate: Date;
  protected _settlementValue: Real;
}
export declare namespace Bond {
  class Arguments extends PricingEngine.Arguments {
    settlementDate: Date;
    cashflows: Leg;
    calendar: Calendar;
    validate(): void;
  }
  class Results extends Instrument.Results {
    settlementValue: Real;
    reset(): void;
  }
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare type CallabilitySchedule = Callability[];
export declare class Callability extends Event {
  constructor(price: Callability.Price, type: Callability.Type, date: Date);
  price(): Callability.Price;
  type(): Callability.Type;
  date(): Date;
  accept(v: AcyclicVisitor): void;
  private _price;
  private _type;
  private _date;
}
export declare namespace Callability {
  class Price {
    init1(): Price;
    init2(amount: Real, type: Price.Type): Price;
    amount(): Real;
    type(): Price.Type;
    private _amount;
    private _type;
  }
  namespace Price {
    enum Type { Dirty = 0, Clean = 1 }
  }
  enum Type { Call = 0, Put = 1 }
}

export declare class CapFloor extends Instrument {
  init1(
      type: CapFloor.Type, floatingLeg: Leg, capRates: Rate[],
      floorRates: Rate[]): CapFloor;
  init2(type: CapFloor.Type, floatingLeg: Leg, strikes: Rate[]): CapFloor;
  isExpired(): boolean;
  setupArguments(args: PricingEngine.Arguments): void;
  type(): CapFloor.Type;
  capRates(): Rate[];
  floorRates(): Rate[];
  floatingLeg(): Leg;
  startDate(): Date;
  maturityDate(): Date;
  lastFloatingRateCoupon(): FloatingRateCoupon;
  optionlet(i: Size): CapFloor;
  atmRate(discountCurve: YieldTermStructure): Rate;
  impliedVolatility(
      targetValue: Real, disc: Handle<YieldTermStructure>, guess: Volatility,
      accuracy?: Real, maxEvaluations?: Natural, minVol?: Volatility,
      maxVol?: Volatility, type?: VolatilityType,
      displacement?: Real): Volatility;
  private _type;
  private _floatingLeg;
  private _capRates;
  private _floorRates;
}
export declare namespace CapFloor {
  enum Type { Cap = 0, Floor = 1, Collar = 2 }
}
export declare class Cap extends CapFloor {
  constructor(floatingLeg: Leg, exerciseRates: Rate[]);
}
export declare class Floor extends CapFloor {
  constructor(floatingLeg: Leg, exerciseRates: Rate[]);
}
export declare class Collar extends CapFloor {
  constructor(floatingLeg: Leg, capRates: Rate[], floorRates: Rate[]);
}

export declare namespace CapFloorEngine {
  class Arguments extends PricingEngine.Arguments {
    validate(): void;
    type: CapFloor.Type;
    startDates: Date[];
    fixingDates: Date[];
    endDates: Date[];
    accrualTimes: Time[];
    capRates: Rate[];
    floorRates: Rate[];
    forwards: Rate[];
    gearings: Rate[];
    spreads: Rate[];
    nominals: Rate[];
    indexes: InterestRateIndex[];
  }
  class Results extends Instrument.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class Claim extends ObserverObservable {
  amount(defaultDate: Date, notional: Real, recoveryRate: Real): Real;
  update(): void;
}
export declare class FaceValueClaim extends Claim {
  amount(defaultDate: Date, notional: Real, recoveryRate: Real): Real;
}
export declare class FaceValueAccrualClaim extends Claim {
  constructor(referenceSecurity: Bond);
  amount(d: Date, notional: Real, recoveryRate: Real): Real;
  private _referenceSecurity;
}

export declare class CliquetOption extends OneAssetOption {
  constructor(
      payoff: PercentageStrikePayoff, maturity: EuropeanExercise,
      resetDates: Date[]);
  setupArguments(args: PricingEngine.Arguments): void;
  private _resetDates;
}
export declare namespace CliquetOption {
  class Arguments extends OneAssetOption.Arguments {
    constructor();
    validate(): void;
    accruedCoupon: Real;
    lastFixing: Real;
    localCap: Real;
    localFloor: Real;
    globalCap: Real;
    globalFloor: Real;
    resetDates: Date[];
  }
  class Results extends OneAssetOption.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
    init(...args: any[]): engine;
  }
}

export declare class CompositeInstrument extends Instrument {
  add(instrument: Instrument, multiplier?: Real): void;
  subtract(instrument: Instrument, multiplier?: Real): void;
  deepUpdate(): void;
  isExpired(): boolean;
  performCalculations(): void;
  private _components;
}

export declare class CPICapFloor extends Instrument {
  constructor(
      type: Option.Type, nominal: Real, startDate: Date, baseCPI: Real,
      maturity: Date, fixCalendar: Calendar,
      fixConvention: BusinessDayConvention, payCalendar: Calendar,
      payConvention: BusinessDayConvention, strike: Rate,
      infIndex: Handle<ZeroInflationIndex>, observationLag: Period,
      observationInterpolation?: CPI.InterpolationType);
  type(): Option.Type;
  nominal(): Real;
  strike(): Rate;
  fixingDate(): Date;
  payDate(): Date;
  inflationIndex(): Handle<ZeroInflationIndex>;
  observationLag(): Period;
  isExpired(): boolean;
  setupArguments(args: PricingEngine.Arguments): void;
  fetchResults(r: PricingEngine.Results): void;
  protected _type: Option.Type;
  protected _nominal: Real;
  protected _startDate: Date;
  protected _fixDate: Date;
  protected _payDate: Date;
  protected _baseCPI: Real;
  protected _maturity: Date;
  protected _fixCalendar: Calendar;
  protected _payCalendar: Calendar;
  protected _fixConvention: BusinessDayConvention;
  protected _payConvention: BusinessDayConvention;
  protected _strike: Rate;
  protected _infIndex: Handle<ZeroInflationIndex>;
  protected _observationLag: Period;
  protected _observationInterpolation: CPI.InterpolationType;
}
export declare namespace CPICapFloor {
  class Arguments extends PricingEngine.Arguments {
    validate(): void;
    type: Option.Type;
    nominal: Real;
    startDate: Date;
    fixDate: Date;
    payDate: Date;
    baseCPI: Real;
    maturity: Date;
    fixCalendar: Calendar;
    payCalendar: Calendar;
    fixConvention: BusinessDayConvention;
    payConvention: BusinessDayConvention;
    strike: Rate;
    infIndex: Handle<ZeroInflationIndex>;
    observationLag: Period;
    observationInterpolation: CPI.InterpolationType;
  }
  class Results extends Instrument.Results {
    reset(): void;
  }
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class CPISwap extends Swap {
  constructor(
      type: CPISwap.Type, nominal: Real, subtractInflationNominal: boolean,
      spread: Spread, floatDayCount: DayCounter, floatSchedule: Schedule,
      floatPaymentRoll: BusinessDayConvention, fixingDays: Natural,
      floatIndex: IborIndex, fixedRate: Rate, baseCPI: Real,
      fixedDayCount: DayCounter, fixedSchedule: Schedule,
      fixedPaymentRoll: BusinessDayConvention, observationLag: Period,
      fixedIndex: ZeroInflationIndex,
      observationInterpolation?: CPI.InterpolationType,
      inflationNominal?: Real);
  floatLegNPV(): Real;
  fairSpread(): Spread;
  fixedLegNPV(): Real;
  fairRate(): Rate;
  type(): CPISwap.Type;
  nominal(): Real;
  subtractInflationNominal(): boolean;
  spread(): Spread;
  floatDayCount(): DayCounter;
  floatSchedule(): Schedule;
  floatPaymentRoll(): BusinessDayConvention;
  fixingDays(): Natural;
  floatIndex(): IborIndex;
  fixedRate(): Rate;
  baseCPI(): Real;
  fixedDayCount(): DayCounter;
  fixedSchedule(): Schedule;
  fixedPaymentRoll(): BusinessDayConvention;
  observationLag(): Period;
  fixedIndex(): ZeroInflationIndex;
  observationInterpolation(): CPI.InterpolationType;
  inflationNominal(): Real;
  cpiLeg(): Leg;
  floatLeg(): Leg;
  setupArguments(args: PricingEngine.Arguments): void;
  fetchResults(r: PricingEngine.Results): void;
  setupExpired(): void;
  private _type;
  private _nominal;
  private _subtractInflationNominal;
  private _spread;
  private _floatDayCount;
  private _floatSchedule;
  private _floatPaymentRoll;
  private _fixingDays;
  private _floatIndex;
  private _fixedRate;
  private _baseCPI;
  private _fixedDayCount;
  private _fixedSchedule;
  private _fixedPaymentRoll;
  private _fixedIndex;
  private _observationLag;
  private _observationInterpolation;
  private _inflationNominal;
  private _fairSpread;
  private _fairRate;
}
export declare namespace CPISwap {
  enum Type { Receiver = -1, Payer = 1 }
  class Arguments extends Swap.Arguments {
    constructor();
    validate(): void;
    type: Type;
    nominal: Real;
  }
  class Results extends Swap.Results {
    reset(): void;
    fairRate: Rate;
    fairSpread: Spread;
  }
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class CreditDefaultSwap extends Instrument {
  init1(
      side: Protection.Side, notional: Real, spread: Rate, schedule: Schedule,
      convention: BusinessDayConvention, dayCounter: DayCounter,
      settlesAccrual?: boolean, paysAtDefaultTime?: boolean,
      protectionStart?: Date, claim?: Claim, lastPeriodDayCounter?: DayCounter,
      rebatesAccrual?: boolean): CreditDefaultSwap;
  init2(
      side: Protection.Side, notional: Real, upfront: Rate, runningSpread: Rate,
      schedule: Schedule, convention: BusinessDayConvention,
      dayCounter: DayCounter, settlesAccrual?: boolean,
      paysAtDefaultTime?: boolean, protectionStart?: Date, upfrontDate?: Date,
      claim?: Claim, lastPeriodDayCounter?: DayCounter,
      rebatesAccrual?: boolean): CreditDefaultSwap;
  side(): Protection.Side;
  notional(): Real;
  runningSpread(): Rate;
  upfront(): Rate;
  settlesAccrual(): boolean;
  paysAtDefaultTime(): boolean;
  coupons(): Leg;
  protectionStartDate(): Date;
  protectionEndDate(): Date;
  rebatesAccrual(): boolean;
  fairUpfront(): Rate;
  fairSpread(): Rate;
  couponLegBPS(): Real;
  couponLegNPV(): Real;
  defaultLegNPV(): Real;
  upfrontBPS(): Real;
  upfrontNPV(): Real;
  accrualRebateNPV(): Real;
  impliedHazardRate(
      targetNPV: Real, discountCurve: Handle<YieldTermStructure>,
      dayCounter: DayCounter, recoveryRate?: Real, accuracy?: Real,
      model?: CreditDefaultSwap.PricingModel): Rate;
  conventionalSpread(
      conventionalRecovery: Real, discountCurve: Handle<YieldTermStructure>,
      dayCounter: DayCounter, model?: CreditDefaultSwap.PricingModel): Rate;
  isExpired(): boolean;
  setupArguments(args: PricingEngine.Arguments): void;
  fetchResults(r: PricingEngine.Results): void;
  setupExpired(): void;
  protected _side: Protection.Side;
  protected _notional: Real;
  protected _upfront: Rate;
  protected _runningSpread: Rate;
  protected _settlesAccrual: boolean;
  protected _paysAtDefaultTime: boolean;
  protected _claim: Claim;
  protected _leg: Leg;
  protected _upfrontPayment: CashFlow;
  protected _accrualRebate: CashFlow;
  protected _protectionStart: Date;
  protected _maturity: Date;
  protected _fairUpfront: Rate;
  protected _fairSpread: Rate;
  protected _couponLegBPS: Real;
  protected _couponLegNPV: Real;
  protected _upfrontBPS: Real;
  protected _upfrontNPV: Real;
  protected _defaultLegNPV: Real;
  protected _accrualRebateNPV: Real;
}
export declare namespace CreditDefaultSwap {
  enum PricingModel { Midpoint = 0, ISDA = 1 }
}

export declare namespace CreditDefaultSwapEngine {
  class Arguments extends PricingEngine.Arguments {
    validate(): void;
    side: Protection.Side;
    notional: Real;
    upfront: Rate;
    spread: Rate;
    leg: Leg;
    upfrontPayment: CashFlow;
    accrualRebate: CashFlow;
    settlesAccrual: boolean;
    paysAtDefaultTime: boolean;
    claim: Claim;
    protectionStart: Date;
    maturity: Date;
  }
  class Results extends Instrument.Results {
    reset(): void;
    fairSpread: Rate;
    fairUpfront: Rate;
    couponLegBPS: Real;
    couponLegNPV: Real;
    defaultLegNPV: Real;
    upfrontBPS: Real;
    upfrontNPV: Real;
    accrualRebateNPV: Real;
  }
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class DividendBarrierOption extends BarrierOption {
  constructor(
      barrierType: Barrier.Type, barrier: Real, rebate: Real,
      payoff: StrikedTypePayoff, exercise: Exercise, dividendDates: Date[],
      dividends: Real[]);
  setupArguments(args: PricingEngine.Arguments): void;
  private _cashFlow;
}
export declare namespace DividendBarrierOption {
  class Arguments extends BarrierOptionEngine.Arguments {
    constructor();
    validate(): void;
    cashFlow: DividendSchedule;
  }
  class Results extends BarrierOptionEngine.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare type DividendSchedule = Dividend[];

export declare class DividendVanillaOption extends OneAssetOption {
  constructor(
      payoff: StrikedTypePayoff, exercise: Exercise, dividendDates: Date[],
      dividends: Real[]);
  impliedVolatility(
      targetValue: Real, process: GeneralizedBlackScholesProcess,
      accuracy?: Real, maxEvaluations?: Size, minVol?: Volatility,
      maxVol?: Volatility): Volatility;
  setupArguments(args: PricingEngine.Arguments): void;
  private _cashFlow;
}

export declare namespace DividendVanillaOptionEngine {
  class Results extends OneAssetOption.Results {}
  class Arguments extends OneAssetOption.Arguments {
    constructor();
    validate(): void;
    cashFlow: DividendSchedule;
  }
  class engine extends GenericEngine<Arguments, Results> {}
}

export declare class EuropeanOption extends VanillaOption {
  constructor(payoff: StrikedTypePayoff, exercise: Exercise);
}

export declare class FixedRateBondForward extends Forward {
  constructor(
      valueDate: Date, maturityDate: Date, type: Position.Type, strike: Real,
      settlementDays: Natural, dayCounter: DayCounter, calendar: Calendar,
      businessDayConvention: BusinessDayConvention,
      fixedCouponBond: FixedRateBond,
      discountCurve?: Handle<YieldTermStructure>,
      incomeDiscountCurve?: Handle<YieldTermStructure>);
  forwardPrice(): Real;
  cleanForwardPrice(): Real;
  spotIncome(incomeDiscountCurve: Handle<YieldTermStructure>): Real;
  spotValue(): Real;
  performCalculations(): void;
  protected _fixedCouponBond: FixedRateBond;
}

export declare class FloatFloatSwap extends Swap {
  ffsInit1(
      type: VanillaSwap.Type, nominal1: Real, nominal2: Real,
      schedule1: Schedule, index1: InterestRateIndex, dayCount1: DayCounter,
      schedule2: Schedule, index2: InterestRateIndex, dayCount2: DayCounter,
      intermediateCapitalExchange?: boolean, finalCapitalExchange?: boolean,
      gearing1?: Real, spread1?: Real, cappedRate1?: Real, flooredRate1?: Real,
      gearing2?: Real, spread2?: Real, cappedRate2?: Real, flooredRate2?: Real,
      paymentConvention1?: BusinessDayConvention,
      paymentConvention2?: BusinessDayConvention): FloatFloatSwap;
  ffsInit2(
      type: VanillaSwap.Type, nominal1: Real[], nominal2: Real[],
      schedule1: Schedule, index1: InterestRateIndex, dayCount1: DayCounter,
      schedule2: Schedule, index2: InterestRateIndex, dayCount2: DayCounter,
      intermediateCapitalExchange?: boolean, finalCapitalExchange?: boolean,
      gearing1?: Real[], spread1?: Real[], cappedRate1?: Real[],
      flooredRate1?: Real[], gearing2?: Real[], spread2?: Real[],
      cappedRate2?: Real[], flooredRate2?: Real[],
      paymentConvention1?: BusinessDayConvention,
      paymentConvention2?: BusinessDayConvention): FloatFloatSwap;
  type(): VanillaSwap.Type;
  nominal1(): Real[];
  nominal2(): Real[];
  schedule1(): Schedule;
  schedule2(): Schedule;
  index1(): InterestRateIndex;
  index2(): InterestRateIndex;
  spread1(): Real[];
  spread2(): Real[];
  gearing1(): Real[];
  gearing2(): Real[];
  cappedRate1(): Rate[];
  flooredRate1(): Rate[];
  cappedRate2(): Rate[];
  flooredRate2(): Rate[];
  dayCount1(): DayCounter;
  dayCount2(): DayCounter;
  paymentConvention1(): BusinessDayConvention;
  paymentConvention2(): BusinessDayConvention;
  leg1(): Leg;
  leg2(): Leg;
  setupArguments(args: PricingEngine.Arguments): void;
  fetchResults(r: PricingEngine.Results): void;
  setupExpired(): void;
  private _init;
  private _type;
  private _nominal1;
  private _nominal2;
  private _schedule1;
  private _schedule2;
  private _index1;
  private _index2;
  private _gearing1;
  private _gearing2;
  private _spread1;
  private _spread2;
  private _cappedRate1;
  private _cappedRate2;
  private _flooredRate1;
  private _flooredRate2;
  private _dayCount1;
  private _dayCount2;
  private _paymentConvention1;
  private _paymentConvention2;
  private _intermediateCapitalExchange;
  private _finalCapitalExchange;
}
export declare namespace FloatFloatSwap {
  class Arguments extends Swap.Arguments {
    constructor();
    validate(): void;
    type: VanillaSwap.Type;
    nominal1: Real[];
    nominal2: Real[];
    leg1ResetDates: Date[];
    leg1FixingDates: Date[];
    leg1PayDates: Date[];
    leg2ResetDates: Date[];
    leg2FixingDates: Date[];
    leg2PayDates: Date[];
    leg1Spreads: Real[];
    leg2Spreads: Real[];
    leg1Gearings: Real[];
    leg2Gearings: Real[];
    leg1CappedRates: Real[];
    leg1FlooredRates: Real[];
    leg2CappedRates: Real[];
    leg2FlooredRates: Real[];
    leg1Coupons: Real[];
    leg2Coupons: Real[];
    leg1AccrualTimes: Real[];
    leg2AccrualTimes: Real[];
    index1: InterestRateIndex;
    index2: InterestRateIndex;
    leg1IsRedemptionFlow: boolean[];
    leg2IsRedemptionFlow: boolean[];
  }
  class Results extends Swap.Results {
    reset(): void;
  }
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class FloatFloatSwaption extends Option {
  constructor(swap: FloatFloatSwap, exercise: Exercise);
  isExpired(): boolean;
  setupArguments(args: PricingEngine.Arguments): void;
  type(): VanillaSwap.Type;
  underlyingSwap(): FloatFloatSwap;
  calibrationBasket(
      standardSwapBase: SwapIndex,
      swaptionVolatility: SwaptionVolatilityStructure,
      basketType?: BasketGeneratingEngine.CalibrationBasketType):
      CalibrationHelper[];
  private _swap;
}
export declare namespace FloatFloatSwaption {
  class Arguments extends FloatFloatSwapOptionArguments {
    constructor();
    validate(): void;
    swap: FloatFloatSwap;
  }
  class Results extends Option.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class Forward extends Instrument {
  constructor(
      dayCounter: DayCounter, calendar: Calendar,
      businessDayConvention: BusinessDayConvention, settlementDays: Natural,
      payoff: Payoff, valueDate: Date, maturityDate: Date,
      discountCurve?: Handle<YieldTermStructure>);
  calendar(): Calendar;
  businessDayConvention(): BusinessDayConvention;
  dayCounter(): DayCounter;
  discountCurve(): Handle<YieldTermStructure>;
  incomeDiscountCurve(): Handle<YieldTermStructure>;
  spotValue(): Real;
  spotIncome(incomeDiscountCurve: Handle<YieldTermStructure>): Real;
  settlementDate(): Date;
  isExpired(): boolean;
  forwardValue(): Real;
  impliedYield(
      underlyingSpotValue: Real, forwardValue: Real, settlementDate: Date,
      comp: Compounding, dayCounter: DayCounter): InterestRate;
  performCalculations(): void;
  protected _underlyingIncome: Real;
  protected _underlyingSpotValue: Real;
  protected _dayCounter: DayCounter;
  protected _calendar: Calendar;
  protected _businessDayConvention: BusinessDayConvention;
  protected _settlementDays: Natural;
  protected _payoff: Payoff;
  protected _valueDate: Date;
  protected _maturityDate: Date;
  protected _discountCurve: Handle<YieldTermStructure>;
  protected _incomeDiscountCurve: Handle<YieldTermStructure>;
}
export declare class ForwardTypePayoff extends Payoff {
  constructor(type: Position.Type, strike: Real);
  forwardType(): Position.Type;
  strike(): Real;
  name(): string;
  description(): string;
  f(price: Real): Real;
  protected _type: Position.Type;
  protected _strike: Real;
}

export declare class ForwardRateAgreement extends Forward {
  constructor(
      valueDate: Date, maturityDate: Date, type: Position.Type,
      strikeForwardRate: Rate, notionalAmount: Real, index: IborIndex,
      discountCurve?: Handle<YieldTermStructure>);
  settlementDate(): Date;
  isExpired(): boolean;
  fixingDate(): Date;
  spotIncome(curve: Handle<YieldTermStructure>): Real;
  spotValue(): Real;
  forwardRate(): InterestRate;
  performCalculations(): void;
  protected _fraType: Position.Type;
  protected _forwardRate: InterestRate;
  protected _strikeForwardRate: InterestRate;
  protected _notionalAmount: Real;
  protected _index: IborIndex;
}

export declare class ForwardOptionArguments extends OneAssetOption.Arguments {
  constructor();
  validate(): void;
  moneyness: Real;
  resetDate: Date;
}
export declare class ForwardVanillaOption extends OneAssetOption {
  constructor(
      moneyness: Real, resetDate: Date, payoff: StrikedTypePayoff,
      exercise: Exercise);
  setupArguments(args: PricingEngine.Arguments): void;
  private _moneyness;
  private _resetDate;
}

export declare namespace Futures {
  enum Type { IMM = 0, ASX = 1 }
}

export declare class ImpliedVolatilityHelper {
  static calculate(
      instrument: Instrument, engine: PricingEngine, volQuote: SimpleQuote,
      targetValue: Real, accuracy: Real, maxEvaluations: Natural,
      minVol: Volatility, maxVol: Volatility): Volatility;
  static clone(process: GeneralizedBlackScholesProcess, volQuote: SimpleQuote):
      GeneralizedBlackScholesProcess;
}
export declare class PriceError implements UnaryFunction<Volatility, Real> {
  constructor(engine: PricingEngine, vol: SimpleQuote, targetValue: Real);
  f(x: Volatility): Real;
  private _engine;
  private _vol;
  private _targetValue;
  private _results;
}

export declare class YoYInflationCapFloor extends Instrument {
  yoyicfInit1(
      type: YoYInflationCapFloor.Type, yoyLeg: Leg, capRates: Rate[],
      floorRates: Rate[]): YoYInflationCapFloor;
  yoyicfInit2(type: YoYInflationCapFloor.Type, yoyLeg: Leg, strikes: Rate[]):
      YoYInflationCapFloor;
  isExpired(): boolean;
  setupArguments(args: PricingEngine.Arguments): void;
  type(): YoYInflationCapFloor.Type;
  capRates(): Rate[];
  floorRates(): Rate[];
  yoyLeg(): Leg;
  startDate(): Date;
  maturityDate(): Date;
  lastYoYInflationCoupon(): YoYInflationCoupon;
  optionlet(i: Size): YoYInflationCapFloor;
  atmRate(discountCurve: YieldTermStructure): Rate;
  impliedVolatility(
      price: Real, yoyCurve: Handle<YoYInflationTermStructure>,
      guess: Volatility, accuracy?: Real, maxEvaluations?: Natural,
      minVol?: Volatility, maxVol?: Volatility): Volatility;
  private _type;
  private _yoyLeg;
  private _capRates;
  private _floorRates;
}
export declare namespace YoYInflationCapFloor {
  enum Type { Cap = 0, Floor = 1, Collar = 2 }
  class Arguments extends PricingEngine.Arguments {
    constructor();
    validate(): void;
    type: Type;
    index: YoYInflationIndex;
    observationLag: Period;
    startDates: Date[];
    fixingDates: Date[];
    payDates: Date[];
    accrualTimes: Time[];
    capRates: Rate[];
    floorRates: Rate[];
    gearings: Real[];
    spreads: Real[];
    nominals: Real[];
  }
  class Results extends Instrument.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}
export declare class YoYInflationCap extends YoYInflationCapFloor {
  constructor(yoyLeg: Leg, exerciseRates: Rate[]);
}
export declare class YoYInflationFloor extends YoYInflationCapFloor {
  constructor(yoyLeg: Leg, exerciseRates: Rate[]);
}
export declare class YoYInflationCollar extends YoYInflationCapFloor {
  constructor(yoyLeg: Leg, capRates: Rate[], floorRates: Rate[]);
}

export declare class ContinuousFloatingLookbackOption extends OneAssetOption {
  constructor(minmax: Real, payoff: TypePayoff, exercise: Exercise);
  setupArguments(args: PricingEngine.Arguments): void;
  protected _minmax: Real;
}
export declare namespace ContinuousFloatingLookbackOption {
  class Arguments extends OneAssetOption.Arguments {
    validate(): void;
    minmax: Real;
  }
  class Results extends OneAssetOption.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}
export declare class ContinuousFixedLookbackOption extends OneAssetOption {
  constructor(minmax: Real, payoff: TypePayoff, exercise: Exercise);
  setupArguments(args: PricingEngine.Arguments): void;
  protected _minmax: Real;
}
export declare namespace ContinuousFixedLookbackOption {
  class Arguments extends OneAssetOption.Arguments {
    validate(): void;
    minmax: Real;
  }
  class Results extends OneAssetOption.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}
export declare class ContinuousPartialFloatingLookbackOption extends
    ContinuousFloatingLookbackOption {
  constructor(
      minmax: Real, lambda: Real, lookbackPeriodEnd: Date, payoff: TypePayoff,
      exercise: Exercise);
  setupArguments(args: PricingEngine.Arguments): void;
  protected _lambda: Real;
  protected _lookbackPeriodEnd: Date;
}
export declare namespace ContinuousPartialFloatingLookbackOption {
  class Arguments extends ContinuousFloatingLookbackOption.Arguments {
    validate(): void;
    lambda: Real;
    lookbackPeriodEnd: Date;
  }
  class Results extends ContinuousFloatingLookbackOption.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}
export declare class ContinuousPartialFixedLookbackOption extends
    ContinuousFixedLookbackOption {
  constructor(
      lookbackPeriodStart: Date, payoff: TypePayoff, exercise: Exercise);
  setupArguments(args: PricingEngine.Arguments): void;
  protected _lookbackPeriodStart: Date;
}
export declare namespace ContinuousPartialFixedLookbackOption {
  class Arguments extends ContinuousFixedLookbackOption.Arguments {
    validate(): void;
    lookbackPeriodStart: Date;
  }
  class Results extends ContinuousFixedLookbackOption.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class MakeCapFloor implements NullaryFunction<CapFloor> {
  constructor(
      capFloorType: CapFloor.Type, tenor: Period, iborIndex: IborIndex,
      strike?: Rate, forwardStart?: Period);
  withNominal(n: Real): MakeCapFloor;
  withEffectiveDate(effectiveDate: Date, firstCapletExcluded: boolean):
      MakeCapFloor;
  withTenor(t: Period): MakeCapFloor;
  withCalendar(cal: Calendar): MakeCapFloor;
  withConvention(bdc: BusinessDayConvention): MakeCapFloor;
  withTerminationDateConvention(bdc: BusinessDayConvention): MakeCapFloor;
  withRule(r: DateGeneration.Rule): MakeCapFloor;
  withEndOfMonth(flag?: boolean): MakeCapFloor;
  withFirstDate(d: Date): MakeCapFloor;
  withNextToLastDate(d: Date): MakeCapFloor;
  withDayCount(dc: DayCounter): MakeCapFloor;
  asOptionlet(b?: boolean): MakeCapFloor;
  withPricingEngine(engine: PricingEngine): MakeCapFloor;
  f(): CapFloor;
  private _capFloorType;
  private _strike;
  private _firstCapletExcluded;
  private _asOptionlet;
  private _makeVanillaSwap;
  private _engine;
}

export declare class MakeCreditDefaultSwap implements
    NullaryFunction<CreditDefaultSwap> {
  init1(tenor: Period, couponRate: Real): MakeCreditDefaultSwap;
  init2(termDate: Date, couponRate: Real): MakeCreditDefaultSwap;
  withUpfrontRate(upfrontRate: Real): MakeCreditDefaultSwap;
  withSide(side: Protection.Side): MakeCreditDefaultSwap;
  withNominal(nominal: Real): MakeCreditDefaultSwap;
  withCouponTenor(couponTenor: Period): MakeCreditDefaultSwap;
  withDayCounter(dayCounter: DayCounter): MakeCreditDefaultSwap;
  withLastPeriodDayCounter(lastPeriodDayCounter: DayCounter):
      MakeCreditDefaultSwap;
  withPricingEngine(engine: PricingEngine): MakeCreditDefaultSwap;
  f(): CreditDefaultSwap;
  private _side;
  private _nominal;
  private _tenor;
  private _termDate;
  private _couponTenor;
  private _couponRate;
  private _upfrontRate;
  private _dayCounter;
  private _lastPeriodDayCounter;
  private _engine;
}

export declare class MakeCms implements NullaryFunction<Swap> {
  init1(
      swapTenor: Period, swapIndex: SwapIndex, iborIndex: IborIndex,
      iborSpread?: Spread, forwardStart?: Period): MakeCms;
  init2(
      swapTenor: Period, swapIndex: SwapIndex, iborSpread?: Spread,
      forwardStart?: Period): MakeCms;
  receiveCms(flag?: boolean): MakeCms;
  withNominal(n: Real): MakeCms;
  withEffectiveDate(effectiveDate: Date): MakeCms;
  withCmsLegTenor(t: Period): MakeCms;
  withCmsLegCalendar(cal: Calendar): MakeCms;
  withCmsLegConvention(bdc: BusinessDayConvention): MakeCms;
  withCmsLegTerminationDateConvention(bdc: BusinessDayConvention): MakeCms;
  withCmsLegRule(r: DateGeneration.Rule): MakeCms;
  withCmsLegEndOfMonth(flag?: boolean): MakeCms;
  withCmsLegFirstDate(d: Date): MakeCms;
  withCmsLegNextToLastDate(d: Date): MakeCms;
  withCmsLegDayCount(dc: DayCounter): MakeCms;
  withFloatingLegTenor(t: Period): MakeCms;
  withFloatingLegCalendar(cal: Calendar): MakeCms;
  withFloatingLegConvention(bdc: BusinessDayConvention): MakeCms;
  withFloatingLegTerminationDateConvention(bdc: BusinessDayConvention): MakeCms;
  withFloatingLegRule(r: DateGeneration.Rule): MakeCms;
  withFloatingLegEndOfMonth(flag?: boolean): MakeCms;
  withFloatingLegFirstDate(d: Date): MakeCms;
  withFloatingLegNextToLastDate(d: Date): MakeCms;
  withFloatingLegDayCount(dc: DayCounter): MakeCms;
  withAtmSpread(flag?: boolean): MakeCms;
  withDiscountingTermStructure(discountingTermStructure:
                                   Handle<YieldTermStructure>): MakeCms;
  withCmsCouponPricer(couponPricer: CmsCouponPricer): MakeCms;
  f(): Swap;
  private _swapTenor;
  private _swapIndex;
  private _iborIndex;
  private _iborSpread;
  private _useAtmSpread;
  private _forwardStart;
  private _cmsSpread;
  private _cmsGearing;
  private _cmsCap;
  private _cmsFloor;
  private _effectiveDate;
  private _cmsCalendar;
  private _floatCalendar;
  private _payCms;
  private _nominal;
  private _cmsTenor;
  private _floatTenor;
  private _cmsConvention;
  private _cmsTerminationDateConvention;
  private _floatConvention;
  private _floatTerminationDateConvention;
  private _cmsRule;
  private _floatRule;
  private _cmsEndOfMonth;
  private _floatEndOfMonth;
  private _cmsFirstDate;
  private _cmsNextToLastDate;
  private _floatFirstDate;
  private _floatNextToLastDate;
  private _cmsDayCount;
  private _floatDayCount;
  private _engine;
  private _couponPricer;
}

export declare class MakeOIS implements NullaryFunction<OvernightIndexedSwap> {
  constructor(
      swapTenor: Period, overnightIndex: OvernightIndex, fixedRate?: Rate,
      forwardStart?: Period);
  receiveFixed(flag?: boolean): MakeOIS;
  withType(type: OvernightIndexedSwap.Type): MakeOIS;
  withNominal(n: Real): MakeOIS;
  withSettlementDays(settlementDays: Natural): MakeOIS;
  withEffectiveDate(effectiveDate: Date): MakeOIS;
  withTerminationDate(terminationDate: Date): MakeOIS;
  withRule(r: DateGeneration.Rule): MakeOIS;
  withPaymentFrequency(f: Frequency): MakeOIS;
  withPaymentAdjustment(convention: BusinessDayConvention): MakeOIS;
  withPaymentLag(lag: Natural): MakeOIS;
  withPaymentCalendar(cal: Calendar): MakeOIS;
  withEndOfMonth(flag?: boolean): MakeOIS;
  withFixedLegDayCount(dc: DayCounter): MakeOIS;
  withOvernightLegSpread(sp: Spread): MakeOIS;
  withDiscountingTermStructure(d: Handle<YieldTermStructure>): MakeOIS;
  withTelescopicValueDates(telescopicValueDates: boolean): MakeOIS;
  withPricingEngine(engine: PricingEngine): MakeOIS;
  f(): OvernightIndexedSwap;
  private _swapTenor;
  private _overnightIndex;
  private _fixedRate;
  private _forwardStart;
  private _settlementDays;
  private _effectiveDate;
  private _terminationDate;
  private _calendar;
  private _paymentFrequency;
  private _paymentCalendar;
  private _paymentAdjustment;
  private _paymentLag;
  private _rule;
  private _endOfMonth;
  private _isDefaultEOM;
  private _type;
  private _nominal;
  private _overnightSpread;
  private _fixedDayCount;
  private _engine;
  private _telescopicValueDates;
}

export declare class MakeSwaption implements NullaryFunction<Swaption> {
  init1(swapIndex: SwapIndex, optionTenor: Period, strike?: Rate): MakeSwaption;
  init2(swapIndex: SwapIndex, fixingDate: Date, strike?: Rate): MakeSwaption;
  withSettlementType(delivery: Settlement.Type): MakeSwaption;
  withOptionConvention(bdc: BusinessDayConvention): MakeSwaption;
  withExerciseDate(date: Date): MakeSwaption;
  withUnderlyingType(type: VanillaSwap.Type): MakeSwaption;
  withPricingEngine(engine: PricingEngine): MakeSwaption;
  f(): Swaption;
  private _swapIndex;
  private _delivery;
  private _underlyingSwap;
  private _optionTenor;
  private _optionConvention;
  private _fixingDate;
  private _exerciseDate;
  private _exercise;
  private _strike;
  private _underlyingType;
  private _engine;
}

export declare class MakeVanillaSwap implements NullaryFunction<VanillaSwap> {
  constructor(
      swapTenor: Period, index: IborIndex, fixedRate?: Rate,
      forwardStart?: Period);
  f(): VanillaSwap;
  receiveFixed(flag?: boolean): MakeVanillaSwap;
  withType(type: VanillaSwap.Type): MakeVanillaSwap;
  withNominal(n: Real): MakeVanillaSwap;
  withSettlementDays(settlementDays: Natural): MakeVanillaSwap;
  withEffectiveDate(effectiveDate: Date): MakeVanillaSwap;
  withTerminationDate(terminationDate: Date): MakeVanillaSwap;
  withRule(r: DateGeneration.Rule): MakeVanillaSwap;
  withFixedLegTenor(t: Period): MakeVanillaSwap;
  withFixedLegCalendar(cal: Calendar): MakeVanillaSwap;
  withFixedLegConvention(bdc: BusinessDayConvention): MakeVanillaSwap;
  withFixedLegTerminationDateConvention(bdc: BusinessDayConvention):
      MakeVanillaSwap;
  withFixedLegRule(r: DateGeneration.Rule): MakeVanillaSwap;
  withFixedLegEndOfMonth(flag?: boolean): MakeVanillaSwap;
  withFixedLegFirstDate(d: Date): MakeVanillaSwap;
  withFixedLegNextToLastDate(d: Date): MakeVanillaSwap;
  withFixedLegDayCount(dc: DayCounter): MakeVanillaSwap;
  withFloatingLegTenor(t: Period): MakeVanillaSwap;
  withFloatingLegCalendar(cal: Calendar): MakeVanillaSwap;
  withFloatingLegConvention(bdc: BusinessDayConvention): MakeVanillaSwap;
  withFloatingLegTerminationDateConvention(bdc: BusinessDayConvention):
      MakeVanillaSwap;
  withFloatingLegRule(r: DateGeneration.Rule): MakeVanillaSwap;
  withFloatingLegEndOfMonth(flag?: boolean): MakeVanillaSwap;
  withFloatingLegFirstDate(d: Date): MakeVanillaSwap;
  withFloatingLegNextToLastDate(d: Date): MakeVanillaSwap;
  withFloatingLegDayCount(dc: DayCounter): MakeVanillaSwap;
  withFloatingLegSpread(sp: Spread): MakeVanillaSwap;
  withDiscountingTermStructure(d: Handle<YieldTermStructure>): MakeVanillaSwap;
  withPricingEngine(engine: PricingEngine): MakeVanillaSwap;
  private _swapTenor;
  private _iborIndex;
  private _fixedRate;
  private _forwardStart;
  private _settlementDays;
  private _effectiveDate;
  private _terminationDate;
  private _fixedCalendar;
  private _floatCalendar;
  private _type;
  private _nominal;
  private _fixedTenor;
  private _floatTenor;
  private _fixedConvention;
  private _fixedTerminationDateConvention;
  private _floatConvention;
  private _floatTerminationDateConvention;
  private _fixedRule;
  private _floatRule;
  private _fixedEndOfMonth;
  private _floatEndOfMonth;
  private _fixedFirstDate;
  private _fixedNextToLastDate;
  private _floatFirstDate;
  private _floatNextToLastDate;
  private _floatSpread;
  private _fixedDayCount;
  private _floatDayCount;
  private _engine;
}

export declare class MakeYoYInflationCapFloor implements
    NullaryFunction<YoYInflationCapFloor> {
  constructor(
      capFloorType: YoYInflationCapFloor.Type, length: Size, cal: Calendar,
      index: YoYInflationIndex, observationLag: Period, strike?: Rate,
      forwardStart?: Period);
  withNominal(n: Real): MakeYoYInflationCapFloor;
  withEffectiveDate(effectiveDate: Date): MakeYoYInflationCapFloor;
  withFirstCapletExcluded(): MakeYoYInflationCapFloor;
  withPaymentDayCounter(dc: DayCounter): MakeYoYInflationCapFloor;
  withPaymentAdjustment(bdc: BusinessDayConvention): MakeYoYInflationCapFloor;
  withFixingDays(n: Natural): MakeYoYInflationCapFloor;
  asOptionlet(b?: boolean): MakeYoYInflationCapFloor;
  withPricingEngine(engine: PricingEngine): MakeYoYInflationCapFloor;
  f(): YoYInflationCapFloor;
  private _capFloorType;
  private _length;
  private _calendar;
  private _index;
  private _observationLag;
  private _strike;
  private _firstCapletExcluded;
  private _asOptionlet;
  private _effectiveDate;
  private _forwardStart;
  private _dayCounter;
  private _roll;
  private _fixingDays;
  private _nominal;
  private _engine;
}

export declare class MultiAssetOption extends Option {
  constructor(payoff: Payoff, exercise: Exercise);
  delta(): Real;
  gamma(): Real;
  theta(): Real;
  vega(): Real;
  rho(): Real;
  dividendRho(): Real;
  setupArguments(args: PricingEngine.Arguments): void;
  fetchResults(r: PricingEngine.Results): void;
  setupExpired(): void;
  isExpired(): boolean;
  protected _delta: Real;
  protected _gamma: Real;
  protected _theta: Real;
  protected _vega: Real;
  protected _rho: Real;
  protected _dividendRho: Real;
}
export declare namespace MultiAssetOption {
  class Results extends InstrumentResultsGreeks {
    reset(): void;
  }
  class Arguments extends Option.Arguments {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class NonstandardSwap extends Swap {
  nssInit1(fromVanilla: VanillaSwap): NonstandardSwap;
  nssInit2(
      type: VanillaSwap.Type, fixedNominal: Real[], floatingNominal: Real[],
      fixedSchedule: Schedule, fixedRate: Real[], fixedDayCount: DayCounter,
      floatingSchedule: Schedule, iborIndex: IborIndex, gearing: Real,
      spread: Spread, floatingDayCount: DayCounter,
      intermediateCapitalExchange?: boolean, finalCapitalExchange?: boolean,
      paymentConvention?: BusinessDayConvention): NonstandardSwap;
  nssInit3(
      type: VanillaSwap.Type, fixedNominal: Real[], floatingNominal: Real[],
      fixedSchedule: Schedule, fixedRate: Real[], fixedDayCount: DayCounter,
      floatingSchedule: Schedule, iborIndex: IborIndex, gearing: Real[],
      spread: Spread[], floatingDayCount: DayCounter,
      intermediateCapitalExchange?: boolean, finalCapitalExchange?: boolean,
      paymentConvention?: BusinessDayConvention): NonstandardSwap;
  type(): VanillaSwap.Type;
  fixedNominal(): Real[];
  floatingNominal(): Real[];
  fixedSchedule(): Schedule;
  fixedRate(): Real[];
  fixedDayCount(): DayCounter;
  floatingSchedule(): Schedule;
  iborIndex(): IborIndex;
  spread(): Spread;
  gearing(): Real;
  spreads(): Spread[];
  gearings(): Real[];
  floatingDayCount(): DayCounter;
  paymentConvention(): BusinessDayConvention;
  fixedLeg(): Leg;
  floatingLeg(): Leg;
  setupExpired(): void;
  setupArguments(args: PricingEngine.Arguments): void;
  fetchResults(r: PricingEngine.Results): void;
  private _init;
  private _type;
  private _fixedNominal;
  private _floatingNominal;
  private _fixedSchedule;
  private _fixedRate;
  private _fixedDayCount;
  private _floatingSchedule;
  private _iborIndex;
  private _spread;
  private _gearing;
  private _singleSpreadAndGearing;
  private _floatingDayCount;
  private _paymentConvention;
  private _intermediateCapitalExchange;
  private _finalCapitalExchange;
}
export declare namespace NonstandardSwap {
  class Arguments extends Swap.Arguments {
    constructor();
    validate(): void;
    type: VanillaSwap.Type;
    fixedNominal: Real[];
    floatingNominal: Real[];
    fixedResetDates: Date[];
    fixedPayDates: Date[];
    floatingAccrualTimes: Time[];
    floatingResetDates: Date[];
    floatingFixingDates: Date[];
    floatingPayDates: Date[];
    fixedCoupons: Real[];
    fixedRate: Real[];
    floatingSpreads: Spread[];
    floatingGearings: Real[];
    floatingCoupons: Real[];
    iborIndex: IborIndex;
    fixedIsRedemptionFlow: boolean[];
    floatingIsRedemptionFlow: boolean[];
  }
  class Results extends Swap.Results {
    reset(): void;
  }
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class NonstandardSwaption extends Option {
  nssInit1(fromSwaption: Swaption): NonstandardSwaption;
  nssInit2(
      swap: NonstandardSwap, exercise: Exercise,
      delivery?: Settlement.Type): NonstandardSwaption;
  type(): VanillaSwap.Type;
  underlyingSwap(): NonstandardSwap;
  calibrationBasket(
      standardSwapBase: SwapIndex,
      swaptionVolatility: SwaptionVolatilityStructure,
      basketType?: BasketGeneratingEngine.CalibrationBasketType):
      CalibrationHelper[];
  isExpired(): boolean;
  setupArguments(args: PricingEngine.Arguments): void;
  private _swap;
  private _settlementType;
}
export declare namespace NonstandardSwaption {
  class Arguments extends Option.Arguments {
    constructor();
    validate(): void;
    swap: NonstandardSwap;
    settlementType: Settlement.Type;
  }
  class Results extends Option.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class OneAssetOption extends Option {
  constructor(payoff: Payoff, exercise: Exercise);
  isExpired(): boolean;
  delta(): Real;
  deltaForward(): Real;
  elasticity(): Real;
  gamma(): Real;
  theta(): Real;
  thetaPerDay(): Real;
  vega(): Real;
  rho(): Real;
  dividendRho(): Real;
  strikeSensitivity(): Real;
  itmCashProbability(): Real;
  fetchResults(r: PricingEngine.Results): void;
  setupExpired(): void;
  protected _delta: Real;
  protected _deltaForward: Real;
  protected _elasticity: Real;
  protected _gamma: Real;
  protected _theta: Real;
  protected _thetaPerDay: Real;
  protected _vega: Real;
  protected _rho: Real;
  protected _dividendRho: Real;
  protected _strikeSensitivity: Real;
  protected _itmCashProbability: Real;
}
export declare namespace OneAssetOption {
  class Results extends ResultsGreeksMoreGreeks {
    reset(): void;
  }
  class Arguments extends Option.Arguments {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class OvernightIndexedSwap extends Swap {
  constructor();
  oisInit1(
      type: OvernightIndexedSwap.Type, nominal: Real, schedule: Schedule,
      fixedRate: Rate, fixedDC: DayCounter, overnightIndex: OvernightIndex,
      spread: Spread, paymentLag: Natural,
      paymentAdjustment: BusinessDayConvention, paymentCalendar: Calendar,
      telescopicValueDates: boolean): OvernightIndexedSwap;
  oisInit2(
      type: OvernightIndexedSwap.Type, nominals: Real[], schedule: Schedule,
      fixedRate: Rate, fixedDC: DayCounter, overnightIndex: OvernightIndex,
      spread: Spread, paymentLag: Natural,
      paymentAdjustment: BusinessDayConvention, paymentCalendar: Calendar,
      telescopicValueDates: boolean): OvernightIndexedSwap;
  type(): OvernightIndexedSwap.Type;
  nominal(): Real;
  nominals(): Real[];
  paymentFrequency(): Frequency;
  fixedRate(): Rate;
  fixedDayCount(): DayCounter;
  spread(): Spread;
  fixedLeg(): Leg;
  overnightLeg(): Leg;
  overnightIndex(): OvernightIndex;
  fixedLegBPS(): Real;
  overnightLegBPS(): Real;
  fixedLegNPV(): Real;
  overnightLegNPV(): Real;
  fairRate(): Real;
  fairSpread(): Real;
  private initialize;
  private _type;
  private _nominals;
  private _paymentFrequency;
  private _paymentCalendar;
  private _paymentAdjustment;
  private _paymentLag;
  private _fixedRate;
  private _fixedDC;
  private _overnightIndex;
  private _spread;
  private _telescopicValueDates;
}
export declare namespace OvernightIndexedSwap {
  enum Type { Receiver = -1, Payer = 1 }
}

export declare class NullPayoff extends Payoff {
  name(): string;
  description(): string;
  f(x: Real): Real;
  accept(v: AcyclicVisitor): void;
}
export declare class TypePayoff extends Payoff {
  constructor(type: Option.Type);
  description(): string;
  optionType(): Option.Type;
  protected _type: Option.Type;
}
export declare class FloatingTypePayoff extends TypePayoff {
  name(): string;
  f(x: Real): Real;
  accept(v: AcyclicVisitor): void;
}
export declare class StrikedTypePayoff extends TypePayoff {
  constructor(type: Option.Type, strike: Real);
  description(): string;
  strike(): Real;
  protected _strike: Real;
}
export declare class PlainVanillaPayoff extends StrikedTypePayoff {
  name(): string;
  f(price: Real): Real;
  accept(v: AcyclicVisitor): void;
}
export declare class PercentageStrikePayoff extends StrikedTypePayoff {
  name(): string;
  f(price: Real): Real;
  accept(v: AcyclicVisitor): void;
}
export declare class AssetOrNothingPayoff extends StrikedTypePayoff {
  name(): string;
  f(price: Real): Real;
  accept(v: AcyclicVisitor): void;
}
export declare class CashOrNothingPayoff extends StrikedTypePayoff {
  constructor(type: Option.Type, strike: Real, cashPayoff: Real);
  name(): string;
  description(): string;
  f(price: Real): Real;
  accept(v: AcyclicVisitor): void;
  cashPayoff(): Real;
  protected _cashPayoff: Real;
}
export declare class GapPayoff extends StrikedTypePayoff {
  constructor(type: Option.Type, strike: Real, secondStrike: Real);
  name(): string;
  description(): string;
  f(price: Real): Real;
  accept(v: AcyclicVisitor): void;
  secondStrike(): Real;
  protected _secondStrike: Real;
}
export declare class SuperFundPayoff extends StrikedTypePayoff {
  constructor(strike: Real, secondStrike: Real);
  name(): string;
  f(price: Real): Real;
  accept(v: AcyclicVisitor): void;
  secondStrike(): Real;
  protected _secondStrike: Real;
}
export declare class SuperSharePayoff extends StrikedTypePayoff {
  constructor(strike: Real, secondStrike: Real, cashPayoff: Real);
  name(): string;
  description(): string;
  f(price: Real): Real;
  accept(v: AcyclicVisitor): void;
  secondStrike(): Real;
  cashPayoff(): Real;
  protected _secondStrike: Real;
  protected _cashPayoff: Real;
}

export declare class QuantoBarrierOption extends BarrierOption {
  constructor(
      barrierType: Barrier.Type, barrier: Real, rebate: Real,
      payoff: StrikedTypePayoff, exercise: Exercise);
  qvega(): Real;
  qrho(): Real;
  qlambda(): Real;
  fetchResults(r: PricingEngine.Results): void;
  setupExpired(): void;
  private _qvega;
  private _qrho;
  private _qlambda;
}
export declare namespace QuantoBarrierOptionEngine {
  class Arguments extends BarrierOptionEngine.Arguments {}
  class Results extends QuantoOptionResults {
    constructor();
  }
}

export declare class QuantoForwardVanillaOption extends ForwardVanillaOption {
  constructor(
      moneyness: Real, resetDate: Date, payoff: StrikedTypePayoff,
      exercise: Exercise);
  qvega(): Real;
  qrho(): Real;
  qlambda(): Real;
  fetchResults(r: PricingEngine.Results): void;
  setupExpired(): void;
  private _qvega;
  private _qrho;
  private _qlambda;
}
export declare namespace QuantoForwardVanillaOptionEngine {
  class Arguments extends ForwardVanillaOption.Arguments {}
  class Results extends QuantoOptionResults {
    constructor();
  }
}

export declare class QuantoOptionResults extends Instrument.Results {
  constructor(ResultsType: Instrument.Results);
  reset(): void;
  ResultsType: Instrument.Results;
  qvega: Real;
  qrho: Real;
  qlambda: Real;
}
export declare class QuantoVanillaOption extends OneAssetOption {
  constructor(payoff: StrikedTypePayoff, exercise: Exercise);
  qvega(): Real;
  qrho(): Real;
  qlambda(): Real;
  fetchResults(r: PricingEngine.Results): void;
  setupExpired(): void;
  private _qvega;
  private _qrho;
  private _qlambda;
}
export declare namespace QuantoVanillaOptionEngine {
  class Arguments extends OneAssetOption.Arguments {}
  class Results extends QuantoOptionResults {
    constructor();
  }
  class engine extends OneAssetOption.engine {}
}

export declare class DoubleStickyRatchetPayoff extends Payoff {
  constructor(
      type1: Real, type2: Real, gearing1: Real, gearing2: Real, gearing3: Real,
      spread1: Real, spread2: Real, spread3: Real, initialValue1: Real,
      initialValue2: Real, accrualFactor: Real);
  name(): string;
  description(): string;
  f(forward: Real): Real;
  accept(v: AcyclicVisitor): void;
  protected _type1: Real;
  protected _type2: Real;
  protected _gearing1: Real;
  protected _gearing2: Real;
  protected _gearing3: Real;
  protected _spread1: Real;
  protected _spread2: Real;
  protected _spread3: Real;
  protected _initialValue1: Real;
  protected _initialValue2: Real;
  protected _accrualFactor: Real;
}
export declare class RatchetPayoff extends DoubleStickyRatchetPayoff {
  constructor(
      gearing1: Real, gearing2: Real, spread1: Real, spread2: Real,
      initialValue: Real, accrualFactor: Real);
  name(): string;
}
export declare class StickyPayoff extends DoubleStickyRatchetPayoff {
  constructor(
      gearing1: Real, gearing2: Real, spread1: Real, spread2: Real,
      initialValue: Real, accrualFactor: Real);
  name(): string;
}
export declare class RatchetMaxPayoff extends DoubleStickyRatchetPayoff {
  constructor(
      gearing1: Real, gearing2: Real, gearing3: Real, spread1: Real,
      spread2: Real, spread3: Real, initialValue1: Real, initialValue2: Real,
      accrualFactor: Real);
  name(): string;
}
export declare class RatchetMinPayoff extends DoubleStickyRatchetPayoff {
  constructor(
      gearing1: Real, gearing2: Real, gearing3: Real, spread1: Real,
      spread2: Real, spread3: Real, initialValue1: Real, initialValue2: Real,
      accrualFactor: Real);
  name(): string;
}
export declare class StickyMaxPayoff extends DoubleStickyRatchetPayoff {
  constructor(
      gearing1: Real, gearing2: Real, gearing3: Real, spread1: Real,
      spread2: Real, spread3: Real, initialValue1: Real, initialValue2: Real,
      accrualFactor: Real);
  name(): string;
}
export declare class StickyMinPayoff extends DoubleStickyRatchetPayoff {
  constructor(
      gearing1: Real, gearing2: Real, gearing3: Real, spread1: Real,
      spread2: Real, spread3: Real, initialValue1: Real, initialValue2: Real,
      accrualFactor: Real);
  name(): string;
}

export declare class Stock extends Instrument {
  constructor(quote: Handle<Quote>);
  isExpired(): boolean;
  performCalculations(): void;
  private _quote;
}

export declare class Swap extends Instrument {
  init1(firstLeg: Leg, secondLeg: Leg): Swap;
  init2(legs: Leg[], payer: boolean[]): Swap;
  init3(legs: Size): Swap;
  startDate(): Date;
  maturityDate(): Date;
  legBPS(j: Size): Real;
  legNPV(j: Size): Real;
  startDiscounts(j: Size): DiscountFactor;
  endDiscounts(j: Size): DiscountFactor;
  npvDateDiscount(): DiscountFactor;
  leg(j: Size): Leg;
  isExpired(): boolean;
  setupArguments(args: PricingEngine.Arguments): void;
  fetchResults(r: PricingEngine.Results): void;
  setupExpired(): void;
  protected _legs: Leg[];
  protected _payer: Real[];
  protected _legNPV: Real[];
  protected _legBPS: Real[];
  protected _startDiscounts: DiscountFactor[];
  protected _endDiscounts: DiscountFactor[];
  protected _npvDateDiscount: DiscountFactor;
}
export declare namespace Swap {
  class Arguments extends PricingEngine.Arguments {
    legs: Leg[];
    payer: Real[];
    validate(): void;
  }
  class Results extends Instrument.Results {
    legNPV: Real[];
    legBPS: Real[];
    startDiscounts: DiscountFactor[];
    endDiscounts: DiscountFactor[];
    npvDateDiscount: DiscountFactor;
    reset(): void;
  }
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class Swaption extends Option {
  constructor(
      swap: VanillaSwap, exercise: Exercise, delivery?: Settlement.Type,
      settlementMethod?: Settlement.Method);
  isExpired(): boolean;
  settlementType(): Settlement.Type;
  settlementMethod(): Settlement.Method;
  type(): VanillaSwap.Type;
  underlyingSwap(): VanillaSwap;
  impliedVolatility(
      price: Real, discountCurve: Handle<YieldTermStructure>, guess: Volatility,
      accuracy: Real, maxEvaluations: Natural, minVol?: Volatility,
      maxVol?: Volatility, type?: VolatilityType,
      displacement?: Real): Volatility;
  setupArguments(args: PricingEngine.Arguments): void;
  private _swap;
  private _settlementType;
  private _settlementMethod;
}
export declare namespace Settlement {
  enum Type { Physical = 0, Cash = 1 }
  enum Method {
    PhysicalOTC = 0,
    PhysicalCleared = 1,
    CollateralizedCashPrice = 2,
    ParYieldCurve = 3
  }
  function checkTypeAndMethodConsistency(
      settlementType: Settlement.Type,
      settlementMethod: Settlement.Method): void;
}

export declare namespace SwaptionEngine {
  class Arguments extends VanillaSwapOptionArguments {
    constructor();
    validate(): void;
    swap: VanillaSwap;
    settlementType: Settlement.Type;
    settlementMethod: Settlement.Method;
  }
  class Results extends Option.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class VanillaOption extends OneAssetOption {
  constructor(payoff: StrikedTypePayoff, exercise: Exercise);
  impliedVolatility(
      targetValue: Real, process: GeneralizedBlackScholesProcess,
      accuracy?: Real, maxEvaluations?: Size, minVol?: Volatility,
      maxVol?: Volatility): Volatility;
}

export declare namespace VanillaOptionEngine {
  class engine extends OneAssetOption.engine {
    constructor();
  }
  class Arguments extends OneAssetOption.Arguments {}
  class Results extends OneAssetOption.Results {}
}

export declare class VanillaStorageOption extends OneAssetOption {
  constructor(
      ex: BermudanExercise, capacity: Real, load: Real, changeRate: Real);
  isExpired(): boolean;
  setupArguments(args: PricingEngine.Arguments): void;
  private _capacity;
  private _load;
  private _changeRate;
}
export declare namespace VanillaStorageOption {
  class Arguments extends PricingEngine.Arguments {
    constructor();
    validate(): void;
    capacity: Real;
    load: Real;
    changeRate: Real;
    payoff: NullPayoff;
    exercise: BermudanExercise;
  }
  class Results extends OneAssetOption.Results {}
}

export declare class VanillaSwap extends Swap {
  constructor(
      type: VanillaSwap.Type, nominal: Real, fixedSchedule: Schedule,
      fixedRate: Rate, fixedDayCount: DayCounter, floatSchedule: Schedule,
      iborIndex: IborIndex, spread: Spread, floatingDayCount: DayCounter,
      paymentConvention?: BusinessDayConvention);
  type(): VanillaSwap.Type;
  nominal(): Real;
  fixedSchedule(): Schedule;
  fixedRate(): Rate;
  fixedDayCount(): DayCounter;
  floatingSchedule(): Schedule;
  iborIndex(): IborIndex;
  spread(): Spread;
  floatingDayCount(): DayCounter;
  paymentConvention(): BusinessDayConvention;
  fixedLeg(): Leg;
  floatingLeg(): Leg;
  fixedLegBPS(): Real;
  fixedLegNPV(): Real;
  fairRate(): Rate;
  floatingLegBPS(): Real;
  floatingLegNPV(): Real;
  fairSpread(): Spread;
  setupArguments(args: PricingEngine.Arguments): void;
  fetchResults(r: PricingEngine.Results): void;
  setupExpired(): void;
  private _type;
  private _nominal;
  private _fixedSchedule;
  private _fixedRate;
  private _fixedDayCount;
  private _floatingSchedule;
  private _iborIndex;
  private _spread;
  private _floatingDayCount;
  private _paymentConvention;
  private _fairRate;
  private _fairSpread;
}
export declare namespace VanillaSwap {
  enum Type { Receiver = -1, Payer = 1 }
  class Results extends Swap.Results {
    fairRate: Rate;
    fairSpread: Spread;
    reset(): void;
  }
  class Arguments extends Swap.Arguments {
    constructor();
    validate(): void;
    type: Type;
    nominal: Real;
    fixedResetDates: Date[];
    fixedPayDates: Date[];
    floatingAccrualTimes: Time[];
    floatingResetDates: Date[];
    floatingFixingDates: Date[];
    floatingPayDates: Date[];
    fixedCoupons: Real[];
    floatingSpreads: Spread[];
    floatingCoupons: Real[];
  }
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class SwingExercise extends BermudanExercise {
  seInit1(dates: Date[], seconds?: Size[]): SwingExercise;
  seInit2(from: Date, to: Date, stepSizeSecs: Size): SwingExercise;
  seconds(): Size[];
  exerciseTimes(dc: DayCounter, refDate: Date): Time[];
  private _seconds;
}
export declare class VanillaForwardPayoff extends StrikedTypePayoff {
  constructor(type: Option.Type, strike: Real);
  name(): string;
  f(price: Real): Real;
  accept(v: AcyclicVisitor): void;
}
export declare class VanillaSwingOption extends OneAssetOption {
  constructor(
      payoff: Payoff, ex: SwingExercise, minExerciseRights: Size,
      maxExerciseRights: Size);
  isExpired(): boolean;
  setupArguments(args: PricingEngine.Arguments): void;
  private _minExerciseRights;
  private _maxExerciseRights;
}
export declare namespace VanillaSwingOption {
  class Results extends OneAssetOption.Results {}
  class Arguments extends OneAssetOption.Results {
    validate(): void;
    minExerciseRights: Size;
    maxExerciseRights: Size;
    payoff: StrikedTypePayoff;
    exercise: SwingExercise;
  }
}

export declare class VarianceSwap extends Instrument {
  constructor(
      position: Position.Type, strike: Real, notional: Real, startDate: Date,
      maturityDate: Date);
  strike(): Real;
  position(): Position.Type;
  startDate(): Date;
  maturityDate(): Date;
  notional(): Real;
  variance(): Real;
  isExpired(): boolean;
  setupExpired(): void;
  setupArguments(args: PricingEngine.Arguments): void;
  fetchResults(r: PricingEngine.Results): void;
  protected _position: Position.Type;
  protected _strike: Real;
  protected _notional: Real;
  protected _startDate: Date;
  protected _maturityDate: Date;
  protected _variance: Real;
}
export declare namespace VarianceSwap {
  class Arguments extends PricingEngine.Arguments {
    constructor();
    validate(): void;
    position: Position.Type;
    strike: Real;
    notional: Real;
    startDate: Date;
    maturityDate: Date;
  }
  class Results extends Instrument.Results {
    reset(): void;
    variance: Real;
  }
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class YearOnYearInflationSwap extends Swap {
  constructor(
      type: YearOnYearInflationSwap.Type, nominal: Real,
      fixedSchedule: Schedule, fixedRate: Rate, fixedDayCount: DayCounter,
      yoySchedule: Schedule, yoyIndex: YoYInflationIndex,
      observationLag: Period, spread: Spread, yoyDayCount: DayCounter,
      paymentCalendar: Calendar, paymentConvention?: BusinessDayConvention);
  fixedLegNPV(): Real;
  fairRate(): Rate;
  yoyLegNPV(): Real;
  faireSpread(): Spread;
  type(): YearOnYearInflationSwap.Type;
  nominal(): Real;
  fixedSchedule(): Schedule;
  fixedRate(): Rate;
  fixedDayCount(): DayCounter;
  yoySchedule(): Schedule;
  yoyInflationIndex(): YoYInflationIndex;
  observationLag(): Period;
  spread(): Spread;
  yoyDayCount(): DayCounter;
  paymentCalendar(): Calendar;
  paymentConvention(): BusinessDayConvention;
  fixedLeg(): Leg;
  yoyLeg(): Leg;
  setupExpired(): void;
  setupArguments(args: PricingEngine.Arguments): void;
  fetchResults(r: PricingEngine.Results): void;
  private _type;
  private _nominal;
  private _fixedSchedule;
  private _fixedRate;
  private _fixedDayCount;
  private _yoySchedule;
  private _yoyIndex;
  private _observationLag;
  private _spread;
  private _yoyDayCount;
  private _paymentCalendar;
  private _paymentConvention;
  private _fairRate;
  private _fairSpread;
}
export declare namespace YearOnYearInflationSwap {
  enum Type { Receiver = -1, Payer = 1 }
  class Arguments extends Swap.Arguments {
    constructor();
    validate(): void;
    type: Type;
    nominal: Real;
    fixedResetDates: Date[];
    fixedPayDates: Date[];
    yoyAccrualTimes: Time[];
    yoyResetDates: Date[];
    yoyFixingDates: Date[];
    yoyPayDates: Date[];
    fixedCoupons: Real[];
    yoySpreads: Spread[];
    yoyCoupons: Real[];
  }
  class Results extends Swap.Results {
    reset(): void;
    fairRate: Rate;
    fairSpread: Spread;
  }
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class ZeroCouponInflationSwap extends Swap {
  constructor(
      type: ZeroCouponInflationSwap.Type, nominal: Real, startDate: Date,
      maturity: Date, fixCalendar: Calendar,
      fixConvention: BusinessDayConvention, dayCounter: DayCounter,
      fixedRate: Rate, infIndex: ZeroInflationIndex, observationLag: Period,
      adjustInfObsDates?: boolean, infCalendar?: Calendar,
      infConvention?: BusinessDayConvention);
  type(): ZeroCouponInflationSwap.Type;
  nominal(): Real;
  startDate(): Date;
  maturityDate(): Date;
  fixedCalendar(): Calendar;
  fixedConvention(): BusinessDayConvention;
  dayCounter(): DayCounter;
  fixedRate(): Rate;
  inflationIndex(): ZeroInflationIndex;
  observationLag(): Period;
  adjustObservationDates(): boolean;
  inflationCalendar(): Calendar;
  inflationConvention(): BusinessDayConvention;
  fixedLegNPV(): Real;
  inflationLegNPV(): Real;
  fairRate(): Real;
  fixedLeg(): Leg;
  inflationLeg(): Leg;
  setupArguments(args: PricingEngine.Arguments): void;
  fetchResults(r: PricingEngine.Results): void;
  protected _type: ZeroCouponInflationSwap.Type;
  protected _nominal: Real;
  protected _startDate: Date;
  protected _maturityDate: Date;
  protected _fixCalendar: Calendar;
  protected _fixConvention: BusinessDayConvention;
  protected _fixedRate: Rate;
  protected _infIndex: ZeroInflationIndex;
  protected _observationLag: Period;
  protected _adjustInfObsDates: boolean;
  protected _infCalendar: Calendar;
  protected _infConvention: BusinessDayConvention;
  protected _dayCounter: DayCounter;
  protected _baseDate: Date;
  protected _obsDate: Date;
}
export declare namespace ZeroCouponInflationSwap {
  enum Type { Receiver = -1, Payer = 1 }
  class Arguments extends Swap.Arguments {
    validate(): void;
    fixedRate: Rate;
  }
  class Results extends Swap.Results {}
  class engine extends GenericEngine<Arguments, Results> {
    constructor();
  }
}

export declare class CCTEU extends FloatingRateBond {
  constructor(
      maturityDate: Date, spread: Spread, fwdCurve?: Handle<YieldTermStructure>,
      startDate?: Date, issueDate?: Date);
  accruedAmount(d?: Date): Real;
}
export declare class BTP extends FixedRateBond {
  btpInit1(
      maturityDate: Date, fixedRate: Rate, startDate?: Date,
      issueDate?: Date): BTP;
  btpInit2(
      maturityDate: Date, fixedRate: Rate, redemption: Real, startDate?: Date,
      issueDate?: Date): BTP;
  accruedAmount(d?: Date): Real;
  yield3(
      cleanPrice: Real, settlementDate?: Date, accuracy?: Real,
      maxEvaluations?: Size): Rate;
}
export declare class RendistatoBasket extends ObserverObservable {
  constructor(
      btps: BTP[], outstandings: Real[],
      cleanPriceQuotes: Array<Handle<Quote>>);
  size(): Size;
  btps(): BTP[];
  cleanPriceQuotes(): Array<Handle<Quote>>;
  outstandings(): Real[];
  weights(): Real[];
  outstanding(): Real;
  update(): void;
  private _btps;
  private _outstandings;
  private _quotes;
  private _outstanding;
  private _n;
  private _weights;
}
export declare class RendistatoCalculator extends LazyObject {
  constructor(
      basket: RendistatoBasket, euriborIndex: Euribor,
      discountCurve: Handle<YieldTermStructure>);
  yield(): Rate;
  duration(): Time;
  yields(): Rate[];
  durations(): Time[];
  swapLengths(): Time[];
  swapRates(): Rate[];
  swapYields(): Rate[];
  swapDurations(): Time[];
  equivalentSwap(): VanillaSwap;
  equivalentSwapRate(): Rate;
  equivalentSwapYield(): Rate;
  equivalentSwapDuration(): Time;
  equivalentSwapLength(): Time;
  equivalentSwapSpread(): Spread;
  performCalculations(): void;
  private _basket;
  private _euriborIndex;
  private _discountCurve;
  private _yields;
  private _durations;
  private _duration;
  private _equivalentSwapIndex;
  private _nSwaps;
  private _swaps;
  private _swapLenghts;
  private _swapBondDurations;
  private _swapBondYields;
  private _swapRates;
}
export declare class RendistatoEquivalentSwapLengthQuote extends Quote {
  constructor(r: RendistatoCalculator);
  value(): Real;
  isValid(): boolean;
  private _r;
}
export declare class RendistatoEquivalentSwapSpreadQuote extends Quote {
  constructor(r: RendistatoCalculator);
  value(): Real;
  isValid(): boolean;
  private _r;
}

export declare class CmsRateBond extends Bond {
  constructor(
      settlementDays: Natural, faceAmount: Real, schedule: Schedule,
      index: SwapIndex, paymentDayCounter: DayCounter,
      paymentConvention?: BusinessDayConvention, fixingDays?: Natural,
      gearings?: Real[], spreads?: Spread[], caps?: Rate[], floors?: Rate[],
      inArrears?: boolean, redemption?: Real, issueDate?: Date);
}

export declare class CPIBond extends Bond {
  constructor(
      settlementDays: Natural, faceAmount: Real, growthOnly: boolean,
      baseCPI: Real, observationLag: Period, cpiIndex: ZeroInflationIndex,
      observationInterpolation: CPI.InterpolationType, schedule: Schedule,
      fixedRate: Rate[], accrualDayCounter: DayCounter,
      paymentConvention?: BusinessDayConvention, issueDate?: Date,
      paymentCalendar?: Calendar, exCouponPeriod?: Period,
      exCouponCalendar?: Calendar, exCouponConvention?: BusinessDayConvention,
      exCouponEndOfMonth?: boolean);
  frequency(): Frequency;
  dayCounter(): DayCounter;
  growthOnly(): boolean;
  baseCPI(): Real;
  observationLag(): Period;
  cpiIndex(): ZeroInflationIndex;
  observationInterpolation(): CPI.InterpolationType;
  protected _frequency: Frequency;
  protected _dayCounter: DayCounter;
  protected _growthOnly: boolean;
  protected _baseCPI: Real;
  protected _observationLag: Period;
  protected _cpiIndex: ZeroInflationIndex;
  protected _observationInterpolation: CPI.InterpolationType;
}

export declare class FixedRateBond extends Bond {
  frbInit1(
      settlementDays: Natural, faceAmount: Real, schedule: Schedule,
      coupons: Rate[], accrualDayCounter: DayCounter,
      paymentConvention: BusinessDayConvention, redemption?: Real,
      issueDate?: Date, paymentCalendar?: Calendar, exCouponPeriod?: Period,
      exCouponCalendar?: Calendar, exCouponConvention?: BusinessDayConvention,
      exCouponEndOfMonth?: boolean): FixedRateBond;
  frbInit2(
      settlementDays: Natural, calendar: Calendar, faceAmount: Real,
      startDate: Date, maturityDate: Date, tenor: Period, coupons: Rate[],
      accrualDayCounter: DayCounter, accrualConvention?: BusinessDayConvention,
      paymentConvention?: BusinessDayConvention, redemption?: Real,
      issueDate?: Date, stubDate?: Date, rule?: DateGeneration.Rule,
      endOfMonth?: boolean, paymentCalendar?: Calendar, exCouponPeriod?: Period,
      exCouponCalendar?: Calendar, exCouponConvention?: BusinessDayConvention,
      exCouponEndOfMonth?: boolean): FixedRateBond;
  frbInit3(
      settlementDays: Natural, faceAmount: Real, schedule: Schedule,
      coupons: InterestRate[], paymentConvention?: BusinessDayConvention,
      redemption?: Real, issueDate?: Date, paymentCalendar?: Calendar,
      exCouponPeriod?: Period, exCouponCalendar?: Calendar,
      exCouponConvention?: BusinessDayConvention,
      exCouponEndOfMonth?: boolean): FixedRateBond;
  frequency(): Frequency;
  dayCounter(): DayCounter;
  protected _frequency: Frequency;
  protected _dayCounter: DayCounter;
}

export declare class FloatingRateBond extends Bond {
  frbInit1(
      settlementDays: Natural, faceAmount: Real, schedule: Schedule,
      iborIndex: IborIndex, accrualDayCounter: DayCounter,
      paymentConvention?: BusinessDayConvention, fixingDays?: Natural,
      gearings?: Real[], spreads?: Spread[], caps?: Rate[], floors?: Rate[],
      inArrears?: boolean, redemption?: Real,
      issueDate?: Date): FloatingRateBond;
  frbInit2(
      settlementDays: Natural, faceAmount: Real, startDate: Date,
      maturityDate: Date, couponFrequency: Frequency, calendar: Calendar,
      iborIndex: IborIndex, accrualDayCounter: DayCounter,
      accrualConvention?: BusinessDayConvention,
      paymentConvention?: BusinessDayConvention, fixingDays?: Natural,
      gearings?: Real[], spreads?: Spread[], caps?: Rate[], floors?: Rate[],
      inArrears?: boolean, redemption?: Real, issueDate?: Date, stubDate?: Date,
      rule?: DateGeneration.Rule, endOfMonth?: boolean): FloatingRateBond;
}

export declare class ZeroCouponBond extends Bond {
  constructor(
      settlementDays: Natural, calendar: Calendar, faceAmount: Real,
      maturityDate: Date, paymentConvention?: BusinessDayConvention,
      redemption?: Real, issueDate?: Date);
}

export declare class AbcdMathFunction implements UnaryFunction<Time, Real> {
  init1(a?: Real, b?: Real, c?: Real, d?: Real): AbcdMathFunction;
  init2(abcd: Real[]): AbcdMathFunction;
  f(t: Time): Real;
  maximumLocation(): Time;
  maximumValue(): Real;
  longTermValue(): Real;
  derivative(t: Time): Real;
  primitive1(t: Time): Real;
  definiteIntegral(t1: Time, t2: Time): Real;
  a(): Real;
  b(): Real;
  c(): Real;
  d(): Real;
  coefficients(): Real[];
  derivativeCoefficients(): Real[];
  definiteIntegralCoefficients(t: Time, t2: Time): Real[];
  definiteDerivativeCoefficients(t: Time, t2: Time): Real[];
  static validate(a: Real, b: Real, c: Real, d: Real): void;
  protected _a: Real;
  protected _b: Real;
  protected _c: Real;
  protected _d: Real;
  private _initialize;
  private _abcd;
  private _dabcd;
  private _da;
  private _db;
  private _pa;
  private _pb;
  private _K;
  private _dibc;
  private _diacplusbcc;
}

export declare namespace Array1D {
  function clear(a: any[]): void;
  function back<T>(a: T[]): T;
  function copy<T>(
      from: T[], to: T[], toStart?: Size, fromStart?: Size,
      fromEnd?: Size): void;
  function negate(a: Real[]): Real[];
  function sum(a: Real[]): Real;
  function partial_sum(
      input: Real[], inputBegin: Size, endBegin: Size, output: Real[],
      outputBegin: Size, bf: BinaryFunction<Real, Real, Real>): void;
  function partial_sort(
      a: any[], first: Size, middle: Size, last: Size,
      comp: BinaryFunction<any, any, number>): void;
  function insertArray<T>(a1: T[], start: Size, a2: T[]): void;
  function empty(a: any[]): boolean;
  function size(a: any[]): Size;
  function resize(a: any[], newSize: Size, defaultValue?: Real): void;
  function add(a1: Real[], a2: Real[]): Real[];
  function sub(a1: Real[], a2: Real[]): Real[];
  function mul(a1: Real[], a2: Real[]): Real[];
  function div(a1: Real[], a2: Real[]): Real[];
  function addScalar(a: Real[], s: Real): Real[];
  function subScalar(a: Real[], s: Real): Real[];
  function mulScalar(a: Real[], s: Real): Real[];
  function divScalar(a: Real[], s: Real): Real[];
  function fromSizeValue(size: Size, value: any): any[];
  function fromSizeValueIncrement(
      size: Size, value: Real, increment: Real): Real[];
  function equal(a1: Real[], a2: Real[], compFun?: Function): boolean;
  function clone(a: any[]): any[];
  function Abs(a: Real[]): Real[];
  function Sqrt(a: Real[]): Real[];
  function Log(a: Real[]): Real[];
  function Exp(a: Real[]): Real[];
  function Pow(a: Real[], alpha: Real): Real[];
  function DotProduct(v1: Real[], v2: Real[]): Real;
  function Norm2(v: Real[]): Real;
}

export declare function convolutions(
    forward: Complex[], begin: Size, end: Size, out: Real[],
    maxLag: Size): void;
export declare function autocovariances1(
    forward: Complex[], begin: Size, end: Size, out: Real[],
    maxLag: Size): void;
export declare function autocovariances2(
    forward: Complex[], begin: Size, end: Size, out: Real[], maxLag: Size,
    reuse: boolean): Real;
export declare function autocorrelations1(
    forward: Complex[], begin: Size, end: Size, out: Real[],
    maxLag: Size): void;
export declare function autocorrelations2(
    forward: Complex[], begin: Size, end: Size, out: Real[], maxLag: Size,
    reuse: boolean): Real;

export declare class BernsteinPolynomial {
  static get(i: Natural, n: Natural, x: Real): Real;
}

export declare function betaFunction(z: Real, w: Real): Real;
export declare function betaContinuedFraction(
    a: Real, b: Real, x: Real, accuracy?: Real, maxIteration?: Integer): Real;
export declare function incompleteBetaFunction(
    a: Real, b: Real, x: Real, accuracy?: Real, maxIteration?: Integer): Real;

export declare class BSpline implements BinaryFunction<Natural, Real, Real> {
  constructor(p: Natural, n: Natural, knots: Real[]);
  f(i: Natural, x: Real): Real;
  private N;
  private _p;
  private _n;
  private _knots;
}

export declare namespace Comparison {
  function close(x: Real, y: Real, n?: Size): boolean;
  function close_enough(x: Real, y: Real, n?: Size): boolean;
}

export declare class Curve implements UnaryFunction<Real, Real> {
  f(x: Real): Real;
}
export declare class TestCurve extends Curve {
  f(x: Real): Real;
}

export declare class ErrorFunction implements UnaryFunction<Real, Real> {
  f(x: Real): Real;
}

export declare class Factorial {
  static get(i: Natural): Real;
  static ln(i: Natural): Real;
}
export declare namespace Factorial {
  const firstFactorials: Real[];
  const tabulated: Size;
}

export declare class FastFourierTransform {
  constructor(order: Size);
  static min_order(inputSize: Size): Size;
  output_size(): Size;
  transform(input: Complex[], output: Complex[]): void;
  inverse_transform(input: Complex[], output: Complex[]): void;
  private transform_impl;
  static bit_reverse(x: Size, order: Size): Size;
  private _cs;
  private _sn;
}

export declare class constant<T, U> implements UnaryFunction<T, U> {
  constructor(u: U);
  f(t: T): U;
  private _u;
}
export declare class identity implements UnaryFunction<any, any> {
  f(t: any): any;
}
export declare class square implements UnaryFunction<Real, Real> {
  f(t: Real): Real;
}
export declare class sin implements UnaryFunction<Real, Real> {
  f(t: Real): Real;
}
export declare class cos implements UnaryFunction<Real, Real> {
  f(t: Real): Real;
}
export declare class cube implements UnaryFunction<Real, Real> {
  f(x: Real): Real;
}
export declare class fourth_power implements UnaryFunction<Real, Real> {
  f(x: Real): Real;
}
export declare class everywhere<T> implements UnaryFunction<T, boolean> {
  f(t: T): boolean;
}
export declare class nowhere<T> implements UnaryFunction<T, boolean> {
  f(t: T): boolean;
}
export declare class equal_within implements
    BinaryFunction<Real, Real, boolean> {
  constructor(eps: Real);
  f(a: Real, b: Real): boolean;
  private _eps;
}
export declare class clipped_function {}
export declare class composed_function {
  constructor(f: Function, g: Function);
  f(x: number): number;
  private _f;
  private _g;
}
export declare function compose(
    f: Function, g: Function): UnaryFunction<number, number>;
export declare function minus(x: Real): Real;
export declare const plus: BinaryFunction<Real, Real, Real>;
export declare const negate: UnaryFunction<Real, Real>;
export declare const multiplies: BinaryFunction<Real, Real, Real>;
export declare const divides: BinaryFunction<Real, Real, Real>;
export declare const modulus: BinaryFunction<Real, Real, Real>;

export declare class GeneralLinearLeastSquares {
  init(x: any[], y: Real[], v: Array<UnaryFunction<any, Real>>):
      GeneralLinearLeastSquares;
  coefficients(): Real[];
  residuals(): Real[];
  standardErrors(): Real[];
  error(): Real[];
  size(): Size;
  dim(): Size;
  calculate(x: any[], y: Real[], v: Array<UnaryFunction<any, Real>>): void;
  protected _a: Real[];
  protected _err: Real[];
  protected _residuals: Real[];
  protected _standardErrors: Real[];
}

export declare function incompleteGammaFunction(
    a: Real, x: Real, accuracy?: Real, maxIteration?: Integer): Real;
export declare function incompleteGammaFunctionSeriesRepr(
    a: Real, x: Real, accuracy?: Real, maxIteration?: Integer): Real;
export declare function incompleteGammaFunctionContinuedFractionRepr(
    a: Real, x: Real, accuracy?: Real, maxIteration?: Integer): Real;

export declare class ArrayProxy {}
export declare class MatrixProxy {}

export declare class Interpolation extends Extrapolator implements
    BinaryFunction<Real, boolean, Real> {
  empty(): boolean;
  f(x: Real, allowExtrapolation?: boolean): Real;
  primitive(x: Real, allowExtrapolation?: boolean): Real;
  derivative(x: Real, allowExtrapolation?: boolean): Real;
  secondDerivative(x: Real, allowExtrapolation?: boolean): Real;
  xMin(): Real;
  xMax(): Real;
  isInRange(x: Real): boolean;
  update(): void;
  protected checkRange(x: Real, extrapolate: boolean): void;
  protected _impl: Interpolation.Impl;
  getExistingHelpers(): any;
}
export declare namespace Interpolation {
  class Impl {
    update(): void;
    xMin(): Real;
    xMax(): Real;
    xValues(): Real[];
    yValues(): Real[];
    isInRange(x: Real): boolean;
    value1(x: Real): Real;
    value2(y: Real[], x: Real): Real;
    primitive(x: Real): Real;
    derivative(x: Real): Real;
    secondDerivative(x: Real): Real;
    _a?: any;
    _b?: any;
    _c?: any;
    _d?: any;
    _n?: Size;
    _primitiveConst?: any;
    _monotonicityAdjustments?: any;
    _aIsFixed?: any;
    _bIsFixed?: any;
    _cIsFixed?: any;
    _dIsFixed?: any;
    _k?: any;
    _error?: any;
    _maxError?: any;
    _abcdEndCriteria?: any;
  }
  class templateImpl extends Impl {
    constructor(
        x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size,
        requiredPoints?: Integer);
    xMin(): Real;
    xMax(): Real;
    xValues(): Real[];
    yValues(): Real[];
    isInRange(x: Real): boolean;
    locate(x: Real): Size;
    _x: Real[];
    _xBegin: Size;
    _xEnd: Size;
    _y: Real[];
    _yBegin: Size;
  }
}

export interface Interpolator {
  interpolate(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size):
      Interpolation;
  localInterpolate?
      (x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size,
       localisation: Size, prevInterpolation: Interpolation,
       finalSize: Size): Interpolation;
}
export declare namespace Interpolator {
  function global(i: any): boolean;
  function requiredPoints(i: any): Size;
  function dataSizeAdjustment(i: any): number;
}

export declare class KernelFunction implements UnaryFunction<Real, Real> {
  f(x: Real): Real;
}
export declare class GaussianKernel extends KernelFunction {
  constructor(average: Real, sigma: Real);
  f(x: Real): Real;
  d(x: Real): Real;
  primitive(x: Real): Real;
  private _nd;
  private _cnd;
  private _normFact;
}

export declare class LexicographicalView {
  constructor(iterator: Real[], begin: Size, end: Size, xSize: Size);
  f(i: Size): Real[];
  xSize(): Size;
  ySize(): Size;
  private _iterator;
  private _begin;
  private _end;
  private _xSize;
  private _ySize;
}

declare type Container = any;
export declare class LinearRegression extends GeneralLinearLeastSquares {
  constructor(x: Container, y: Real[]);
  lrInit1(intercept?: Real): LinearRegression;
  lrInit2(v: Array<UnaryFunction<Container, Real>>): LinearRegression;
  x: Container;
  y: Real[];
}
export declare class LinearLeastSquaresRegression extends
    GeneralLinearLeastSquares {
  constructor(x: Real[], y: Real[], v: Array<UnaryFunction<Container, Real>>);
}


export declare type Matrix = number[][];
export declare namespace Array2D {
  function reset(M: Matrix, m: Size, n: Size, dft?: Real): void;
  function from1D(a: Real[], n: Size): Matrix;
  function to1D(m: Real[][]): Real[];
  function fill(m: Matrix, v: Real): void;
  function from(m: Matrix): Matrix;
  function max(m: Matrix): Real;
  function min(m: Matrix): Real;
  function rows(m: Matrix): Size;
  function columns(m: Matrix): Size;
  function size1(m: Matrix): Size;
  function size2(m: Matrix): Size;
  function diagonal(m: Matrix): Real[];
  function add(m1: Matrix, m2: Matrix): Matrix;
  function sub(m1: Matrix, m2: Matrix): Matrix;
  function addScalar(m: Matrix, s: Real): Matrix;
  function subScalar(m: Matrix, s: Real): Matrix;
  function mulScalar(m: Matrix, s: Real): Matrix;
  function divScalar(m: Matrix, s: Real): Matrix;
  function mul(a: Matrix, b: Matrix): Matrix;
  function mulVector(m: Matrix, a: Real[]): Real[];
  function row(m: Matrix, r: Size): Real[];
  function column(m: Matrix, col: Size): Real[];
  function copyV2Col(m: Matrix, v: Real[], col: Size): void;
  function isMatrix(a: any[]): boolean;
  function newMatrix(rows: Size, columns: Size, value?: number): any[][];
  function identityMatrix(rows: Size): Matrix;
  function transpose(m: Matrix): Matrix;
  function transposeVector(a: any[]): Matrix;
  function outerProduct(v1: Real[], v2: Real[]): Matrix;
  function inverse(m: Matrix): Matrix;
  function determinant(m: Matrix): Real;
}

export declare function modifiedBesselFunction_i(nu: Real, x: Real): Real;
export declare function modifiedBesselFunction_k(nu: Real, x: Real): Real;
export declare function modifiedBesselFunction_ic(
    nu: Real, z: Complex): Complex;
export declare function modifiedBesselFunction_kc(
    nu: Real, z: Complex): Complex;
export declare function modifiedBesselFunction_i_exponentiallyWeighted(
    nu: Real, x: Real): Real;
export declare function modifiedBesselFunction_ic_exponentiallyWeighted(
    nu: Real, z: Complex): Complex;
export declare function modifiedBesselFunction_k_exponentiallyWeighted(
    nu: Real, x: Real): Real;
export declare function modifiedBesselFunction_kc_exponentiallyWeighted(
    nu: Real, z: Complex): Complex;
export declare function modifiedBesselFunction_i_Press(nu: Real, x: Real): Real;
export declare function modifiedBesselFunction_k_Press(nu: Real, x: Real): Real;

export declare class PascalTriangle {}

export declare class PolynomialFunction {}

export declare class PrimeNumbers {
  static get(absoluteIndex: Size): BigNatural;
  static nextPrimeNumber(): BigNatural;
  static _primeNumbers: BigNatural[];
}

export declare class quadratic implements UnaryFunction<Real, Real> {
  constructor(a: Real, b: Real, c: Real);
  turningPoint(): Real;
  valueAtTurningPoint(): Real;
  f(x: Real): Real;
  discriminant(): Real;
  roots(byref: byRef): boolean;
  private _a;
  private _b;
  private _c;
}
interface byRef {
  x: Real;
  y: Real;
}


export declare class RichardsonExtrapolation {
  constructor(f: UnaryFunction<Real, Real>, delta_h: Real, n?: Real);
  f1(t?: Real): Real;
  f2(t: Real, s: Real): Real;
  private _delta_h;
  private _fdelta_h;
  private _n;
  private _f;
}

export declare class Rounding implements UnaryFunction<Decimal, Decimal> {
  constructor(precision?: Integer, type?: Rounding.Type, digit?: Integer);
  precision(): Integer;
  type(): Rounding.Type;
  roundingDigit(): Integer;
  f(value: Decimal): Decimal;
  private _precision;
  private _type;
  private _digit;
}
export declare class UpRounding extends Rounding {
  constructor(precision: Integer, digit?: Integer);
}
export declare class DownRounding extends Rounding {
  constructor(precision: Integer, digit?: Integer);
}
export declare class ClosestRounding extends Rounding {
  constructor(precision: Integer, digit?: Integer);
}
export declare class CeilingTruncation extends Rounding {
  constructor(precision: Integer, digit?: Integer);
}
export declare class FloorTruncation extends Rounding {
  constructor(precision: Integer, digit?: Integer);
}
export declare namespace Rounding {
  enum Type { None = 0, Up = 1, Down = 2, Closest = 3, Floor = 4, Ceiling = 5 }
}

export declare class SampledCurve {
  init1(gridSize?: Size): SampledCurve;
  init2(grid: Real[]): SampledCurve;
  grid(): Real[];
  values(): Real[];
  gridValue(i: Size): Real;
  value(i: Size): Real;
  set(i: Size, v: Real): void;
  size(): Size;
  empty(): boolean;
  setGrid(g: Real[]): void;
  setValues(g: Real[]): void;
  sample(f: UnaryFunction<Real, Real>): void;
  valueAtCenter(): Real;
  firstDerivativeAtCenter(): Real;
  secondDerivativeAtCenter(): Real;
  swap(from: SampledCurve): void;
  setLogGrid(min: Real, max: Real): void;
  regridLogGrid(min: Real, max: Real): void;
  shiftGrid(s: Real): void;
  scaleGrid(s: Real): void;
  regrid1(new_grid: Real[]): void;
  regrid2(new_grid: Real[], func: UnaryFunction<Real, Real>): void;
  transform(f: UnaryFunction<Real, Real>): SampledCurve;
  transformGrid(f: UnaryFunction<Real, Real>): SampledCurve;
  private _grid;
  private _values;
}

export declare const MAX_FUNCTION_EVALUATIONS = 100;
export interface Solver1DImpl extends ICuriouslyRecurringTemplate {
  solveImpl(f: UnaryFunction<Real, Real>, accuracy: Real): Real;
}
export interface ISolver1D {
  solve1(f: UnaryFunction<Real, Real>, accuracy: Real, guess: Real, step: Real):
      Real;
  solve2(
      f: UnaryFunction<Real, Real>, accuracy: Real, guess: Real, xMin: Real,
      xMax: Real): Real;
  setMaxEvaluations(evaluations: Size): void;
  setLowerBound(lowerBound: Real): void;
  setUpperBound(upperBound: Real): void;
}
export declare class Solver1D<Impl extends Solver1DImpl> extends
    CuriouslyRecurringTemplate<Impl> implements ISolver1D {
  solve1(f: UnaryFunction<Real, Real>, accuracy: Real, guess: Real, step: Real):
      Real;
  solve2(
      f: UnaryFunction<Real, Real>, accuracy: Real, guess: Real, xMin: Real,
      xMax: Real): Real;
  setMaxEvaluations(evaluations: Size): void;
  setLowerBound(lowerBound: Real): void;
  setUpperBound(upperBound: Real): void;
  private _enforceBounds;
  protected _root: Real;
  protected _xMin: Real;
  protected _xMax: Real;
  protected _fxMin: Real;
  protected _fxMax: Real;
  protected _maxEvaluations: Size;
  protected _evaluationNumber: Size;
  private _lowerBound;
  private _upperBound;
  private _lowerBoundEnforced;
  private _upperBoundEnforced;
}

export declare class TransformedGrid {
  init1(grid: Real[]): TransformedGrid;
  init2(grid: Real[], func: UnaryFunction<Real, Real>): TransformedGrid;
  gridArray(): Real[];
  transformedGridArray(): Real[];
  dxmArray(): Real[];
  dxpArray(): Real[];
  dxArray(): Real[];
  grid(i: Size): Real;
  transformedGrid(i: Size): Real;
  dxm(i: Size): Real;
  dxp(i: Size): Real;
  dx(i: Size): Real;
  size(): Size;
  protected _grid: Real[];
  protected _transformedGrid: Real[];
  protected _dxm: Real[];
  protected _dxp: Real[];
  protected _dx: Real[];
}
export declare class LogGrid extends TransformedGrid {
  constructor(grid: Real[]);
  logGridArray(): Real[];
  logGrid(i: Size): Real;
}

export declare class AliMikhailHaqCopula implements
    BinaryFunction<Real, Real, Real> {
  constructor(theta: Real);
  f(x: Real, y: Real): Real;
  private _theta;
}

export declare class ClaytonCopula implements BinaryFunction<Real, Real, Real> {
  constructor(theta: Real);
  f(x: Real, y: Real): Real;
  private _theta;
}

export declare class FarlieGumbelMorgensternCopula implements
    BinaryFunction<Real, Real, Real> {
  constructor(theta: Real);
  f(x: Real, y: Real): Real;
  private _theta;
}

export declare class FrankCopula implements BinaryFunction<Real, Real, Real> {
  constructor(theta: Real);
  f(x: Real, y: Real): Real;
  private _theta;
}

export declare class GalambosCopula implements
    BinaryFunction<Real, Real, Real> {
  constructor(theta: Real);
  f(x: Real, y: Real): Real;
  private _theta;
}

export declare class GaussianCopula implements
    BinaryFunction<Real, Real, Real> {
  constructor(rho: Real);
  f(x: Real, y: Real): Real;
  private _rho;
  private _bivariate_normal_cdf;
  private _invCumNormal;
}

export declare class GumbelCopula implements BinaryFunction<Real, Real, Real> {
  constructor(theta: Real);
  f(x: Real, y: Real): Real;
  private _theta;
}

export declare class HuslerReissCopula implements
    BinaryFunction<Real, Real, Real> {
  constructor(theta: Real);
  f(x: Real, y: Real): Real;
  private _theta;
  private _cumNormal;
}

export declare class IndependentCopula implements
    BinaryFunction<Real, Real, Real> {
  f(x: Real, y: Real): Real;
}

export declare class MarshallOlkinCopula implements
    BinaryFunction<Real, Real, Real> {
  constructor(a1: Real, a2: Real);
  f(x: Real, y: Real): Real;
  private _a1;
  private _a2;
}

export declare class MaxCopula implements BinaryFunction<Real, Real, Real> {
  f(x: Real, y: Real): Real;
}

export declare class MinCopula implements BinaryFunction<Real, Real, Real> {
  f(x: Real, y: Real): Real;
}

export declare class PlackettCopula implements
    BinaryFunction<Real, Real, Real> {
  constructor(theta: Real);
  f(x: Real, y: Real): Real;
  private _theta;
}

export declare function binomialCoefficientLn(
    n: BigNatural, k: BigNatural): Real;
export declare function binomialCoefficient(n: BigNatural, k: BigNatural): Real;
export declare class BinomialDistribution implements UnaryFunction<Real, Real> {
  constructor(p: Real, n: BigNatural);
  f(k: BigNatural): Real;
  private _n;
  private _logP;
  private _logOneMinusP;
}
export declare class CumulativeBinomialDistribution implements
    UnaryFunction<Real, Real> {
  constructor(p: Real, n: BigNatural);
  f(k: BigNatural): Real;
  private _n;
  private _p;
}
export declare function PeizerPrattMethod2Inversion(
    z: Real, n: BigNatural): Real;

export declare type BivariateCumulativeNormalDistribution =
    BivariateCumulativeNormalDistributionWe04DP;
export declare class BivariateCumulativeNormalDistributionDr78 {
  constructor(rho: Real);
  f(a: Real, b: Real): Real;
  private _rho;
  private _rho2;
}
export declare class BivariateCumulativeNormalDistributionWe04DP {
  constructor(rho: Real);
  f(x: Real, y: Real): Real;
  private _correlation;
  private _cumnorm;
}

export declare class BivariateCumulativeStudentDistribution {
  constructor(n: Natural, rho: Real);
  f(x: Real, y: Real): Real;
  private sign;
  private arctan;
  private f_x;
  private P_n;
  private _n;
  private _rho;
}

export declare class CumulativeChiSquareDistribution implements
    UnaryFunction<Real, Real> {
  constructor(df: Real);
  f(x: Real): Real;
  private _df;
}
export declare class NonCentralChiSquareDistribution implements
    UnaryFunction<Real, Real> {
  constructor(df: Real, ncp: Real);
  f(x: Real): Real;
  private _df;
  private _ncp;
}
export declare class CumulativeNonCentralChiSquareDistribution implements
    UnaryFunction<Real, Real> {
  constructor(df: Real, ncp: Real);
  f(x: Real): Real;
  private _df;
  private _ncp;
}
export declare class InverseCumulativeNonCentralChiSquare implements
    UnaryFunction<Real, Real> {
  constructor(df: Real, ncp: Real, maxEvaluations?: Size, accuracy?: Real);
  f(x: Real): Real;
  private _nonCentralDist;
  private _guess;
  private _maxEvaluations;
  private _accuracy;
}

export declare type GammaDistribution = CumulativeGammaDistribution;
export declare class CumulativeGammaDistribution implements
    UnaryFunction<Real, Real> {
  constructor(a: Real);
  f(x: Real): Real;
  private _a;
}
export declare class GammaFunction {
  value(x: Real): Real;
  logValue(x: Real): Real;
}

export declare class NormalDistribution implements UnaryFunction<Real, Real> {
  constructor(average?: Real, sigma?: Real);
  f(x: Real): Real;
  d(x: Real): Real;
  private _average;
  private _sigma;
  private _normalizationFactor;
  private _denominator;
  private _derNormalizationFactor;
}
export declare type GaussianDistribution = NormalDistribution;
export declare class CumulativeNormalDistribution implements
    UnaryFunction<Real, Real> {
  constructor(average?: Real, sigma?: Real);
  f(z: Real): Real;
  d(x: Real): Real;
  private _average;
  private _sigma;
  private _gaussian;
  private _errorFunction;
}
export declare class InverseCumulativeNormal implements
    UnaryFunction<Real, Real> {
  constructor(average?: Real, sigma?: Real);
  f(x: Real): Real;
  static standard_value(x: Real): Real;
  static tail_value(x: Real): Real;
  static _f: CumulativeNormalDistribution;
  private _average;
  private _sigma;
}
export declare type InvCumulativeNormalDistribution = InverseCumulativeNormal;
export declare class MoroInverseCumulativeNormal implements
    UnaryFunction<Real, Real> {
  constructor(average?: Real, sigma?: Real);
  f(x: Real): Real;
  private _average;
  private _sigma;
}
export declare class MaddockInverseCumulativeNormal implements
    UnaryFunction<Real, Real> {
  constructor(average?: Real, sigma?: Real);
  f(x: Real): Real;
  private _average;
  private _sigma;
}
export declare class MaddockCumulativeNormal implements
    UnaryFunction<Real, Real> {
  constructor(average?: Real, sigma?: Real);
  f(x: Real): Real;
  private _average;
  private _sigma;
}

export declare class PoissonDistribution implements UnaryFunction<Real, Real> {
  constructor(mu: Real);
  f(k: BigNatural): Real;
  private _mu;
}
export declare class CumulativePoissonDistribution implements
    UnaryFunction<Real, Real> {
  constructor(mu: Real);
  f(k: BigNatural): Real;
  private _mu;
}
export declare class InverseCumulativePoisson implements
    UnaryFunction<Real, Real> {
  constructor(lambda?: Real);
  f(x: Real): Real;
  private calcSummand;
  private _lambda;
}

export declare class StudentDistribution implements UnaryFunction<Real, Real> {
  constructor(n: Integer);
  f(x: Real): Real;
  static G: GammaFunction;
  private _n;
}
export declare class CumulativeStudentDistribution implements
    UnaryFunction<Real, Real> {
  constructor(n: Integer);
  f(x: Real): Real;
  private _n;
}
export declare class InverseCumulativeStudent implements
    UnaryFunction<Real, Real> {
  constructor(n: Integer, accuracy?: Real, maxIterations?: Size);
  f(y: Real): Real;
  private _d;
  private _f;
  private _accuracy;
  private _maxIterations;
}

export declare class DiscreteTrapezoidIntegral implements
    BinaryFunction<Real[], Real[], Real> {
  f(x: Real[], f: Real[]): Real;
}
export declare class DiscreteSimpsonIntegral implements
    BinaryFunction<Real[], Real[], Real> {
  f(x: Real[], f: Real[]): Real;
}
export declare class DiscreteTrapezoidIntegrator extends Integrator {
  constructor(evaluations: Size);
  protected integrate(f: UnaryFunction<Real, Real>, a: Real, b: Real): Real;
}
export declare class DiscreteSimpsonIntegrator extends Integrator {
  constructor(evaluations: Size);
  protected integrate(f: UnaryFunction<Real, Real>, a: Real, b: Real): Real;
}

export declare class FilonIntegral extends Integrator {
  constructor(type: FilonIntegral.Type, t: Real, intervals: Size);
  protected integrate(f: UnaryFunction<Real, Real>, a: Real, b: Real): Real;
  private _type;
  private _t;
  private _intervals;
  private _n;
}
export declare namespace FilonIntegral {
  enum Type { Sine = 0, Cosine = 1 }
}

export declare class GaussianOrthogonalPolynomial {
  mu_0(): Real;
  alpha(i: Size): Real;
  beta(i: Size): Real;
  w(i: Size): Real;
  value(n: Size, x: Real): Real;
  weightedValue(n: Size, x: Real): Real;
}
export declare class GaussLaguerrePolynomial extends
    GaussianOrthogonalPolynomial {
  constructor(s?: Real);
  mu_0(): Real;
  alpha(i: Size): Real;
  beta(i: Size): Real;
  w(x: Real): Real;
  private _s;
}
export declare class GaussHermitePolynomial extends
    GaussianOrthogonalPolynomial {
  constructor(mu?: Real);
  mu_0(): Real;
  alpha(i: Size): Real;
  beta(i: Size): Real;
  w(x: Real): Real;
  private _mu;
}
export declare class GaussJacobiPolynomial extends
    GaussianOrthogonalPolynomial {
  constructor(alpha: Real, beta: Real);
  mu_0(): Real;
  alpha(i: Size): Real;
  beta(i: Size): Real;
  w(x: Real): Real;
  private _alpha;
  private _beta;
}
export declare class GaussLegendrePolynomial extends GaussJacobiPolynomial {
  constructor();
}
export declare class GaussChebyshevPolynomial extends GaussJacobiPolynomial {
  constructor();
}
export declare class GaussChebyshev2ndPolynomial extends GaussJacobiPolynomial {
  constructor();
}
export declare class GaussGegenbauerPolynomial extends GaussJacobiPolynomial {
  constructor(lambda: Real);
}
export declare class GaussHyperbolicPolynomial extends
    GaussianOrthogonalPolynomial {
  mu_0(): Real;
  alpha(i: Size): Real;
  beta(i: Size): Real;
  w(x: Size): Real;
}

export declare class GaussianQuadrature {
  constructor(n: Size, orthPoly: GaussianOrthogonalPolynomial);
  f(uf: UnaryFunction<Real, Real>): Real;
  order(): Size;
  weights(): Real[];
  x(): Real[];
  protected _x: Real[];
  protected _w: Real[];
}
export declare class GaussLaguerreIntegration extends GaussianQuadrature {
  constructor(n: Size, s?: Real);
}
export declare class GaussHermiteIntegration extends GaussianQuadrature {
  constructor(n: Size, mu?: Real);
}
export declare class GaussJacobiIntegration extends GaussianQuadrature {
  constructor(n: Size, alpha: Real, beta: Real);
}
export declare class GaussHyperbolicIntegration extends GaussianQuadrature {
  constructor(n: Size);
}
export declare class GaussLegendreIntegration extends GaussianQuadrature {
  constructor(n: Size);
}
export declare class GaussChebyshevIntegration extends GaussianQuadrature {
  constructor(n: Size);
}
export declare class GaussChebyshev2ndIntegration extends GaussianQuadrature {
  constructor(n: Size);
}
export declare class GaussGegenbauerIntegration extends GaussianQuadrature {
  constructor(n: Size, lambda: Real);
}
export declare class TabulatedGaussLegendre {
  constructor(n?: Size);
  f(uf: UnaryFunction<Real, Real>): Real;
  order1(order: Size): void;
  order2(): Size;
  private _order;
  private _w;
  private _x;
  private _n;
}

export declare class GaussLobattoIntegral extends Integrator {
  constructor(
      maxIterations: Size, absAccuracy: Real, relAccuracy?: Real,
      useConvergenceEstimate?: boolean);
  protected integrate(f: UnaryFunction<Real, Real>, a: Real, b: Real): Real;
  protected calculateAbsTolerance(
      f: UnaryFunction<Real, Real>, a: Real, b: Real): Real;
  protected adaptivGaussLobattoStep(
      f: UnaryFunction<Real, Real>, a: Real, b: Real, fa: Real, fb: Real,
      acc: Real): Real;
  protected _relAccuracy: Real;
  protected _useConvergenceEstimate: boolean;
}

export declare class Integrator implements
    TernaryFunction<UnaryFunction<Real, Real>, Real, Real, Real> {
  constructor(absoluteAccuracy: Real, maxEvaluations: Size);
  f(f: UnaryFunction<Real, Real>, a: Real, b: Real): Real;
  setAbsoluteAccuracy(accuracy: Real): void;
  setMaxEvaluations(maxEvaluations: Size): void;
  absoluteAccuracy(): Real;
  maxEvaluations(): Size;
  absoluteError(): Real;
  setAbsoluteError(error: Real): void;
  numberOfEvaluations(): Size;
  setNumberOfEvaluations(evaluations: Size): void;
  increaseNumberOfEvaluations(increase: Size): void;
  integrationSuccess(): boolean;
  protected integrate(f: UnaryFunction<Real, Real>, a: Real, b: Real): Real;
  private _absoluteAccuracy;
  private _absoluteError;
  private _maxEvaluations;
  private _evaluations;
}

export declare class GaussKronrodNonAdaptive extends Integrator {
  constructor(
      absoluteAccuracy: Real, maxEvaluations: Size, relativeAccuracy: Real);
  setRelativeAccuracy(a: Real): void;
  relativeAccuracy(): Real;
  protected integrate(f: UnaryFunction<Real, Real>, a: Real, b: Real): Real;
  private _relativeAccuracy;
}
export declare class GaussKronrodAdaptive extends Integrator {
  constructor(absoluteAccuracy: Real, maxEvaluations?: Size);
  protected integrate(f: UnaryFunction<Real, Real>, a: Real, b: Real): Real;
  private integrateRecursively;
}

export declare class SegmentIntegral extends Integrator {
  constructor(intervals: Size);
  protected integrate(f: UnaryFunction<Real, Real>, a: Real, b: Real): Real;
  private _intervals;
}

export declare class SimpsonIntegral extends TrapezoidIntegral {
  constructor(accuracy: Real, maxIterations: Size);
  protected integrate(f: UnaryFunction<Real, Real>, a: Real, b: Real): Real;
}

export declare class TrapezoidIntegral extends Integrator {
  constructor(policy: Policy, accuracy: Real, maxIterations: Size);
  protected integrate(f: UnaryFunction<Real, Real>, a: Real, b: Real): Real;
  policy: Policy;
}
export declare type Policy = Default | MidPoint;
export declare namespace IntegrationPolicy {
  function integrate(
      policy: Policy, f: UnaryFunction<Real, Real>, a: Real, b: Real, I: Real,
      N: Size): Real;
  function nbEvalutions(policy: Policy): Size;
}
export declare class Default {
  static integrate(
      f: UnaryFunction<Real, Real>, a: Real, b: Real, I: Real, N: Size): Real;
  static nbEvalutions(): Size;
}
export declare class MidPoint {
  static integrate(
      f: UnaryFunction<Real, Real>, a: Real, b: Real, I: Real, N: Size): Real;
  static nbEvalutions(): Size;
}

export declare class TwoDimensionalIntegral {
  constructor(integratorX: Integrator, integratorY: Integrator);
  f(f: UnaryFunction<[Real, Real], Real>, a: [Real, Real],
    b: [Real, Real]): Real;
  private g;
  private _integratorX;
  private _integratorY;
}

export declare class AbcdCoeffHolder {
  constructor(
      a: Real, b: Real, c: Real, d: Real, aIsFixed: boolean, bIsFixed: boolean,
      cIsFixed: boolean, dIsFixed: boolean);
  _a: Real;
  _b: Real;
  _c: Real;
  _d: Real;
  _aIsFixed: boolean;
  _bIsFixed: boolean;
  _cIsFixed: boolean;
  _dIsFixed: boolean;
  _k: Real[];
  _error: Real;
  _maxError: Real;
  _abcdEndCriteria: EndCriteria.Type;
}

export declare class AbcdInterpolation extends Interpolation {
  constructor(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size, a?: Real,
      b?: Real, c?: Real, d?: Real, aIsFixed?: boolean, bIsFixed?: boolean,
      cIsFixed?: boolean, dIsFixed?: boolean, vegaWeighted?: boolean,
      endCriteria?: EndCriteria, optMethod?: OptimizationMethod);
  a(): Real;
  b(): Real;
  c(): Real;
  d(): Real;
  k1(): Real[];
  rmsError(): Real;
  maxError(): Real;
  endCriteria(): EndCriteria.Type;
  k2(t: Time, x: Real[], xBegin: Size, xEnd: Size): Real;
  private _coeffs;
}
export declare class Abcd {
  constructor(
      a: Real, b: Real, c: Real, d: Real, aIsFixed: boolean, bIsFixed: boolean,
      cIsFixed: boolean, dIsFixed: boolean, vegaWeighted?: boolean,
      endCriteria?: EndCriteria, optMethod?: OptimizationMethod);
  interpolate(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size):
      Interpolation;
  static global: boolean;
  private _a;
  private _b;
  private _c;
  private _d;
  private _aIsFixed;
  private _bIsFixed;
  private _cIsFixed;
  private _dIsFixed;
  private _vegaWeighted;
  private _endCriteria;
  private _optMethod;
}

export declare class BackwardFlatInterpolation extends Interpolation {
  constructor(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size);
}
export declare class BackwardFlat implements Interpolator {
  interpolate(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size):
      Interpolation;
  static global: boolean;
  static requiredPoints: Size;
}

export declare class BackwardflatLinearInterpolation extends Interpolation2D {}

export declare class BicubicSpline extends Interpolation2D {
  constructor(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size, yEnd: Size,
      zData: Matrix);
  derivativeX(x: Real, y: Real): Real;
  derivativeY(x: Real, y: Real): Real;
  secondDerivativeX(x: Real, y: Real): Real;
  secondDerivativeY(x: Real, y: Real): Real;
  derivativeXY(x: Real, y: Real): Real;
}
export declare class Bicubic implements Interpolator2D {
  interpolate(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size, yEnd: Size,
      zData: Matrix): Interpolation2D;
}
export declare class BicubicSplineDerivatives {
  derivativeX(x: Real, y: Real): Real;
  derivativeY(x: Real, y: Real): Real;
  derivativeXY(x: Real, y: Real): Real;
  secondDerivativeX(x: Real, y: Real): Real;
  secondDerivativeY(x: Real, y: Real): Real;
}
export declare class BicubicSplineImpl extends Interpolation2D.templateImpl {
  constructor(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size, yEnd: Size,
      zData: Matrix);
  calculate(): void;
  value(x: Real, y: Real): Real;
  derivativeX(x: Real, y: Real): Real;
  secondDerivativeX(x: Real, y: Real): Real;
  derivativeY(x: Real, y: Real): Real;
  secondDerivativeY(x: Real, y: Real): Real;
  derivativeXY(x: Real, y: Real): Real;
  private _splines;
}

export declare class BilinearInterpolation extends Interpolation2D {
  constructor(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size, yEnd: Size,
      zData: Matrix);
}
export declare class Bilinear {
  interpolate(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size, yEnd: Size,
      zData: Matrix): BilinearInterpolation;
}

export declare class CoefficientHolder {
  constructor(n: Size);
  _n: Size;
  _primitiveConst: Real[];
  _a: Real[];
  _b: Real[];
  _c: Real[];
  _monotonicityAdjustments: boolean[];
}

export declare class ConvexMonotoneInterpolation extends Interpolation {
  constructor(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size,
      quadraticity: Real, monotonicity: Real, forcePositive: boolean,
      flatFinalPeriod?: boolean, preExistingHelpers?: Map<Real, SectionHelper>);
  getExistingHelpers(): Map<Real, SectionHelper>;
}
export declare class ConvexMonotone implements Interpolator {
  constructor(
      quadraticity?: Real, monotonicity?: Real, forcePositive?: boolean);
  interpolate(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size):
      Interpolation;
  localInterpolate(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size,
      localisation: Size, prevInterpolation: Interpolation,
      finalSize: Size): Interpolation;
  static global: boolean;
  static requiredPoints: Size;
  static dataSizeAdjustment: Size;
  private _quadraticity;
  private _monotonicity;
  private _forcePositive;
}
export declare class SectionHelper {
  value(x: Real): Real;
  primitive(x: Real): Real;
  fNext(): Real;
}
export declare class ComboHelper extends SectionHelper {
  constructor(
      quadraticHelper: SectionHelper, convMonoHelper: SectionHelper,
      quadraticity: Real);
  value(x: Real): Real;
  primitive(x: Real): Real;
  fNext(): Real;
  private _quadraticity;
  private _quadraticHelper;
  private _convMonoHelper;
}
export declare class EverywhereConstantHelper extends SectionHelper {
  constructor(value: Real, prevPrimitive: Real, xPrev: Real);
  value(x: Real): Real;
  primitive(x: Real): Real;
  fNext(): Real;
  private _value;
  private _prevPrimitive;
  private _xPrev;
}
export declare class ConvexMonotone2Helper extends SectionHelper {
  constructor(
      xPrev: Real, xNext: Real, gPrev: Real, gNext: Real, fAverage: Real,
      eta2: Real, prevPrimitive: Real);
  value(x: Real): Real;
  primitive(x: Real): Real;
  fNext(): Real;
  private _xPrev;
  private _xNext;
  private _xScaling;
  private _gPrev;
  private _gNext;
  private _fAverage;
  private _eta2;
  private _prevPrimitive;
}
export declare class ConvexMonotone3Helper extends SectionHelper {
  constructor(
      xPrev: Real, xNext: Real, gPrev: Real, gNext: Real, fAverage: Real,
      eta3: Real, prevPrimitive: Real);
  value(x: Real): Real;
  primitive(x: Real): Real;
  fNext(): Real;
  private _xPrev;
  private _xNext;
  private _xScaling;
  private _gPrev;
  private _gNext;
  private _fAverage;
  private _eta3;
  private _prevPrimitive;
}
export declare class ConvexMonotone4Helper extends SectionHelper {
  constructor(
      xPrev: Real, xNext: Real, gPrev: Real, gNext: Real, fAverage: Real,
      eta4: Real, prevPrimitive: Real);
  value(x: Real): Real;
  primitive(x: Real): Real;
  fNext(): Real;
  protected _xPrev: Real;
  protected _xNext: Real;
  protected _xScaling: Real;
  protected _gPrev: Real;
  protected _gNext: Real;
  protected _fAverage: Real;
  protected _eta4: Real;
  protected _prevPrimitive: Real;
  protected _A: Real;
}
export declare class ConvexMonotone4MinHelper extends ConvexMonotone4Helper {
  constructor(
      xPrev: Real, xNext: Real, gPrev: Real, gNext: Real, fAverage: Real,
      eta4: Real, prevPrimitive: Real);
  value(x: Real): Real;
  primitive(x: Real): Real;
  private _splitRegion;
  private _xRatio;
  private _x2;
  private _x3;
}
export declare class ConstantGradHelper extends SectionHelper {
  constructor(
      fPrev: Real, prevPrimitive: Real, xPrev: Real, xNext: Real, fNext: Real);
  value(x: Real): Real;
  primitive(x: Real): Real;
  fNext(): Real;
  private _fPrev;
  private _xPrev;
  private _fGrad;
  private _fNext;
  private _prevPrimitive;
}
export declare class QuadraticHelper extends SectionHelper {
  constructor(
      xPrev: Real, xNext: Real, fPrev: Real, fNext: Real, fAverage: Real,
      prevPrimitive: Real);
  value(x: Real): Real;
  primitive(x: Real): Real;
  fNext(): Real;
  private _fPrev;
  private _xPrev;
  private _xNext;
  private _fAverage;
  private _fNext;
  private _xScaling;
  private _a;
  private _b;
  private _c;
  private _prevPrimitive;
}
export declare class QuadraticMinHelper extends SectionHelper {
  constructor(
      xPrev: Real, xNext: Real, fPrev: Real, fNext: Real, fAverage: Real,
      prevPrimitive: Real);
  value(x: Real): Real;
  primitive(x: Real): Real;
  fNext(): Real;
  private _splitRegion;
  private _x1;
  private _x2;
  private _x3;
  private _x4;
  private _a;
  private _b;
  private _c;
  private _primitive1;
  private _primitive2;
  private _fAverage;
  private _fPrev;
  private _fNext;
  private _xScaling;
  private _xRatio;
}
export declare class ConvexMonotoneImpl extends Interpolation.templateImpl {
  constructor(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size,
      quadraticity: Real, monotonicity: Real, forcePositive: boolean,
      constantLastPeriod: boolean,
      preExistingHelpers: Map<Real, SectionHelper>);
  update(): void;
  value1(x: Real): Real;
  primitive(x: Real): Real;
  derivative(x: Real): Real;
  secondDerivative(x: Real): Real;
  getExistingHelpers(): Map<Real, SectionHelper>;
  private _sectionHelpers;
  private _preSectionHelpers;
  private _extrapolationHelper;
  private _forcePositive;
  private _constantLastPeriod;
  private _quadraticity;
  private _monotonicity;
  private _length;
}
export declare namespace ConvexMonotoneImpl {
  enum SectionType {
    EverywhereConstant = 0,
    ConstantGradient = 1,
    QuadraticMinimum = 2,
    QuadraticMaximum = 3
  }
}

export declare class CubicInterpolation extends Interpolation {
  constructor(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size,
      da: CubicInterpolation.DerivativeApprox, monotonic: boolean,
      leftCond: CubicInterpolation.BoundaryCondition, leftConditionValue: Real,
      rightCond: CubicInterpolation.BoundaryCondition,
      rightConditionValue: Real);
  primitiveConstants(): Real[];
  aCoefficients(): Real[];
  bCoefficients(): Real[];
  cCoefficients(): Real[];
  monotonicityAdjustments(): boolean[];
  private _coeffs;
}
export declare class CubicNaturalSpline extends CubicInterpolation {
  constructor(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size);
}
export declare class MonotonicCubicNaturalSpline extends CubicInterpolation {
  constructor(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size);
}
export declare class CubicSplineOvershootingMinimization1 extends
    CubicInterpolation {
  constructor(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size);
}
export declare class CubicSplineOvershootingMinimization2 extends
    CubicInterpolation {
  constructor(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size);
}
export declare class AkimaCubicInterpolation extends CubicInterpolation {
  constructor(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size);
}
export declare class KrugerCubic extends CubicInterpolation {
  constructor(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size);
}
export declare class HarmonicCubic extends CubicInterpolation {
  constructor(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size);
}
export declare class FritschButlandCubic extends CubicInterpolation {
  constructor(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size);
}
export declare class Parabolic extends CubicInterpolation {
  constructor(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size);
}
export declare class MonotonicParabolic extends CubicInterpolation {
  constructor(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size);
}
export declare namespace CubicInterpolation {
  enum DerivativeApprox {
    Spline = 0,
    SplineOM1 = 1,
    SplineOM2 = 2,
    FourthOrder = 3,
    Parabolic = 4,
    FritschButland = 5,
    Akima = 6,
    Kruger = 7,
    Harmonic = 8
  }
  enum BoundaryCondition {
    NotAKnot = 0,
    FirstDerivative = 1,
    SecondDerivative = 2,
    Periodic = 3,
    Lagrange = 4
  }
}
export declare class Cubic implements Interpolator {
  constructor(
      da?: CubicInterpolation.DerivativeApprox, monotonic?: boolean,
      leftCondition?: CubicInterpolation.BoundaryCondition,
      leftConditionValue?: Real,
      rightCondition?: CubicInterpolation.BoundaryCondition,
      rightConditionValue?: Real);
  interpolate(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size):
      Interpolation;
  static global: boolean;
  static requiredPoints: Size;
  private _da;
  private _monotonic;
  private _leftType;
  private _rightType;
  private _leftValue;
  private _rightValue;
}

export declare class Extrapolator {
  enableExtrapolation(b?: boolean): void;
  disableExtrapolation(b?: boolean): void;
  allowsExtrapolation(): boolean;
  _extrapolate: boolean;
}

export declare class FlatExtrapolator2D extends Interpolation2D {
  constructor(decoratedInterpolation: Interpolation2D);
}

export declare class ForwardFlatInterpolation extends Interpolation {
  constructor(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size);
}
export declare class ForwardFlat implements Interpolator {
  interpolate(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size):
      Interpolation;
  static global: boolean;
  static requiredPoints: Size;
}
export declare namespace detail {
  class ForwardFlatInterpolationImpl extends Interpolation.templateImpl {
    constructor(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size);
    update(): void;
    value1(x: Real): Real;
    primitive(x: Real): Real;
    derivative(x: Real): Real;
    secondDerivative(x: Real): number;
    _primitive: Real[];
  }
}

export declare class Interpolation2D extends Extrapolator implements
    TernaryFunction<Real, Real, boolean, Real> {
  f(x: Real, y: Real, allowExtrapolation?: boolean): Real;
  xMin(): Real;
  xMax(): Real;
  xValues(): Real[];
  locateX(x: Real): Size;
  yMin(): Real;
  yMax(): Real;
  yValues(): Real[];
  locateY(y: Real): Size;
  zData(): Matrix;
  isInRange(x: Real, y: Real): boolean;
  update(): void;
  checkRange(x: Real, y: Real, extrapolate: boolean): void;
  _impl: Interpolation2D.Impl;
}
export interface Interpolator2D {
  interpolate(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size, yEnd: Size,
      zData: Matrix): Interpolation2D;
}
export declare namespace Interpolation2D {
  class Impl {
    calculate(): void;
    xMin(): Real;
    xMax(): Real;
    xValues(): Real[];
    locateX(x: Real): Size;
    yMin(): Real;
    yMax(): Real;
    yValues(): Real[];
    locateY(y: Real): Size;
    zData(): Matrix;
    isInRange(x: Real, y: Real): boolean;
    value(x: Real, y: Real): Real;
  }
  class templateImpl extends Impl {
    constructor(
        x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size,
        yEnd: Size, zData: Matrix);
    xMin(): Real;
    xMax(): Real;
    yMin(): Real;
    yMax(): Real;
    xValues(): Real[];
    yValues(): Real[];
    zData(): Matrix;
    isInRange(x: Real, y: Real): boolean;
    locateX(x: Real): Size;
    locateY(y: Real): Size;
    _x: Real[];
    _xBegin: Size;
    _xEnd: Size;
    _y: Real[];
    _yBegin: Size;
    _yEnd: Size;
    _zData: Matrix;
  }
}

export declare class KernelInterpolation extends Interpolation {
  constructor(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size,
      kernel: UnaryFunction<Real, Real>, epsilon?: Real);
}

export declare class KernelInterpolation2D extends Interpolation2D {
  constructor(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size, yEnd: Size,
      zData: Matrix, kernel: UnaryFunction<Real, Real>);
}

export declare class LagrangeInterpolation extends Interpolation {
  constructor(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size);
  value(y: Real[], x: Real): Real;
}

export declare class LinearInterpolation extends Interpolation {
  constructor(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size);
}
export declare class Linear implements Interpolator {
  interpolate(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size):
      Interpolation;
  static global: boolean;
  static requiredPoints: Size;
}

export declare class LogLinearInterpolation extends Interpolation {
  constructor(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size);
}
export declare class LogLinear implements Interpolator {
  interpolate(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size):
      Interpolation;
  static global: boolean;
  static requiredPoints: Size;
}
export declare class LogCubicInterpolation extends Interpolation {
  constructor(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size,
      da: CubicInterpolation.DerivativeApprox, monotonic: boolean,
      leftC: CubicInterpolation.BoundaryCondition, leftConditionValue: Real,
      rightC: CubicInterpolation.BoundaryCondition, rightConditionValue: Real);
}
export declare class LogCubic {
  constructor(
      da: CubicInterpolation.DerivativeApprox, monotonic?: boolean,
      leftC?: CubicInterpolation.BoundaryCondition, leftConditionValue?: Real,
      rightC?: CubicInterpolation.BoundaryCondition,
      rightConditionValue?: Real);
  interpolate(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size):
      Interpolation;
  static global: boolean;
  static requiredPoints: Size;
  private _da;
  private _monotonic;
  private _leftType;
  private _rightType;
  private _leftValue;
  private _rightValue;
}
export declare class LogCubicNaturalSpline extends LogCubicInterpolation {
  constructor(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size);
}
export declare class MonotonicLogCubicNaturalSpline extends
    LogCubicInterpolation {
  constructor(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size);
}
export declare class KrugerLogCubic extends LogCubicInterpolation {
  constructor(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size);
}
export declare class HarmonicLogCubic extends LogCubicInterpolation {
  constructor(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size);
}
export declare class FritschButlandLogCubic extends LogCubicInterpolation {
  constructor(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size);
}
export declare class LogParabolic extends LogCubicInterpolation {
  constructor(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size);
}
export declare class MonotonicLogParabolic extends LogCubicInterpolation {
  constructor(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size);
}
export declare class LogMixedLinearCubicInterpolation extends Interpolation {
  constructor(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size, n: Size,
      behavior: MixedInterpolation.Behavior,
      da: CubicInterpolation.DerivativeApprox, monotonic: boolean,
      leftC: CubicInterpolation.BoundaryCondition, leftConditionValue: Real,
      rightC: CubicInterpolation.BoundaryCondition, rightConditionValue: Real);
}
export declare class LogMixedLinearCubic {
  constructor(
      n: Size, behavior: MixedInterpolation.Behavior,
      da: CubicInterpolation.DerivativeApprox, monotonic?: boolean,
      leftC?: CubicInterpolation.BoundaryCondition, leftConditionValue?: Real,
      rightC?: CubicInterpolation.BoundaryCondition,
      rightConditionValue?: Real);
  interpolate(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size):
      Interpolation;
  static global: boolean;
  static requiredPoints: Size;
  private _n;
  private _behavior;
  private _da;
  private _monotonic;
  private _leftType;
  private _rightType;
  private _leftValue;
  private _rightValue;
}
export declare class LogMixedLinearCubicNaturalSpline extends
    LogMixedLinearCubicInterpolation {
  constructor(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size, n: Size,
      behavior?: MixedInterpolation.Behavior);
}

export declare class MixedLinearCubicInterpolation extends Interpolation {
  constructor(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size, n: Size,
      behavior: MixedInterpolation.Behavior,
      da: CubicInterpolation.DerivativeApprox, monotonic: boolean,
      leftC: CubicInterpolation.BoundaryCondition, leftConditionValue: Real,
      rightC: CubicInterpolation.BoundaryCondition, rightConditionValue: Real);
}
export declare class MixedLinearCubicNaturalSpline extends
    MixedLinearCubicInterpolation {
  constructor(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size, n: Size,
      behavior?: MixedInterpolation.Behavior);
}
export declare class MixedLinearMonotonicCubicNaturalSpline extends
    MixedLinearCubicInterpolation {
  constructor(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size, n: Size,
      behavior?: MixedInterpolation.Behavior);
}
export declare class MixedLinearKrugerCubic extends
    MixedLinearCubicInterpolation {
  constructor(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size, n: Size,
      behavior?: MixedInterpolation.Behavior);
}
export declare class MixedLinearFritschButlandCubic extends
    MixedLinearCubicInterpolation {
  constructor(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size, n: Size,
      behavior?: MixedInterpolation.Behavior);
}
export declare class MixedLinearParabolic extends
    MixedLinearCubicInterpolation {
  constructor(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size, n: Size,
      behavior?: MixedInterpolation.Behavior);
}
export declare class MixedLinearMonotonicParabolic extends
    MixedLinearCubicInterpolation {
  constructor(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size, n: Size,
      behavior?: MixedInterpolation.Behavior);
}
export declare namespace MixedInterpolation {
  enum Behavior { ShareRanges = 0, SplitRanges = 1 }
  class MixedInterpolationImpl<I1 extends Interpolator, I2 extends Interpolator>
      extends Interpolation.templateImpl {
    constructor(
        x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size, n: Size,
        behavior?: Behavior, factory1?: I1, factory2?: I2);
    update(): void;
    value1(x: Real): Real;
    primitive(x: Real): Real;
    derivative(x: Real): Real;
    secondDerivative(x: Real): Real;
    switchIndex(): Size;
    private _xBegin2;
    private _yBegin2;
    private _interpolation1;
    private _interpolation2;
  }
}
export declare class MixedLinearCubic implements Interpolator {
  constructor(
      n: Size, behavior: MixedInterpolation.Behavior,
      da: CubicInterpolation.DerivativeApprox, monotonic?: boolean,
      leftC?: CubicInterpolation.BoundaryCondition, leftConditionValue?: Real,
      rightC?: CubicInterpolation.BoundaryCondition,
      rightConditionValue?: Real);
  interpolate(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size):
      Interpolation;
  static global: boolean;
  static requiredPoints: Size;
  private _n;
  private _behavior;
  private _da;
  private _monotonic;
  private _leftType;
  private _rightType;
  private _leftValue;
  private _rightValue;
}

declare type SplineGrid = Real[][];
export declare class MultiCubicSpline {
  constructor(grid: SplineGrid, y: Real[][], ae?: boolean[]);
  f(x: Real[]): Real;
}


export declare class SABRWrapper {
  constructor(t: Time, forward: Real, params: Real[], addParams: Real[]);
  volatility(x: Real): Real;
  private _t;
  private _forward;
  private _params;
  private _shift;
}
export declare class SABRSpecs {
  dimension(): Size;
  defaultValues(
      params: Real[], dummy: boolean[], forward: Real, expiryTime: Real,
      addParams: Real[]): void;
  guess(
      values: Real[], paramIsFixed: boolean[], forward: Real, expiryTime: Real,
      r: Real[], addParams: Real[]): void;
  eps1(): Real;
  eps2(): Real;
  dilationFactor(): Real;
  inverse(y: Real[], dummy1: boolean[], dummy2: Real[], dummy3: Real): Real[];
  direct(x: Real[], dummy1: boolean[], dummy2: Real[], dummy3: Real): Real[];
  weight(strike: Real, forward: Real, stdDev: Real, addParams: Real[]): Real;
  instance(t: Time, forward: Real, params: Real[], addParams: Real[]):
      SABRWrapper;
}
export declare class SABRInterpolation extends Interpolation {
  sabrInit(
      x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size, t: Time,
      forward: Real, alpha: Real, beta: Real, nu: Real, rho: Real,
      alphaIsFixed: boolean, betaIsFixed: boolean, nuIsFixed: boolean,
      rhoIsFixed: boolean, vegaWeighted?: boolean, endCriteria?: EndCriteria,
      optMethod?: OptimizationMethod, errorAccept?: Real, useMaxError?: boolean,
      maxGuesses?: Size, shift?: Real): SABRInterpolation;
  expiry(): Real;
  forward(): Real;
  alpha(): Real;
  beta(): Real;
  nu(): Real;
  rho(): Real;
  rmsError(): Real;
  maxError(): Real;
  interpolationWeights(): Real[];
  endCriteria(): EndCriteria.Type;
  private _coeffs;
}
export declare class SABR {
  constructor(
      t: Time, forward: Real, alpha: Real, beta: Real, nu: Real, rho: Real,
      alphaIsFixed: boolean, betaIsFixed: boolean, nuIsFixed: boolean,
      rhoIsFixed: boolean, vegaWeighted?: boolean, endCriteria?: EndCriteria,
      optMethod?: OptimizationMethod, errorAccept?: Real, useMaxError?: boolean,
      maxGuesses?: Size, shift?: Real);
  interpolate(x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size):
      Interpolation;
  static global: boolean;
  private _t;
  private _forward;
  private _alpha;
  private _beta;
  private _nu;
  private _rho;
  private _alphaIsFixed;
  private _betaIsFixed;
  private _nuIsFixed;
  private _rhoIsFixed;
  private _vegaWeighted;
  private _endCriteria;
  private _optMethod;
  private _errorAccept;
  private _useMaxError;
  private _maxGuesses;
  private _shift;
}

export declare namespace XABRCoeffHolder {
  interface ModelType {
    dimension(): Size;
    defaultValues(
        params: Real[], dummy: boolean[], forward: Real, expiryTime: Real,
        addParams: Real[]): void;
    guess(
        values: Real[], paramIsFixed: boolean[], forward: Real,
        expiryTime: Real, r: Real[], addParams: Real[]): void;
    eps1(): Real;
    eps2(): Real;
    dilationFactor(): Real;
    inverse(y: Real[], dummy1: boolean[], dummy2: Real[], dummy3: Real): Real[];
    direct(x: Real[], dummy1: boolean[], dummy2: Real[], dummy3: Real): Real[];
    weight(strike: Real, forward: Real, stdDev: Real, addParams: Real[]): Real;
    instance(t: Time, forward: Real, params: Real[], addParams: Real[]):
        ModelInstanceType;
  }
  interface ModelInstanceType {
    volatility(x: Real): Real;
  }
}
export declare class XABRCoeffHolder {
  constructor(
      Model: XABRCoeffHolder.ModelType, t: Time, forward: Real, params: Real[],
      paramIsFixed: boolean[], addParams: Real[]);
  updateModelInstance(): void;
  _model: XABRCoeffHolder.ModelType;
  _t: Real;
  _forward: Real;
  _params: Real[];
  _paramIsFixed: boolean[];
  _weights: Real[];
  _error: Real;
  _maxError: Real;
  _XABREndCriteria: EndCriteria.Type;
  _modelInstance: XABRCoeffHolder.ModelInstanceType;
  _addParams: Real[];
}

export declare class XABRInterpolationImpl extends
    XABRCoeffHolderInterpolationtemplateImpl {}

export declare class BasisIncompleteOrdered {
  constructor(euclideanDimension: Size);
  addVector(newVector: Real[]): boolean;
  basisSize(): Size;
  euclideanDimension(): Size;
  getBasisAsRowsInMatrix(): Matrix;
  private _currentBasis;
  private _euclideanDimension;
  private _newVector;
}
export declare class OrthogonalProjections {
  constructor(originalVectors: Matrix, multiplierCutOff: Real, tolerance: Real);
  validVectors(): boolean[];
  GetVector(index: Size): Real[];
  numberValidVectors(): Size;
  private _originalVectors;
  private _multiplierCutoff;
  private _numberVectors;
  private _numberValidVectors;
  private _dimension;
  private _validVectors;
  private _projectedVectors;
  private _orthoNormalizedVectors;
}

export declare class BiCGStabResult {
  constructor(iterations: Size, error: Real, x: Real[]);
  iterations: Size;
  error: Real;
  x: Real[];
}
export declare class BiCGstab {
  constructor(
      A: BiCGstab.MatrixMult, maxIter: Size, relTol: Real,
      preConditioner?: BiCGstab.MatrixMult);
  solve(b: Real[], x0?: Real[]): BiCGStabResult;
  norm2(a: Real[]): Real;
  protected _A: BiCGstab.MatrixMult;
  protected _M: BiCGstab.MatrixMult;
  protected _maxIter: Size;
  protected _relTol: Real;
}
export declare namespace BiCGstab {
  type MatrixMult = UnaryFunction<Real[], Real[]>;
}

export declare function CholeskyDecomposition(
    S: Matrix, flexible?: boolean): Matrix;

export declare function factorReduction(mtrx: Matrix, maxIters?: Size): Real[];

export declare function getCovariance(
    stdDev: Real[], stdDevBegin: Size, stdDevEnd: Size, corr: Matrix,
    tolerance?: Real): Matrix;
export declare class CovarianceDecomposition {
  constructor(cov: Matrix, tolerance?: Real);
  variances(): Real[];
  standardDeviations(): Real[];
  correlationMatrix(): Matrix;
  private _variances;
  private _stdDevs;
  private _correlationMatrix;
}

export declare class GMRESResult {
  constructor(errors: Real[], x: Real[]);
  errors: Real[];
  x: Real[];
}
export declare class GMRES {
  constructor(
      A: GMRES.MatrixMult, maxIter: Size, relTol: Real,
      preConditioner?: GMRES.MatrixMult);
  solve(b: Real[], x0?: Real[]): GMRESResult;
  solveWithRestart(restart: Size, b: Real[], x0?: Real[]): GMRESResult;
  protected solveImpl(b: Real[], x0: Real[]): GMRESResult;
  protected _A: GMRES.MatrixMult;
  protected _M: GMRES.MatrixMult;
  protected _maxIter: Size;
  protected _relTol: Real;
}
export declare namespace GMRES {
  type MatrixMult = UnaryFunction<Real[], Real[]>;
}

export declare function pseudoSqrt(
    matrix: Matrix, sa?: SalvagingAlgorithm.Type): Matrix;
export declare function rankReducedSqrt(
    matrix: Matrix, maxRank: Size, componentRetainedPercentage: Real,
    sa: SalvagingAlgorithm.Type): Matrix;
export declare namespace SalvagingAlgorithm {
  enum Type {
    None = 0,
    Spectral = 1,
    Hypersphere = 2,
    LowerDiagonal = 3,
    Higham = 4
  }
}

export declare function qrDecomposition(
    M: Matrix, q: Matrix, r: Matrix, pivot?: boolean): Size[];
export declare function qrSolve(
    a: Matrix, b: Real[], pivot?: boolean, d?: Real[]): Real[];

export declare class SparseILUPreconditioner {
  constructor(A: SparseMatrix, lfil?: Integer);
  L(): SparseMatrix;
  U(): SparseMatrix;
  apply(b: Real[]): Real[];
  private forwardSolve;
  private backwardSolve;
  private _L;
  private _U;
  private _lBands;
  private _uBands;
}

export declare class SparseMatrix {
  constructor();
  static from(m: Real[][]): SparseMatrix;
  to(): Real[][];
  smInit1(row_size: Integer, column_size: Integer, non_zeroes?: Size):
      SparseMatrix;
  smInit2(
      row_size: Integer, column_size: Integer, values: Real[], columns: Size[],
      rowIndex: Integer[], filled_row_until: Size): SparseMatrix;
  smInit3(
      row_size: Integer, column_size: Integer, values: Real[],
      columns: Integer[], rowIndex: Integer[],
      filled_row_until: Size): SparseMatrix;
  clone(): SparseMatrix;
  filled_size(): Size;
  row_size(): Size;
  column_size(): Size;
  f(m: Size, n: Size): Real;
  set(m: Size, n: Size, v: Real): void;
  mulScalarAssign(x: Real): SparseMatrix;
  mulScalar(x: Real): SparseMatrix;
  minusAssign(): SparseMatrix;
  mulVector(x: Real[]): Real[];
  adda(x: SparseMatrix): SparseMatrix;
  add(x: SparseMatrix): SparseMatrix;
  suba(x: SparseMatrix): SparseMatrix;
  sub(x: SparseMatrix): SparseMatrix;
  private findIndex;
  private insert;
  private _values;
  private _columns;
  private _rowIndex;
  private _column_size;
  private _row_size;
  private _filled_row_until;
}
export declare function identity_matrix(s: Size): SparseMatrix;

export declare class SVD {
  constructor(M: Matrix);
  U(): Matrix;
  V(): Matrix;
  S(): Matrix;
  singularValues(): Real[];
  norm2(): Real;
  cond(): Real;
  rank(): Size;
  solveFor(b: Real[]): Real[];
  private _U;
  private _V;
  private _s;
  private _m;
  private _n;
  private _transpose;
}

export declare class SymmetricSchurDecomposition {
  constructor(s: Matrix);
  eigenvalues(): Real[];
  eigenvectors(): Matrix;
  private _jacobiRotate;
  private _diagonal;
  private _eigenVectors;
}

export declare class FrobeniusCostFunction extends CostFunction {}

export declare class TqrEigenDecomposition {
  constructor(
      diag: Real[], sub: Real[],
      calc?: TqrEigenDecomposition.EigenVectorCalculation,
      strategy?: TqrEigenDecomposition.ShiftStrategy);
  eigenvalues(): Real[];
  eigenvectors(): Matrix;
  iterations(): Size;
  private offDiagIsZero;
  private _iter;
  private _d;
  private _ev;
}
export declare namespace TqrEigenDecomposition {
  enum EigenVectorCalculation {
    WithEigenVector = 0,
    WithoutEigenVector = 1,
    OnlyFirstRowEigenVector = 2
  }
  enum ShiftStrategy { NoShift = 0, Overrelaxation = 1, CloseEigenValue = 2 }
}

export interface OdeFunction1D {
  f1(x: Real, y: Complex): Complex;
}
export interface OdeFunction2D {
  f2(x: Real, y: Complex[]): Complex[];
}
export declare class AdaptiveRungeKutta {
  constructor(eps?: Real, h1?: Real, hmin?: Real);
  f2(ode: OdeFunction2D, y1: Complex[], x1: Real, x2: Real): Complex[];
  f1(ode: OdeFunction1D, y1: Complex, x1: Real, x2: Real): Complex;
  private rkqs;
  private rkck;
  private _eps;
  private _h1;
  private _hmin;
}

export declare class ArmijoLineSearch extends LineSearch {
  search(
      P: Problem, ecType: EndCriteria.byRef, endCriteria: EndCriteria,
      t_ini: Real): Real;
  private _alpha;
  private _beta;
}

export declare class BFGS extends LineSearchBasedMethod {
  constructor(lineSearch?: LineSearch);
  getUpdatedDirection(P: Problem, gold2: Real, oldGradient: Real[]): Real[];
  private _inverseHessian;
}

export declare class ConjugateGradient extends LineSearchBasedMethod {
  constructor(lineSearch?: LineSearch);
  protected getUpdatedDirection(P: Problem, gold2: Real, oldGradient: Real[]):
      Real[];
}

export declare class Constraint {
  constructor(impl?: Constraint.Impl);
  empty(): boolean;
  test(params: Real[]): boolean;
  upperBound(params: Real[]): Real[];
  lowerBound(params: Real[]): Real[];
  update(params: Real[], direction: Real[], beta: Real): Real;
  protected _impl: Constraint.Impl;
}
export declare class NoConstraint extends Constraint {
  constructor();
}
export declare class PositiveConstraint extends Constraint {
  constructor();
}
export declare class BoundaryConstraint extends Constraint {
  constructor(low: Real, high: Real);
}
export declare class CompositeConstraint extends Constraint {
  constructor(c1: Constraint, c2: Constraint);
}
export declare class NonhomogeneousBoundaryConstraint extends Constraint {
  constructor(low: Real[], high: Real[]);
}
export declare namespace Constraint {
  class Impl {
    constructor(...args: any[]);
    test(params: Real[]): boolean;
    upperBound(params: Real[]): Real[];
    lowerBound(params: Real[]): Real[];
    readonly isDisposed: boolean;
    dispose(): void;
    private _isDisposed;
  }
}
export declare namespace NoConstraint {
  class Impl extends Constraint.Impl {
    test(params: Real[]): boolean;
  }
}
export declare namespace PositiveConstraint {
  class Impl extends Constraint.Impl {
    test(params: Real[]): boolean;
    lowerBound(params: Real[]): Real[];
  }
}
export declare namespace BoundaryConstraint {
  class Impl extends Constraint.Impl {
    constructor(low: Real, high: Real);
    test(params: Real[]): boolean;
    upperBound(params: Real[]): Real[];
    lowerBound(params: Real[]): Real[];
    private _low;
    private _high;
  }
}
export declare namespace CompositeConstraint {
  class Impl extends Constraint.Impl {
    constructor(c1: Constraint, c2: Constraint);
    test(params: Real[]): boolean;
    upperBound(params: Real[]): Real[];
    lowerBound(params: Real[]): Real[];
    private _c1;
    private _c2;
  }
}
export declare namespace NonhomogeneousBoundaryConstraint {
  class Impl extends Constraint.Impl {
    constructor(low: Real[], high: Real[]);
    test(params: Real[]): boolean;
    upperBound(params: Real[]): Real[];
    lowerBound(params: Real[]): Real[];
    private _low;
    private _high;
  }
}

export declare class CostFunction {
  value(x: Real[]): Real;
  values(x: Real[]): Real[];
  gradient(grad: Real[], x: Real[]): void;
  valueAndGradient(grad: Real[], x: Real[]): Real;
  jacobian(jac: Matrix, x: Real[]): void;
  valuesAndJacobian(jac: Matrix, x: Real[]): Real[];
  finiteDifferenceEpsilon(): Real;
  readonly isDisposed: boolean;
  dispose(): void;
  _isDisposed: boolean;
}
export declare class ParametersTransformation {
  direct(x: Real[]): Real[];
  inverse(x: Real[]): Real[];
}

export declare class DifferentialEvolution extends OptimizationMethod {
  constructor(configuration?: DifferentialEvolution.Configuration);
  configuration(): DifferentialEvolution.Configuration;
  minimize(p: Problem, endCriteria: EndCriteria): EndCriteria.Type;
  private fillInitialPopulation;
  private getCrossoverMask;
  private getMutationProbabilities;
  private adaptSizeWeights;
  private adaptCrossover;
  private calculateNextGeneration;
  private rotateArray;
  private crossover;
  private _configuration;
  private _upperBound;
  private _lowerBound;
  private _currGenSizeWeights;
  private _currGenCrossover;
  private _bestMemberEver;
  private _rng;
}
export declare namespace DifferentialEvolution {
  enum Strategy {
    Rand1Standard = 0,
    BestMemberWithJitter = 1,
    CurrentToBest2Diffs = 2,
    Rand1DiffWithPerVectorDither = 3,
    Rand1DiffWithDither = 4,
    EitherOrWithOptimalRecombination = 5,
    Rand1SelfadaptiveWithRotation = 6
  }
  enum CrossoverType { Normal = 0, Binomial = 1, Exponential = 2 }
  class Candidate {
    constructor(size?: Size);
    values: Real[];
    cost: Real;
  }
  class Configuration {
    constructor();
    withBounds(b?: boolean): Configuration;
    withCrossoverProbability(p: Real): Configuration;
    withPopulationMembers(n: Size): Configuration;
    withSeed(s: Size): Configuration;
    withAdaptiveCrossover(b?: boolean): Configuration;
    withStepsizeWeight(w: Real): Configuration;
    withCrossoverType(t: CrossoverType): Configuration;
    withStrategy(s: Strategy): Configuration;
    strategy: Strategy;
    crossoverType: CrossoverType;
    populationMembers: Size;
    stepsizeWeight: Real;
    crossoverProbability: Real;
    seed: Size;
    applyBounds: boolean;
    crossoverIsAdaptive: boolean;
  }
}

export declare class EndCriteria {
  constructor(
      maxIterations: Size, maxStationaryStateIterations: Size,
      rootEpsilon: Real, functionEpsilon: Real, gradientNormEpsilon: Real);
  checkMaxIterations(iteration: Size, ref: EndCriteria.byRef): boolean;
  checkStationaryPoint(xOld: Real, xNew: Real, ref: EndCriteria.byRef): boolean;
  checkStationaryFunctionValue(
      fxOld: Real, fxNew: Real, ref: EndCriteria.byRef): boolean;
  checkStationaryFunctionAccuracy(
      f: Real, positiveOptimization: boolean, ref: EndCriteria.byRef): boolean;
  checkZeroGradientNorm(gradientNorm: Real, ref: EndCriteria.byRef): boolean;
  isValid(
      iteration: Size, positiveOptimization: boolean, fold: Real,
      normgold: Real, fnew: Real, normgnew: Real,
      ref: EndCriteria.byRef): boolean;
  maxIterations(): Size;
  maxStationaryStateIterations(): Size;
  rootEpsilon(): Real;
  functionEpsilon(): Real;
  gradientNormEpsilon(): Real;
  protected _maxIterations: Size;
  protected _maxStationaryStateIterations: Size;
  protected _rootEpsilon: Real;
  protected _functionEpsilon: Real;
  protected _gradientNormEpsilon: Real;
}
export declare namespace EndCriteria {
  interface byRef {
    ecType?: Type;
    statStateIterations?: Size;
  }
  enum Type {
    None = 0,
    MaxIterations = 1,
    StationaryPoint = 2,
    StationaryFunctionValue = 3,
    StationaryFunctionAccuracy = 4,
    ZeroGradientNorm = 5,
    Unknown = 6
  }
}

export declare class GoldsteinLineSearch extends LineSearch {
  search(
      P: Problem, ecType: EndCriteria.byRef, endCriteria: EndCriteria,
      t_ini: Real): Real;
  private _alpha;
  private _beta;
  private _extrapolation;
}

export declare class LeastSquareProblem {
  size(): Size;
  targetAndValue(x: Real[], target: Real[], fct2fit: Real[]): void;
  targetValueAndGradient(
      x: Real[], grad_fct2fit: Matrix, target: Real[], fct2fit: Real[]): void;
}
export declare class LeastSquareFunction extends CostFunction {
  constructor(lsp: LeastSquareProblem);
  value(x: Real[]): Real;
  values(x: Real[]): Real[];
  gradient(grad_f: Real[], x: Real[]): void;
  valueAndGradient(grad_f: Real[], x: Real[]): Real;
  protected _lsp: LeastSquareProblem;
}
export declare class NonLinearLeastSquare {
  constructor(
      c: Constraint, accuracy?: Real, maxiter?: Size, om?: OptimizationMethod);
  perform(lsProblem: LeastSquareProblem): Real[];
  setInitialValue(initialValue: Real[]): void;
  results(): Real[];
  residualNorm(): Real;
  lastValue(): Real;
  exitFlag(): Integer;
  iterationsNumber(): Integer;
  private _results;
  private _initialValue;
  private _resnorm;
  private _exitFlag;
  private _accuracy;
  private _bestAccuracy;
  private _maxIterations;
  private _nbIterations;
  private _om;
  private _c;
}

export declare class LevenbergMarquardt extends OptimizationMethod {
  constructor(
      epsfcn?: Real, xtol?: Real, gtol?: Real,
      useCostFunctionsJacobian?: boolean);
  minimize(P: Problem, endCriteria: EndCriteria): EndCriteria.Type;
  getInfo(): Integer;
  fcn(m: Integer, n: Integer, x: Real[], fvec: Real[], ref: {}): void;
  jacFcn(m: Integer, n: Integer, x: Real[], fjac: Real[], ref: {}): void;
  private _currentProblem;
  private _initCostValues;
  private _initJacobian;
  private _info;
  private _epsfcn;
  private _xtol;
  private _gtol;
  private _useCostFunctionsJacobian;
}

export declare class LineSearch {
  lastX(): Real[];
  lastFunctionValue(): Real;
  lastGradient(): Real[];
  lastGradientNorm2(): Real;
  succeed(): boolean;
  searchDirection: Real[];
  search(p: Problem, ecType: EndCriteria.byRef, ec: EndCriteria, t_ini: Real):
      Real;
  update(params: Real[], direction: Real[], beta: Real, constraint: Constraint):
      Real;
  protected _searchDirection: Real[];
  protected _xtd: Real[];
  protected _gradient: Real[];
  protected _qt: Real;
  protected _qpt: Real;
  protected _succeed: boolean;
}

export declare class LineSearchBasedMethod extends OptimizationMethod {
  constructor(lSearch: LineSearch);
  minimize(P: Problem, endCriteria: EndCriteria): EndCriteria.Type;
  protected getUpdatedDirection(p: Problem, gold2: Real, gradient: Real[]):
      Real[];
  protected _lineSearch: LineSearch;
}

export declare class OptimizationMethod {
  minimize(P: Problem, endCriteria: EndCriteria): EndCriteria.Type;
  readonly isDisposed: boolean;
  dispose(): void;
  private _isDisposed;
}

export declare class Problem {
  constructor(
      costFunction: CostFunction, constraint: Constraint, initialValue: Real[]);
  constraint(): Constraint;
  costFunction(): CostFunction;
  setCurrentValue(currentValue: Real[]): void;
  currentValue(): Real[];
  setFunctionValue(functionValue: Real): void;
  functionValue(): Real;
  setGradientNormValue(squaredNorm: Real): void;
  gradientNormValue(): Real;
  functionEvaluation(): Integer;
  gradientEvaluation(): Integer;
  value(x: Real[]): Real;
  values(x: Real[]): Real[];
  gradient(grad_f: Real[], x: Real[]): void;
  valueAndGradient(grad_f: Real[], x: Real[]): Real;
  reset(): void;
  protected _costFunction: CostFunction;
  protected _constraint: Constraint;
  protected _currentValue: Real[];
  protected _functionValue: Real;
  protected _squaredNorm: Real;
  protected _functionEvaluation: Integer;
  protected _gradientEvaluation: Integer;
}

export declare class ProjectedConstraint extends Constraint {
  init1(
      constraint: Constraint, parameterValues: Real[],
      fixParameters: boolean[]): ProjectedConstraint;
  init2(constraint: Constraint, projection: Projection): ProjectedConstraint;
}
export declare namespace ProjectedConstraint {
  class Impl extends Constraint.Impl {
    init1(
        constraint: Constraint, parameterValues: Real[],
        fixParameters: boolean[]): Impl;
    init2(constraint: Constraint, projection: Projection): Impl;
    test(params: Real[]): boolean;
    upperBound(params: Real[]): Real[];
    lowerBound(params: Real[]): Real[];
    private _constraint;
    private _projection;
  }
}

export declare class ProjectedCostFunction extends CostFunctionProjection {
  init1(
      costFunction: CostFunction, parameterValues: Real[],
      fixParameters: boolean[]): ProjectedCostFunction;
  init2(costFunction: CostFunction, projection: Projection):
      ProjectedCostFunction;
  value(freeParameters: Real[]): Real;
  values(freeParameters: Real[]): Real[];
}

export declare class Projection {
  constructor(parameterValues: Real[], fixParameters?: boolean[]);
  project(parameters: Real[]): Real[];
  include(projectedParameters: Real[]): Real[];
  mapFreeParameters(parameterValues: Real[]): void;
  _numberOfFreeParameters: Size;
  _fixedParameters: Real[];
  _actualParameters: Real[];
  _fixParameters: boolean[];
}

export declare class Simplex extends OptimizationMethod {
  constructor(lambda: Real);
  minimize(P: Problem, endCriteria: EndCriteria): EndCriteria.Type;
  private extrapolate;
  private _lambda;
  private _vertices;
  private _values;
  private _sum;
}

export declare class SimulatedAnnealing extends OptimizationMethod {
  constructor(RNG?: any);
  init1(lambda: Real, T0: Real, epsilon: Real, m: Size, rng?: any):
      SimulatedAnnealing;
  init2(lambda: Real, T0: Real, K: Size, alpha: Real, rng?: any):
      SimulatedAnnealing;
  RNG: any;
}
export declare namespace SimulatedAnnealing {
  enum Scheme { ConstantFactor = 0, ConstantBudget = 1 }
}

export declare class SphereCylinderOptimizer {
  constructor(
      r: Real, s: Real, alpha: Real, z1: Real, z2: Real, z3: Real,
      zweight?: Real);
  isIntersectionNonEmpty(): boolean;
  findClosest(maxIterations: Size, tolerance: Real, byref: byRef): void;
  findByProjection(byref: byRef): boolean;
  private _nonEmpty;
}
interface byRef {
  y1: Real;
  y2: Real;
  y3: Real;
}


export declare class SteepestDescent extends LineSearchBasedMethod {
  constructor(lineSearch?: LineSearch);
  getUpdatedDirection(P: Problem, gold2: Real, oldGradient: Real[]): Real[];
}

export declare class BoxMullerGaussianRng {
  constructor(uniformGenerator: RNG<Real>);
  next(): Sample<Real>;
  private _uniformGenerator;
  private _returnFirst;
  private _firstValue;
  private _secondValue;
  private _firstWeight;
  private _secondWeight;
  private _weight;
}

export declare class CLGaussianRng {
  constructor(uniformGenerator: RNG<Real>);
  next(): Sample<Real>;
  private _uniformGenerator;
}

export declare class FaureRsg implements USG<Real[]> {
  init(dimensionality: Size): FaureRsg;
  nextIntSequence(): Integer[];
  lastIntSequence(): Integer[];
  nextSequence(): FaureRsg.sample_type;
  lastSequence(): FaureRsg.sample_type;
  dimension(): Size;
  private generateNextIntSequence;
  private _dimensionality;
  private _sequence;
  private _integerSequence;
  private _bary;
  private _gray;
  private _base;
  private _mbit;
  private _powBase;
  private _addOne;
  private pascal3D;
  private _normalizationFactor;
}
export declare namespace FaureRsg {
  type sample_type = Sample<Real[]>;
}

export declare class HaltonRsg implements USG<Real[]> {
  init(
      dimensionality: Size, seed?: BigNatural, randomStart?: boolean,
      randomShift?: boolean): HaltonRsg;
  nextSequence(): HaltonRsg.sample_type;
  lastSequence(): HaltonRsg.sample_type;
  dimension(): Size;
  private _dimensionality;
  private _sequenceCounter;
  private _sequence;
  private _randomStart;
  private _randomShift;
}
export declare namespace HaltonRsg {
  type sample_type = Sample<Real[]>;
}

export declare class InverseCumulativeRng implements RNG<Real> {
  constructor(
      uniformGenerator: RNG<Real>,
      inverseCumulative: UnaryFunction<Real, Real>);
  next(): InverseCumulativeRng.sample_type;
  private _uniformGenerator;
  private _ICND;
}
export declare namespace InverseCumulativeRng {
  type sample_type = Sample<Real>;
  type urng_type = RNG<Real>;
}

export declare class InverseCumulativeRsg implements USG<Real[]> {
  constructor(
      uniformSequenceGenerator: USG<Real[]>,
      inverseCumulative?: UnaryFunction<Real, Real>);
  nextSequence(): InverseCumulativeRsg.sample_type;
  lastSequence(): Sample<Real[]>;
  dimension(): Size;
  private _uniformSequenceGenerator;
  private _dimention;
  private _x;
  private _ICD;
}
export declare namespace InverseCumulativeRsg {
  type sample_type = Sample<Real[]>;
}

export declare class KnuthUniformRng implements RNG<Real> {
  init1(seed: Integer): KnuthUniformRng;
  next(): Sample<Real>;
  private mod_sum;
  private is_odd;
  private ranf_start;
  private ranf_array;
  private ranf_arr_cycle;
  private _ranf_arr_buf;
  private _ranf_arr_ptr;
  private _ranf_arr_sentinel;
  private _ran_u;
}

export declare class LatticeRsg {
  constructor(dimensionality: Size, z: Real[], N: Size);
  skipTo(n: BigNatural): void;
  nextSequence(): LatticeRsg.sample_type;
  lastSequence(): LatticeRsg.sample_type;
  dimension(): Size;
  private _dimensionality;
  private _N;
  private _i;
  private _z;
  private _sequence;
}
export declare namespace LatticeRsg {
  type sample_type = Sample<Real[]>;
}

export declare class LatticeRule {
  static getRule(name: LatticeRule.type, Z: Real[], N: Integer): void;
}
export declare namespace LatticeRule {
  enum type { A = 0, B = 1, C = 2, D = 3 }
}

export declare class LecuyerUniformRng implements RNG<Real> {
  init1(seed: Integer): LecuyerUniformRng;
  next(): Sample<Real>;
  private _temp1;
  private _temp2;
  private _y;
  private _buffer;
}

export declare const N_PRIMITIVES = 8129334;
export declare const PPMT_MAX_DIM = 21200;
export declare const N_MAX_DEGREE = 18;

export declare class MersenneTwisterUniformRng implements RNG<Real> {
  init1(seed: Integer): MersenneTwisterUniformRng;
  init2(seeds: Integer[]): MersenneTwisterUniformRng;
  next(): Sample<Real>;
  nextReal(): Real;
  nextInt32(): Integer;
  private seedInitialization;
  private twist;
  private mt;
  private mti;
}

export declare class RandomizedLDS {
  constructor(LDS: USG<Real[]>, PRS?: USG<Real[]>);
  init1(ldsg: USG<Real[]>, prsg?: USG<Real[]>): RandomizedLDS;
  init2(ldsg: USG<Real[]>): RandomizedLDS;
  init3(dimensionality: Size, ldsSeed?: BigNatural, prsSeed?: BigNatural):
      RandomizedLDS;
  nextSequence(): RandomizedLDS.sample_type;
  lastSequence(): RandomizedLDS.sample_type;
  nextRandomizer(): void;
  dimension(): Size;
  LDS: USG<Real[]>;
  PRS: USG<Real[]>;
  private _ldsg;
  private _pristineldsg;
  private _prsg;
  private _dimension;
  private x;
  private _randomizer;
}
export declare namespace RandomizedLDS {
  type sample_type = Sample<Real[]>;
}

export declare class RandomSequenceGenerator implements USG<Real[]> {
  constructor(rng: RNG<Real>);
  init1(dimensionality: Size): RandomSequenceGenerator;
  init2(dimensionality: Size, seed: BigNatural): RandomSequenceGenerator;
  nextSequence(): RandomSequenceGenerator.sample_type;
  nextInt32Sequence(): BigNatural[];
  lastSequence(): RandomSequenceGenerator.sample_type;
  dimension(): Size;
  private _dimensionality;
  private _rng;
  private _sequence;
  private _int32Sequence;
}
export declare namespace RandomSequenceGenerator {
  type sample_type = Sample<Real[]>;
}

export declare class Ranlux3UniformRng {}
export declare class Ranlux4UniformRng {}

export interface RNG<T> {
  next(): Sample<T>;
  nextInt32?(): Size;
  init1?(seed: T): RNG<T>;
  init2?(seeds: T[]): RNG<T>;
}
export interface USG<T> {
  nextSequence(): Sample<T>;
  lastSequence(): Sample<T>;
  dimension(): Size;
  init?(dimensionality: Size, seed?: BigNatural): USG<T>;
}
export declare class GenericPseudoRandom {
  constructor(URNG: RNG<Real>, IC: UnaryFunction<Real, Real>);
  make_sequence_generator(dimension: Size, seed: BigNatural):
      GenericPseudoRandom.rsg_type;
  IC: UnaryFunction<Real, Real>;
  URNG: RNG<Real>;
  allowsErrorEstimate: boolean;
}
export declare class PseudoRandom extends GenericPseudoRandom {
  constructor();
  make_sequence_generator(dimension: Size, seed: BigNatural):
      PseudoRandom.rsg_type;
}
export declare class PoissonPseudoRandom extends GenericPseudoRandom {
  constructor();
  make_sequence_generator(dimension: Size, seed: BigNatural):
      PoissonPseudoRandom.rsg_type;
}
export declare class GenericLowDiscrepancy {
  constructor(URSG: USG<Real[]>, IC: UnaryFunction<Real, Real>);
  make_sequence_generator(dimension: Size, seed: BigNatural):
      InverseCumulativeRsg;
  IC: UnaryFunction<Real, Real>;
  URSG: USG<Real[]>;
  allowsErrorEstimate: boolean;
}
export declare class LowDiscrepancy extends GenericLowDiscrepancy {
  constructor();
  make_sequence_generator(dimension: Size, seed: BigNatural):
      InverseCumulativeRsg;
}
export declare namespace GenericPseudoRandom {
  type urng_type = RNG<Real>;
  type rng_type = InverseCumulativeRng;
  type rsg_type = InverseCumulativeRsg;
  type ursg_type = RandomSequenceGenerator;
  const allowsErrorEstimate = true;
}
export declare namespace PseudoRandom {
  type urng_type = RNG<Real>;
  type rng_type = InverseCumulativeRng;
  type rsg_type = InverseCumulativeRsg;
  type ursg_type = RandomSequenceGenerator;
  const allowsErrorEstimate = true;
}
export declare namespace PoissonPseudoRandom {
  type urng_type = RNG<Real>;
  type rng_type = InverseCumulativeRng;
  type rsg_type = InverseCumulativeRsg;
  type ursg_type = RandomSequenceGenerator;
  const allowsErrorEstimate = true;
}
export declare namespace GenericLowDiscrepancy {
  const allowsErrorEstimate = false;
}
export declare namespace LowDiscrepancy {
  type rsg_type = InverseCumulativeRsg;
  const allowsErrorEstimate = false;
}
export declare type RNGTraits =
    PseudoRandom | PoissonPseudoRandom | LowDiscrepancy;

export declare namespace SeedGenerator {
  function get(): number;
  function initialize(): void;
}

export declare class SobolBrownianBridgeRsg {
  constructor(
      factors: Size, steps: Size, ordering?: SobolBrownianGenerator.Ordering,
      seed?: Integer, directionIntegers?: SobolRsg.DirectionIntegers);
  nextSequence(): Sample<Real[]>;
  lastSequence(): Sample<Real[]>;
  dimension(): Size;
  private _factors;
  private _steps;
  private _dim;
  private _seq;
  private _gen;
}

export declare class SobolRsg implements USG<Real[]> {
  init(
      dimensionality: Size, seed?: BigNatural,
      directionIntegers?: SobolRsg.DirectionIntegers): SobolRsg;
  skipTo(skip: Size): void;
  nextInt32Sequence(): Size[];
  nextSequence(): Sample<Real[]>;
  lastSequence(): Sample<Real[]>;
  dimension(): Size;
  private _dimensionality;
  private _sequenceCounter;
  private _firstDraw;
  private _sequence;
  private _integerSequence;
  private _directionIntegers;
}
export declare namespace SobolRsg {
  enum DirectionIntegers {
    Unit = 0,
    Jaeckel = 1,
    SobolLevitan = 2,
    SobolLevitanLemieux = 3,
    JoeKuoD5 = 4,
    JoeKuoD6 = 5,
    JoeKuoD7 = 6,
    Kuo = 7,
    Kuo2 = 8,
    Kuo3 = 9
  }
}

export declare class StochasticCollocationInvCDF implements
    UnaryFunction<Real, Real> {
  constructor(
      invCDF: UnaryFunction<Real, Real>, lagrangeOrder: Size, pMax?: Real,
      pMin?: Real);
  value(x: Real): Real;
  f(u: Real): Real;
  private _x;
  private _sigma;
  private _y;
  private _interpl;
}

export declare class Brent extends Solver1D<Brent> {
  solveImpl(f: UnaryFunction<Real, Real>, xAccuracy: Real): Real;
  private sign;
}

export declare class FalsePosition extends Solver1D<FalsePosition> {
  solveImpl(f: UnaryFunction<Real, Real>, xAccuracy: Real): Real;
}

export declare class FiniteDifferenceNewtonSafe extends
    Solver1D<FiniteDifferenceNewtonSafe> {
  solveImpl(f: UnaryFunction<Real, Real>, xAccuracy: Real): Real;
}

export declare class Halley extends Solver1D<Halley> {
  solveImpl(f: UnaryFunction<Real, Real>, xAccuracy: Real): Real;
}

export declare class HalleySafe extends Solver1D<HalleySafe> {
  solveImpl(f: UnaryFunction<Real, Real>, xAccuracy: Real): Real;
}

export declare class Bisection extends Solver1D<Bisection> {
  solveImpl(f: UnaryFunction<Real, Real>, xAccuracy: Real): Real;
}

export declare class NewtonSafe extends Solver1D<NewtonSafe> {
  solveImpl(f: UnaryFunction<Real, Real>, xAccuracy: Real): Real;
}

export declare class Newton extends Solver1D<Newton> {
  solveImpl(f: UnaryFunction<Real, Real>, xAccuracy: Real): Real;
}

export declare class Ridder extends Solver1D<Ridder> {
  solveImpl(f: UnaryFunction<Real, Real>, xAcc: Real): Real;
  private sign;
}

export declare class Secant extends Solver1D<Secant> {
  solveImpl(f: UnaryFunction<Real, Real>, xAccuracy: Real): Real;
}

export declare class ConvergenceStatistics {
  constructor(T: any, U?: any);
  add(value: Real, weight?: Real): void;
  addSequence(values: Real[], weights?: Real[]): void;
  reset(): void;
  convergenceTable(): Array<[Size, Real]>;
  samples1(): Size;
  samples2(inRange: UnaryFunction<Real, boolean>): Size;
  weightSum1(): Real;
  weightSum2(inRange: UnaryFunction<Real, boolean>): Real;
  min(): Real;
  max(): Real;
  mean(): Real;
  variance(): Real;
  errorEstimate(): Real;
  expectationValue1(f: UnaryFunction<Real, Real>): Real;
  expectationValue2(
      f: UnaryFunction<Real, Real>,
      inRange: UnaryFunction<Real, boolean>): [Real, Size];
  standardDeviation(): Real;
  skewness(): Real;
  kurtosis(): Real;
  percentile(percent: Real): Real;
  topPercentile(percent: Real): Real;
  downsideSamples(): Size;
  downsideWeightSum(): Real;
  gaussianDownsideVariance(): Real;
  gaussianDownsideDeviation(): Real;
  gaussianRegret(target: Real): Real;
  gaussianPercentile(percentile: Real): Real;
  gaussianTopPercentile(percentile: Real): Real;
  gaussianPotentialUpside(percentile: Real): Real;
  gaussianValueAtRisk(percentile: Real): Real;
  gaussianExpectedShortfall(percentile: Real): Real;
  gaussianShortfall(target: Real): Real;
  gaussianAverageShortfall(target: Real): Real;
  T: any;
  U: any;
  private _table;
  private _samplingRule;
  private _nextSampleSize;
}
export declare class DoublingConvergenceSteps {
  initialSamples(): Size;
  nextSamples(current: Size): Size;
}

export declare class DiscrepancyStatistics extends SequenceStatistics {
  constructor(dimension: Size);
  add(sample: Real[], weight?: Real): void;
  reset(dimension?: Size): void;
  discrepancy(): Real;
  private _adiscr;
  private _cdiscr;
  private _bdiscr;
  private _ddiscr;
}

export declare class GenericGaussianStatistics {
  constructor(S: any);
  gaussianDownsideVariance(): Real;
  gaussianDownsideDeviation(): Real;
  gaussianRegret(target: Real): Real;
  gaussianPercentile(percentile: Real): Real;
  gaussianTopPercentile(percentile: Real): Real;
  gaussianPotentialUpside(percentile: Real): Real;
  gaussianValueAtRisk(percentile: Real): Real;
  gaussianExpectedShortfall(percentile: Real): Real;
  gaussianShortfall(target: Real): Real;
  gaussianAverageShortfall(target: Real): Real;
  data(): Array<[Real, Real]>;
  add(value: Real, weight?: Real): void;
  addSequence(value: Real[], weight?: Real[]): void;
  samples1(): Size;
  samples2(inRange: UnaryFunction<Real, boolean>): Size;
  weightSum1(): Real;
  weightSum2(inRange: UnaryFunction<Real, boolean>): Real;
  min(): Real;
  max(): Real;
  mean(): Real;
  variance(): Real;
  errorEstimate(): Real;
  expectationValue1(f: UnaryFunction<Real, Real>): Real;
  expectationValue2(
      f: UnaryFunction<Real, Real>,
      inRange: UnaryFunction<Real, boolean>): [Real, Size];
  standardDeviation(): Real;
  skewness(): Real;
  kurtosis(): Real;
  percentile(percent: Real): Real;
  topPercentile(percent: Real): Real;
  downsideSamples(): Size;
  downsideWeightSum(): Real;
  downsideVariance(): Real;
  downsideDeviation(): Real;
  reset(): void;
  reserve(n: Size): void;
  sort(): void;
  S: any;
}
export declare class GaussianStatistics extends GenericGaussianStatistics {
  constructor();
}
export declare namespace GaussianStatistics {
  type value_type = Real;
}
export declare class StatsHolder {
  constructor(mean: Real, standardDeviation: Real);
  mean(): Real;
  standardDeviation(): Real;
  private _mean;
  private _standardDeviation;
}
export declare namespace StatsHolder {
  type value_type = Real;
}

export declare class GeneralStatistics {
  constructor();
  samples1(): Size;
  samples2(inRange: UnaryFunction<Real, boolean>): Size;
  data(): Array<[Real, Real]>;
  weightSum1(): Real;
  weightSum2(inRange: UnaryFunction<Real, boolean>): Real;
  mean(): Real;
  variance(): Real;
  standardDeviation(): Real;
  errorEstimate(): Real;
  skewness(): Real;
  kurtosis(): Real;
  min(): Real;
  max(): Real;
  expectationValue1(f: UnaryFunction<Real, Real>): Real;
  expectationValue2(
      f: UnaryFunction<Real, Real>,
      inRange: UnaryFunction<Real, boolean>): [Real, Size];
  percentile(percent: Real): Real;
  topPercentile(percent: Real): Real;
  add(value: Real, weight?: Real): void;
  addSequence(value: Real[], weight?: Real[]): void;
  reset(): void;
  reserve(n: Size): void;
  sort(): void;
  private _samples;
  private _sorted;
}
export declare namespace GeneralStatistics {
  type value_type = Real;
}

export declare class Histogram {
  init1(data: Real[], breaks: Size): Histogram;
  init2(data: Real[], algorithm: Histogram.Algorithm): Histogram;
  init3(data: Real[], breaks: Real[]): Histogram;
  bins(): Size;
  breaks(): Real[];
  algorithm(): Histogram.Algorithm;
  empty(): boolean;
  counts(i: Size): Size;
  frequency(i: Size): Real;
  private calculate;
  private _data;
  private _bins;
  private _algorithm;
  private _breaks;
  private _counts;
  private _frequency;
}
export declare namespace Histogram {
  enum Algorithm { None = 0, Sturges = 1, FD = 2, Scott = 3 }
}

export declare class IncrementalStatistics {
  constructor();
  samples1(): Size;
  samples2(inRange: any): Size;
  weightSum1(): Real;
  weightSum2(inRange: any): Size;
  mean(): Real;
  variance(): Real;
  standardDeviation(): Real;
  errorEstimate(): Real;
  skewness(): Real;
  kurtosis(): Real;
  min(): Real;
  max(): Real;
  downsideSamples(): Size;
  downsideWeightSum(): Real;
  downsideVariance(): Real;
  downsideDeviation(): Real;
  add(value: Real, valueWeight?: Real): void;
  addSequence(value: Real[], weight?: Real[]): void;
  reset(): void;
  data(): Array<[Real, Real]>;
  private _data;
  private _downsideData;
}

export declare class GenericSequenceStatistics {
  constructor(S: any);
  init(dimension?: Size): GenericSequenceStatistics;
  size(): Size;
  reset(dimension?: Size): void;
  add(sample: Real[], weight?: Real): void;
  samples1(): Size;
  samples2(inRange: any): Size;
  weightSum1(): Real;
  weightSum2(inRange: any): Size;
  mean(): Real[];
  variance(): Real[];
  standardDeviation(): Real[];
  downsideVariance(): Real[];
  downsideDeviation(): Real[];
  semiVariance(): Real[];
  semiDeviation(): Real[];
  errorEstimate(): Real[];
  skewness(): Real[];
  kurtosis(): Real[];
  min(): Real[];
  max(): Real[];
  gaussianPercentile(x: Real): Real[];
  gaussianPotentialUpside(x: Real): Real[];
  gaussianValueAtRisk(x: Real): Real[];
  gaussianExpectedShortfall(x: Real): Real[];
  gaussianShortfall(x: Real): Real[];
  gaussianAverageShortfall(x: Real): Real[];
  percentile(x: Real): Real[];
  potentialUpside(x: Real): Real[];
  valueAtRisk(x: Real): Real[];
  expectedShortfall(x: Real): Real[];
  regret(x: Real): Real[];
  shortfall(x: Real): Real[];
  averageShortfall(x: Real): Real[];
  covariance(): Matrix;
  correlation(): Matrix;
  S: any;
  protected _dimension: Size;
  protected _stats: any[];
  protected _results: Real[];
  protected _quadraticSum: Matrix;
}
export declare class SequenceStatistics extends GenericSequenceStatistics {
  constructor(dimension?: Size);
}
export declare class SequenceStatisticsInc extends GenericSequenceStatistics {
  constructor(dimension?: Size);
}

export declare class GenericRiskStatistics {
  constructor(S: any);
  semiVariance(): Real;
  semiDeviation(): Real;
  downsideVariance(): Real;
  downsideDeviation(): Real;
  regret(target: Real): Real;
  potentialUpside(centile: Real): Real;
  valueAtRisk(centile: Real): Real;
  expectedShortfall(centile: Real): Real;
  shortfall(target: Real): Real;
  averageShortfall(target: Real): Real;
  data(): Array<[Real, Real]>;
  add(value: Real, weight?: Real): void;
  addSequence(value: Real[], weight?: Real[]): void;
  samples1(): Size;
  samples2(inRange: UnaryFunction<Real, boolean>): Size;
  weightSum1(): Real;
  weightSum2(inRange: UnaryFunction<Real, boolean>): Real;
  min(): Real;
  max(): Real;
  mean(): Real;
  variance(): Real;
  errorEstimate(): Real;
  expectationValue1(f: UnaryFunction<Real, Real>): Real;
  expectationValue2(
      f: UnaryFunction<Real, Real>,
      inRange: UnaryFunction<Real, boolean>): [Real, Size];
  standardDeviation(): Real;
  skewness(): Real;
  kurtosis(): Real;
  percentile(percent: Real): Real;
  topPercentile(percent: Real): Real;
  downsideSamples(): Size;
  downsideWeightSum(): Real;
  gaussianDownsideVariance(): Real;
  gaussianDownsideDeviation(): Real;
  gaussianRegret(target: Real): Real;
  gaussianPercentile(percentile: Real): Real;
  gaussianTopPercentile(percentile: Real): Real;
  gaussianPotentialUpside(percentile: Real): Real;
  gaussianValueAtRisk(percentile: Real): Real;
  gaussianExpectedShortfall(percentile: Real): Real;
  gaussianShortfall(target: Real): Real;
  gaussianAverageShortfall(target: Real): Real;
  reset(): void;
  reserve(n: Size): void;
  sort(): void;
  S: any;
}
export declare class RiskStatistics extends GenericRiskStatistics {
  constructor();
}

export declare type Statistics = RiskStatistics;
export declare type BaseStat = GeneralStatistics | GaussianStatistics |
    IncrementalStatistics | RiskStatistics;
export declare function createStat(S: any): any;

declare class CashFlowObserver implements Observable, Observer, Event,
                                          CashFlow {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  date(): Date;
  hasOccurred: (refDate: Date, includeRefDate: boolean) => boolean;
  amount1(): Real;
  exCouponDate: () => Date;
  tradingExCoupon: () => boolean;
  accept(v: AcyclicVisitor): void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
}

export declare class CmsCouponPricerMeanRevertingPricer implements
    Observable, Observer, FloatingRateCouponPricer, CmsCouponPricer,
    MeanRevertingPricer {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update: () => void;
  deepUpdate: () => void;
  swapletPrice(): Real;
  swapletRate(): Rate;
  capletPrice(effectiveCap: Rate): Real;
  capletRate(effectiveCap: Rate): Rate;
  floorletPrice(effectiveFloor: Rate): Real;
  floorletRate(effectiveFloor: Rate): Rate;
  initialize(coupon: FloatingRateCoupon): void;
  init: (v?: Handle<SwaptionVolatilityStructure>) => CmsCouponPricer;
  swaptionVolatility: () => Handle<SwaptionVolatilityStructure>;
  setSwaptionVolatility: (v: Handle<SwaptionVolatilityStructure>) => void;
  meanReversion(): Real;
  setMeanReversion(h: Handle<Quote>): void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _swaptionVol: Handle<SwaptionVolatilityStructure>;
}

declare class CouponLazyObject implements Observable, Observer, Event, CashFlow,
                                          Coupon, LazyObject {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  accept(v: AcyclicVisitor): void;
  date: () => Date;
  hasOccurred: (refDate: Date, includeRefDate: boolean) => boolean;
  amount1(): Real;
  exCouponDate: () => Date;
  tradingExCoupon: () => boolean;
  init:
      (paymentDate: Date, nominal: Real, accrualStartDate: Date,
       accrualEndDate: Date, refPeriodStart?: Date, refPeriodEnd?: Date,
       exCouponDate?: Date) => Coupon;
  nominal: () => Real;
  accrualStartDate: () => Date;
  accrualEndDate: () => Date;
  referencePeriodStart: () => Date;
  referencePeriodEnd: () => Date;
  accrualPeriod: () => Time;
  accruedPeriod: (d: Date) => Time;
  accrualDays: () => Integer;
  accruedDays: (d: Date) => Integer;
  rate(): Rate;
  dayCounter(): DayCounter;
  accruedAmount(d: Date): Real;
  recalculate: () => void;
  freeze: () => void;
  unfreeze: () => void;
  alwaysForwardNotifications: () => void;
  calculate: () => void;
  performCalculations(): void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _paymentDate: Date;
  _nominal: Real;
  _accrualStartDate: Date;
  _accrualEndDate: Date;
  _refPeriodStart: Date;
  _refPeriodEnd: Date;
  _exCouponDate: Date;
  _accrualPeriod: Real;
  _calculated: boolean;
  _frozen: boolean;
  _alwaysForward: boolean;
}

declare class CouponObserver implements Observable, Observer, Event, CashFlow,
                                        Coupon {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  accept(v: AcyclicVisitor): void;
  date: () => Date;
  hasOccurred: (refDate: Date, includeRefDate: boolean) => boolean;
  amount1(): Real;
  exCouponDate: () => Date;
  tradingExCoupon: () => boolean;
  init:
      (paymentDate: Date, nominal: Real, accrualStartDate: Date,
       accrualEndDate: Date, refPeriodStart: Date, refPeriodEnd: Date,
       exCouponDate: Date) => Coupon;
  nominal: () => Real;
  accrualStartDate: () => Date;
  accrualEndDate: () => Date;
  referencePeriodStart: () => Date;
  referencePeriodEnd: () => Date;
  accrualPeriod: () => Time;
  accruedPeriod: (d: Date) => Time;
  accrualDays: () => Integer;
  accruedDays: (d: Date) => Integer;
  rate(): Rate;
  dayCounter(): DayCounter;
  accruedAmount(d: Date): Real;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _paymentDate: Date;
  _nominal: Real;
  _accrualStartDate: Date;
  _accrualEndDate: Date;
  _refPeriodStart: Date;
  _refPeriodEnd: Date;
  _exCouponDate: Date;
  _accrualPeriod: Real;
}

declare class DefaultLossModelLazyObject implements Observable, Observer,
                                                    DefaultLossModel,
                                                    LazyObject {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  expectedTrancheLoss(d: Date): Real;
  probOverLoss: (d: Date, lossFraction: Real) => Probability;
  percentile(d: Date, percentile: Real): Real;
  expectedShortfall(d: Date, percentile: Real): Real;
  splitVaRLevel(d: Date, loss: Real): Real[];
  splitESFLevel: (d: Date, loss: Real) => Real[];
  lossDistribution(d: Date): Map<Real, Probability>;
  densityTrancheLoss: (d: Date, lossFraction: Real) => Real;
  probsBeingNthEvent(n: Size, d: Date): Probability[];
  defaultCorrelation(d: Date, iName: Size, jName: Size): Real;
  probAtLeastNEvents(n: Size, d: Date): Probability;
  expectedRecovery(d: Date, iName: Size, key: DefaultProbKey): Real;
  setBasket: (bskt: Basket) => void;
  resetModel(): void;
  recalculate: () => void;
  freeze: () => void;
  unfreeze: () => void;
  alwaysForwardNotifications: () => void;
  calculate: () => void;
  performCalculations(): void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _calculated: boolean;
  _frozen: boolean;
  _alwaysForward: boolean;
  _basket: RelinkableHandle<Basket>;
}

declare class DefaultLossModelObserver implements Observer, DefaultLossModel {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  expectedTrancheLoss(d: Date): Real;
  probOverLoss: (d: Date, lossFraction: Real) => Probability;
  percentile: (d: Date, percentile: Real) => Real;
  expectedShortfall: (d: Date, percentile: Real) => Real;
  splitVaRLevel: (d: Date, loss: Real) => Real[];
  splitESFLevel: (d: Date, loss: Real) => Real[];
  lossDistribution: (d: Date) => Map<Real, Probability>;
  densityTrancheLoss: (d: Date, lossFraction: Real) => Real;
  probsBeingNthEvent: (n: Size, d: Date) => Probability[];
  defaultCorrelation: (d: Date, iName: Size, jName: Size) => Real;
  probAtLeastNEvents: (n: Size, d: Date) => Probability;
  expectedRecovery: (d: Date, iName: Size, key: DefaultProbKey) => Real;
  setBasket: (bskt: Basket) => void;
  resetModel(): void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _basket: RelinkableHandle<Basket>;
}

declare class DefaultLossModelLatentModel implements Observable, Observer,
                                                     DefaultLossModel,
                                                     LatentModel {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  expectedTrancheLoss(d: Date): Real;
  probOverLoss(d: Date, lossFraction: Real): Probability;
  percentile(d: Date, percentile: Real): Real;
  expectedShortfall(d: Date, percentile: Real): Real;
  splitVaRLevel: (d: Date, loss: Real) => Real[];
  splitESFLevel: (d: Date, loss: Real) => Real[];
  lossDistribution: (d: Date) => Map<Real, Probability>;
  densityTrancheLoss: (d: Date, lossFraction: Real) => Real;
  probsBeingNthEvent: (n: Size, d: Date) => Probability[];
  defaultCorrelation: (d: Date, iName: Size, jName: Size) => Real;
  probAtLeastNEvents: (n: Size, d: Date) => Probability;
  expectedRecovery(d: Date, iName: Size, key: DefaultProbKey): Real;
  setBasket: (bskt: Basket) => void;
  resetModel(): void;
  init: (copulaPolicyImpl: any) => LatentModel;
  lmInit1: (factorsWeights: Real[][], ini?: any) => LatentModel;
  lmInit2: (factorsWeight: Real[], ini?: any) => LatentModel;
  lmInit3: (correlSqr: Real, nVariables: Size, ini?: any) => LatentModel;
  lmInit4:
      (singleFactorCorrel: Handle<Quote>, nVariables: Size,
       ini?: any) => LatentModel;
  size: () => Size;
  numFactors: () => Size;
  numTotalFactors: () => Size;
  factorWeights: () => Real[][];
  idiosyncFctrs: () => Real[];
  latentVariableCorrel: (iVar1: Size, iVar2: Size) => Real;
  integration: () => LMIntegration;
  integratedExpectedValue1: (f: UnaryFunction<Real[], Real>) => Real;
  integratedExpectedValue2: (f: UnaryFunction<Real[], Real[]>) => Real[];
  cumulativeY: (val: Real, iVariable: Size) => Probability;
  cumulativeZ: (z: Real) => Probability;
  density: (m: Real[]) => Probability;
  inverseCumulativeDensity: (p: Probability, iFactor: Size) => Real;
  inverseCumulativeY: (p: Probability, iVariable: Size) => Real;
  inverseCumulativeZ: (p: Probability) => Real;
  allFactorCumulInverter: (probs: Real[]) => Real[];
  latentVarValue: (allFactors: Real[], iVar: Size) => Real;
  copula: () => any;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _basket: RelinkableHandle<Basket>;
  copulaPolicy: any;
  _factorWeights: Real[][];
  _cachedMktFactor: Handle<Quote>;
  _idiosyncFctrs: Real[];
  _nFactors: Size;
  _nVariables: Size;
  _copula: any;
}

declare class HimalayaOptionEngineMcSimulation implements
    Observable, Observer, PricingEngine,
    GenericEngine<HimalayaOption.Arguments, HimalayaOption.Results>,
    HimalayaOption.engine, McSimulation {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update: () => void;
  deepUpdate: () => void;
  getArguments: () => HimalayaOption.Arguments;
  getResults: () => HimalayaOption.Results;
  reset: () => void;
  calculate(): void;
  mcsInit:
      (antitheticVariate: boolean, controlVariate: boolean) => McSimulation;
  value: (tolerance: Real, maxSamples: Size, minSamples: Size) => Real;
  valueWithSamples: (samples: Size) => Real;
  errorEstimate: () => Real;
  sampleAccumulator: () => RiskStatistics;
  calculate1:
      (requiredTolerance: Real, requiredSamples: Size,
       maxSamples: Size) => void;
  pathPricer(): PathPricer<Path|MultiPath>;
  pathGenerator(): MultiPathGenerator;
  timeGrid(): TimeGrid;
  controlPathPricer: () => PathPricer<Path|MultiPath>;
  controlPathGenerator: () => PathGenerator;
  controlPricingEngine: () => PricingEngine;
  controlVariateValue: () => Real;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _mcModel: MonteCarloModel;
  _antitheticVariate: boolean;
  _controlVariate: boolean;
  MC: MonteCarloModel.mc_traits;
  RNG: MonteCarloModel.rng_traits;
  S: any;
  _arguments: HimalayaOption.Arguments;
  _results: HimalayaOption.Results;
}

declare class EverestOptionEngineMcSimulation implements
    Observable, Observer, PricingEngine,
    GenericEngine<EverestOption.Arguments, EverestOption.Results>,
    EverestOption.engine, McSimulation {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update: () => void;
  deepUpdate: () => void;
  getArguments: () => EverestOption.Arguments;
  getResults: () => EverestOption.Results;
  reset: () => void;
  calculate(): void;
  mcsInit:
      (antitheticVariate: boolean, controlVariate: boolean) => McSimulation;
  value: (tolerance: Real, maxSamples: Size, minSamples: Size) => Real;
  valueWithSamples: (samples: Size) => Real;
  errorEstimate: () => Real;
  sampleAccumulator: () => RiskStatistics;
  calculate1:
      (requiredTolerance: Real, requiredSamples: Size,
       maxSamples: Size) => void;
  pathPricer(): PathPricer<Path|MultiPath>;
  pathGenerator(): MultiPathGenerator;
  timeGrid(): TimeGrid;
  controlPathPricer: () => PathPricer<Path|MultiPath>;
  controlPathGenerator: () => PathGenerator;
  controlPricingEngine: () => PricingEngine;
  controlVariateValue: () => Real;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _mcModel: MonteCarloModel;
  _antitheticVariate: boolean;
  _controlVariate: boolean;
  MC: MonteCarloModel.mc_traits;
  RNG: MonteCarloModel.rng_traits;
  S: any;
  _arguments: EverestOption.Arguments;
  _results: EverestOption.Results;
}

declare class IndexObserver implements Observable, Observer, Index {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  name(): string;
  fixingCalendar(): Calendar;
  isValidFixingDate(fixingDate: Date): boolean;
  fixing(fixingDate: Date, forecastTodaysFixing?: boolean): Real;
  timeSeries: () => TimeSeries<Real>;
  allowsNativeFixings: () => boolean;
  addFixing(fixingDate: Date, fixing: Real, forceOverwrite?: boolean): void;
  addFixings1: (t: TimeSeries<Real>, forceOverwrite?: boolean) => void;
  addFixings2:
      (d: Date[], dBegin: Size, dEnd: Size, v: Real[], vBegin: Size,
       forceOverwrite?: boolean) => void;
  clearFixings: () => void;
  checkNativeFixingsAllowed: () => void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
}

declare class InstrumentResultsGreeks implements PricingEngine.Results,
                                                 Instrument.Results,
                                                 Option.Greeks {
  reset(): void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  value: Real;
  errorEstimate: Real;
  valuationDate: Date;
  additionalResults: Map<string, any>;
  delta: Real;
  gamma: Real;
  theta: Real;
  vega: Real;
  rho: Real;
  dividendRho: Real;
}

declare class ResultsGreeksMoreGreeks implements PricingEngine.Results,
                                                 Instrument.Results,
                                                 Option.Greeks,
                                                 Option.MoreGreeks {
  reset(): void;
  value: Real;
  errorEstimate: Real;
  valuationDate: Date;
  additionalResults: Map<string, any>;
  delta: Real;
  gamma: Real;
  theta: Real;
  vega: Real;
  rho: Real;
  dividendRho: Real;
  itmCashProbability: Real;
  deltaForward: Real;
  elasticity: Real;
  thetaPerDay: Real;
  strikeSensitivity: Real;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
}

export declare class VanillaSwapOptionArguments implements
    VanillaSwap.Arguments, Option.Arguments {
  validate(): void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  payoff: Payoff;
  exercise: Exercise;
  legs: Leg[];
  payer: Real[];
  type: VanillaSwap.Type;
  nominal: Real;
  fixedResetDates: Date[];
  fixedPayDates: Date[];
  floatingAccrualTimes: Time[];
  floatingResetDates: Date[];
  floatingFixingDates: Date[];
  floatingPayDates: Date[];
  fixedCoupons: Real[];
  floatingSpreads: Spread[];
  floatingCoupons: Real[];
}

export declare class AbcdCoeffHolderInterpolationtemplateImpl implements
    AbcdCoeffHolder, Interpolation.templateImpl {
  constructor(
      a: Real, b: Real, c: Real, d: Real, aIsFixed: boolean, bIsFixed: boolean,
      cIsFixed: boolean, dIsFixed: boolean, x: Real[], xBegin: Size, xEnd: Size,
      y: Real[], yBegin: Size, requiredPoints?: Integer);
  update(): void;
  xMin: () => Real;
  xMax: () => Real;
  xValues: () => Real[];
  yValues: () => Real[];
  isInRange: (x: Real) => boolean;
  locate: (x: Real) => Size;
  value1(x: Real): Real;
  value2: (y: Real[], x: Real) => Real;
  primitive(x: Real): Real;
  derivative(x: Real): Real;
  secondDerivative(x: Real): Real;
  _a: Real;
  _b: Real;
  _c: Real;
  _d: Real;
  _aIsFixed: boolean;
  _bIsFixed: boolean;
  _cIsFixed: boolean;
  _dIsFixed: boolean;
  _k: Real[];
  _error: Real;
  _maxError: Real;
  _abcdEndCriteria: EndCriteria.Type;
  _x: Real[];
  _xBegin: Size;
  _xEnd: Size;
  _y: Real[];
  _yBegin: Size;
}

export declare class CoefficientHolderInterpolationtemplateImpl implements
    CoefficientHolder, Interpolation.templateImpl {
  constructor(
      n: Size, x: Real[], xBegin: Size, xEnd: Size, y: Real[], yBegin: Size,
      requiredPoints?: Integer);
  update(): void;
  xMin: () => Real;
  xMax: () => Real;
  xValues: () => Real[];
  yValues: () => Real[];
  isInRange: (x: Real) => boolean;
  locate: (x: Real) => Size;
  value1(x: Real): Real;
  value2: (y: Real[], x: Real) => Real;
  primitive(x: Real): Real;
  derivative(x: Real): Real;
  secondDerivative(x: Real): Real;
  _n: Size;
  _primitiveConst: Real[];
  _a: Real[];
  _b: Real[];
  _c: Real[];
  _monotonicityAdjustments: boolean[];
  _x: Real[];
  _xBegin: Size;
  _xEnd: Size;
  _y: Real[];
  _yBegin: Size;
}

export declare class BicubicSplineDerivativesInterpolation2DImpl implements
    BicubicSplineDerivatives, Interpolation2D.templateImpl {
  enableExtrapolation: (b: boolean) => void;
  disableExtrapolation: (b: boolean) => void;
  allowsExtrapolation: () => boolean;
  xMin: () => Real;
  xMax: () => Real;
  xValues: () => Real[];
  locateX: (x: Real) => Size;
  yMin: () => Real;
  yMax: () => Real;
  yValues: () => Real[];
  locateY: (y: Real) => Size;
  zData: () => Matrix;
  isInRange: (x: Real, y: Real) => boolean;
  value(x: Real, y: Real): Real;
  calculate(): void;
  derivativeX(x: Real, y: Real): Real;
  derivativeY(x: Real, y: Real): Real;
  derivativeXY(x: Real, y: Real): Real;
  secondDerivativeX(x: Real, y: Real): Real;
  secondDerivativeY(x: Real, y: Real): Real;
  _extrapolate: boolean;
  _x: Real[];
  _xBegin: Size;
  _xEnd: Size;
  _y: Real[];
  _yBegin: Size;
  _yEnd: Size;
  _zData: Matrix;
}

declare class CostFunctionProjection implements CostFunction, Projection {
  value(x: Real[]): Real;
  values(x: Real[]): Real[];
  gradient: (grad_f: Real[], x: Real[]) => void;
  valueAndGradient: (grad_f: Real[], x: Real[]) => Real;
  jacobian: (jac: Matrix, x: Real[]) => void;
  valuesAndJacobian: (jac: Matrix, x: Real[]) => Real[];
  finiteDifferenceEpsilon: () => Real;
  project: (parameters: Real[]) => Real[];
  include: (projectedParameters: Real[]) => Real[];
  mapFreeParameters: (parameterValues: Real[]) => void;
  isDisposed: false;
  dispose: () => void;
  _numberOfFreeParameters: Size;
  _fixedParameters: Real[];
  _actualParameters: Real[];
  _fixParameters: boolean[];
  _isDisposed: boolean;
}

declare class ObserverObservableExtrapolator implements Observer, Observable,
                                                        Extrapolator {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  enableExtrapolation: (b?: boolean) => void;
  disableExtrapolation: (b?: boolean) => void;
  allowsExtrapolation: () => boolean;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _extrapolate: boolean;
}

export declare class XABRCoeffHolderInterpolationtemplateImpl implements
    XABRCoeffHolder, Interpolation.templateImpl {
  updateModelInstance: () => void;
  update(): void;
  xMin: () => Real;
  xMax: () => Real;
  xValues: () => Real[];
  yValues: () => Real[];
  isInRange: (x: Real) => boolean;
  locate: (x: Real) => Size;
  value1(x: Real): Real;
  value2: (y: Real[], x: Real) => Real;
  primitive(x: Real): Real;
  derivative(x: Real): Real;
  secondDerivative(x: Real): Real;
  _model: XABRCoeffHolder.ModelType;
  _t: Real;
  _forward: Real;
  _params: Real[];
  _paramIsFixed: boolean[];
  _weights: Real[];
  _error: Real;
  _maxError: Real;
  _XABREndCriteria: EndCriteria.Type;
  _modelInstance: XABRCoeffHolder.ModelInstanceType;
  _addParams: Real[];
  _x: Real[];
  _xBegin: Size;
  _xEnd: Size;
  _y: Real[];
  _yBegin: Size;
}

export declare class LatticeCuriouslyRecurringTemplate<
    Impl extends TreeLatticeImpl> implements Lattice,
                                             CuriouslyRecurringTemplate<Impl> {
  timeGrid: () => TimeGrid;
  initialize(asset: DiscretizedAsset, time: Time): void;
  rollback(asset: DiscretizedAsset, to: Time): void;
  partialRollback(asset: DiscretizedAsset, to: Time): void;
  presentValue(asset: DiscretizedAsset): Real;
  grid(t: Time): Real[];
  impl: () => any;
  _t: TimeGrid;
}

declare class CalibratedModelAffineModel implements Observable, Observer,
                                                    CalibratedModel,
                                                    AffineModel {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  discount(t: Time): DiscountFactor;
  discountBond1(now: Time, maturity: Time, factors: Real[]): Real;
  discountBondOption1(
      type: Option.Type, strike: Real, maturity: Time,
      bondMaturity: Time): Real;
  discountBondOption2:
      (type: Option.Type, strike: Real, maturity: Time, bondStart: Time,
       bondMaturity: Time) => Real;
  cmInit: (nArguments: Size) => CalibratedModel;
  calibrate1(
      instruments: CalibrationHelperBase[], method: OptimizationMethod,
      endCriteria: EndCriteria, additionalConstraint?: Constraint,
      weights?: Real[], fixParameters?: boolean[]): void;
  calibrate2(
      instruments: BlackCalibrationHelper[], method: OptimizationMethod,
      endCriteria: EndCriteria, additionalConstraint?: Constraint,
      weights?: Real[], fixParameters?: boolean[]): void;
  value1(params: Real[], instruments: CalibrationHelperBase[]): Real;
  value2(params: Real[], instruments: BlackCalibrationHelper[]): Real;
  constraint: () => Constraint;
  endCriteria: () => EndCriteria.Type;
  problemValues: () => Real[];
  params: () => Real[];
  setParams(params: Real[]): void;
  functionEvaluation: () => Integer;
  generateArguments: () => void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _arguments: Parameter[];
  _constraint: Constraint;
  _shortRateEndCriteria: EndCriteria.Type;
  _problemValues: Real[];
  _functionEvaluation: Integer;
}

export declare class CoxIngersollRossTermStructureConsistentModel implements
    Observable, Observer, CalibratedModel, ShortRateModel, OneFactorModel,
    AffineModel, OneFactorAffineModel, CoxIngersollRoss,
    TermStructureConsistentModel {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  discount: (t: Time) => DiscountFactor;
  discountBond1: (now: Time, maturity: Time, factors: Real[]) => Real;
  discountBondOption1(
      type: Option.Type, strike: Real, maturity: Time,
      bondMaturity: Time): Real;
  discountBondOption2:
      (type: Option.Type, strike: Real, maturity: Time, bondStart: Time,
       bondMaturity: Time) => Real;
  cmInit: (nArguments: Size) => CalibratedModel;
  calibrate1(
      instruments: CalibrationHelperBase[], method: OptimizationMethod,
      endCriteria: EndCriteria, additionalConstraint?: Constraint,
      weights?: Real[], fixParameters?: boolean[]): void;
  calibrate2(
      instruments: BlackCalibrationHelper[], method: OptimizationMethod,
      endCriteria: EndCriteria, additionalConstraint?: Constraint,
      weights?: Real[], fixParameters?: boolean[]): void;
  value1(params: Real[], instruments: CalibrationHelperBase[]): Real;
  value2(params: Real[], instruments: BlackCalibrationHelper[]): Real;
  constraint: () => Constraint;
  endCriteria: () => EndCriteria.Type;
  problemValues: () => Real[];
  params: () => Real[];
  setParams: (params: Real[]) => void;
  functionEvaluation: () => Integer;
  generateArguments(): void;
  srmInit: (nArguments: Size) => ShortRateModel;
  ofmInit: (nArguments: Size) => OneFactorModel;
  dynamics(): OneFactorModel.ShortRateDynamics;
  tree(grid: TimeGrid): Lattice;
  ofamInit: (nArguments: Size) => OneFactorAffineModel;
  discountBond2: (now: Time, maturity: Time, rate: Rate) => Real;
  A(t: Time, T: Time): Real;
  B: (t: Time, T: Time) => Real;
  tcmInit: (termStructure:
                Handle<YieldTermStructure>) => TermStructureConsistentModel;
  termStructure: () => Handle<YieldTermStructure>;
  cisrInit:
      (r0?: Real, theta?: Real, k?: Real, sigma?: Real,
       withFellerConstraint?: boolean) => CoxIngersollRoss;
  theta: () => Real;
  k: () => Real;
  sigma: () => Real;
  x0: () => Real;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _arguments: Parameter[];
  _constraint: Constraint;
  _shortRateEndCriteria: EndCriteria.Type;
  _problemValues: Real[];
  _functionEvaluation: Integer;
  _termStructure: Handle<YieldTermStructure>;
  _theta: Parameter;
  _k: Parameter;
  _sigma: Parameter;
  _r0: Parameter;
}

export declare class Gaussian1dModelCalibratedModel implements
    Observable, Observer, TermStructureConsistentModel, LazyObject,
    Gaussian1dModel, CalibratedModel {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  recalculate: () => void;
  freeze: () => void;
  unfreeze: () => void;
  alwaysForwardNotifications: () => void;
  calculate: () => void;
  performCalculations(): void;
  cmInit: (nArguments: Size) => CalibratedModel;
  calibrate1(
      instruments: CalibrationHelperBase[], method: OptimizationMethod,
      endCriteria: EndCriteria, additionalConstraint?: Constraint,
      weights?: Real[], fixParameters?: boolean[]): void;
  calibrate2(
      instruments: BlackCalibrationHelper[], method: OptimizationMethod,
      endCriteria: EndCriteria, additionalConstraint?: Constraint,
      weights?: Real[], fixParameters?: boolean[]): void;
  value1(params: Real[], instruments: CalibrationHelperBase[]): Real;
  value2(params: Real[], instruments: BlackCalibrationHelper[]): Real;
  constraint: () => Constraint;
  endCriteria: () => EndCriteria.Type;
  problemValues: () => Real[];
  params: () => Real[];
  setParams: (params: Real[]) => void;
  functionEvaluation: () => Integer;
  generateArguments(): void;
  tcmInit: (termStructure:
                Handle<YieldTermStructure>) => TermStructureConsistentModel;
  termStructure: () => Handle<YieldTermStructure>;
  g1dmInit: (yieldTermStructure: Handle<YieldTermStructure>) => Gaussian1dModel;
  stateProcess: () => StochasticProcess1D;
  numeraire1: (t: Time, y?: Real, yts?: Handle<YieldTermStructure>) => Real;
  zerobond1:
      (T: Time, t?: Time, y?: Real, yts?: Handle<YieldTermStructure>) => Real;
  numeraire2:
      (referenceDate: Date, y?: Real, yts?: Handle<YieldTermStructure>) => Real;
  zerobond2:
      (maturity: Date, referenceDate?: Date, y?: Real,
       yts?: Handle<YieldTermStructure>) => Real;
  zerobondOption:
      (type: Option.Type, expiry: Date, valueDate: Date, maturity: Date,
       strike: Rate, referenceDate?: Date, y?: Real,
       yts?: Handle<YieldTermStructure>, yStdDevs?: Real, yGridPoints?: Size,
       extrapolatePayoff?: boolean, flatPayoffExtrapolation?: boolean) => Real;
  forwardRate:
      (fixing: Date, referenceDate?: Date, y?: Real,
       iborIdx?: IborIndex) => Real;
  swapRate:
      (fixing: Date, tenor: Period, referenceDate?: Date, y?: Real,
       swapIdx?: SwapIndex) => Real;
  swapAnnuity:
      (fixing: Date, tenor: Period, referenceDate?: Date, y?: Real,
       swapIdx?: SwapIndex) => Real;
  yGrid:
      (stdDevs: Real, gridPoints: Size, T?: Real, t?: Real, y?: Real) => Real[];
  numeraireImpl(t: Time, y: Real, yts: Handle<YieldTermStructure>): Real;
  zerobondImpl(T: Time, t: Time, y: Real, yts: Handle<YieldTermStructure>):
      Real;
  underlyingSwap:
      (index: SwapIndex, expiry: Date, tenor: Period) => VanillaSwap;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _calculated: boolean;
  _frozen: boolean;
  _alwaysForward: boolean;
  _arguments: Parameter[];
  _constraint: Constraint;
  _shortRateEndCriteria: EndCriteria.Type;
  _problemValues: Real[];
  _functionEvaluation: Integer;
  _termStructure: Handle<YieldTermStructure>;
  _swapCache: Map<Gaussian1dModel.CachedSwapKey, VanillaSwap>;
  _stateProcess: StochasticProcess1D;
  _evaluationDate: Date;
  _enforcesTodaysHistoricFixings: boolean;
}

export declare class LazyObjectCalibrationHelperBase implements
    Observable, Observer, LazyObject, CalibrationHelperBase {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  recalculate: () => void;
  freeze: () => void;
  unfreeze: () => void;
  alwaysForwardNotifications: () => void;
  calculate: () => void;
  performCalculations(): void;
  calibrationError(): Real;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _calculated: boolean;
  _frozen: boolean;
  _alwaysForward: boolean;
}

declare class MarketModelFactoryObserver implements Observable, Observer,
                                                    MarketModelFactory {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  create(e: EvolutionDescription, numberOfFactors: Size): MarketModel;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
}

export declare class MarketModelNodeDataProviderParametricExercise implements
    MarketModelNodeDataProvider, ParametricExercise {
  numberOfExercises(): Size;
  numberOfData(): Size[];
  evolution(): EvolutionDescription;
  nextStep(cs: CurveState): void;
  reset(): void;
  isExerciseTime(): boolean[];
  values(cs: CurveState, results: Real[]): void;
  numberOfVariables(): Size[];
  numberOfParameters(): Size[];
  exercise(exerciseNumber: Size, parameters: Real[], variables: Real[]):
      boolean;
  guess(exerciseNumber: Size, parameters: Real[]): void;
}

export declare class OneFactorAffineTermStructureConsistent implements
    Observable, Observer, CalibratedModel, ShortRateModel, OneFactorModel,
    AffineModel, OneFactorAffineModel, TermStructureConsistentModel {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  discount(t: Time): DiscountFactor;
  discountBond1(now: Time, maturity: Time, factors: Real[]): Real;
  discountBondOption1(
      type: Option.Type, strike: Real, maturity: Time,
      bondMaturity: Time): Real;
  discountBondOption2:
      (type: Option.Type, strike: Real, maturity: Time, bondStart: Time,
       bondMaturity: Time) => Real;
  cmInit: (nArguments: Size) => CalibratedModel;
  calibrate1(
      instruments: CalibrationHelperBase[], method: OptimizationMethod,
      endCriteria: EndCriteria, additionalConstraint?: Constraint,
      weights?: Real[], fixParameters?: boolean[]): void;
  calibrate2(
      instruments: BlackCalibrationHelper[], method: OptimizationMethod,
      endCriteria: EndCriteria, additionalConstraint?: Constraint,
      weights?: Real[], fixParameters?: boolean[]): void;
  value1(params: Real[], instruments: CalibrationHelperBase[]): Real;
  value2(params: Real[], instruments: BlackCalibrationHelper[]): Real;
  constraint: () => Constraint;
  endCriteria: () => EndCriteria.Type;
  problemValues: () => Real[];
  params: () => Real[];
  setParams: (params: Real[]) => void;
  functionEvaluation: () => Integer;
  generateArguments: () => void;
  srmInit: (nArguments: Size) => ShortRateModel;
  ofmInit: (nArguments: Size) => OneFactorModel;
  dynamics(): OneFactorModel.ShortRateDynamics;
  tree: (grid: TimeGrid) => Lattice;
  tcmInit: (termStructure:
                Handle<YieldTermStructure>) => TermStructureConsistentModel;
  termStructure: () => Handle<YieldTermStructure>;
  ofamInit: (nArguments: Size) => OneFactorAffineModel;
  discountBond2: (now: Time, maturity: Time, rate: Rate) => Real;
  A: (t: Time, T: Time) => Real;
  B: (t: Time, T: Time) => Real;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _arguments: Parameter[];
  _constraint: Constraint;
  _shortRateEndCriteria: EndCriteria.Type;
  _problemValues: Real[];
  _functionEvaluation: Integer;
  _termStructure: Handle<YieldTermStructure>;
}

declare class OneFactorModelAffineModel implements Observable, Observer,
                                                   CalibratedModel,
                                                   ShortRateModel,
                                                   OneFactorModel, AffineModel {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  discount(t: Time): DiscountFactor;
  discountBond1(now: Time, maturity: Time, factors: Real[]): Real;
  discountBondOption1(
      type: Option.Type, strike: Real, maturity: Time,
      bondMaturity: Time): Real;
  discountBondOption2:
      (type: Option.Type, strike: Real, maturity: Time, bondStart: Time,
       bondMaturity: Time) => Real;
  cmInit: (nArguments: Size) => CalibratedModel;
  calibrate1(
      instruments: CalibrationHelperBase[], method: OptimizationMethod,
      endCriteria: EndCriteria, additionalConstraint?: Constraint,
      weights?: Real[], fixParameters?: boolean[]): void;
  calibrate2(
      instruments: BlackCalibrationHelper[], method: OptimizationMethod,
      endCriteria: EndCriteria, additionalConstraint?: Constraint,
      weights?: Real[], fixParameters?: boolean[]): void;
  value1(params: Real[], instruments: CalibrationHelperBase[]): Real;
  value2(params: Real[], instruments: BlackCalibrationHelper[]): Real;
  constraint: () => Constraint;
  endCriteria: () => EndCriteria.Type;
  problemValues: () => Real[];
  params: () => Real[];
  setParams: (params: Real[]) => void;
  functionEvaluation: () => Integer;
  generateArguments: () => void;
  srmInit: (nArguments: Size) => ShortRateModel;
  ofmInit: (nArguments: Size) => OneFactorModel;
  dynamics(): OneFactorModel.ShortRateDynamics;
  tree(grid: TimeGrid): Lattice;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _arguments: Parameter[];
  _constraint: Constraint;
  _shortRateEndCriteria: EndCriteria.Type;
  _problemValues: Real[];
  _functionEvaluation: Integer;
}

export declare class OneFactorModelTermStructureConsistentModel implements
    Observable, Observer, OneFactorModel, ShortRateModel,
    TermStructureConsistentModel {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  cmInit: (nArguments: Size) => CalibratedModel;
  calibrate1(
      instruments: CalibrationHelperBase[], method: OptimizationMethod,
      endCriteria: EndCriteria, additionalConstraint?: Constraint,
      weights?: Real[], fixParameters?: boolean[]): void;
  calibrate2(
      instruments: BlackCalibrationHelper[], method: OptimizationMethod,
      endCriteria: EndCriteria, additionalConstraint?: Constraint,
      weights?: Real[], fixParameters?: boolean[]): void;
  value1(params: Real[], instruments: CalibrationHelperBase[]): Real;
  value2(params: Real[], instruments: BlackCalibrationHelper[]): Real;
  constraint: () => Constraint;
  endCriteria: () => EndCriteria.Type;
  problemValues: () => Real[];
  params: () => Real[];
  setParams: (params: Real[]) => void;
  functionEvaluation: () => Integer;
  generateArguments: () => void;
  srmInit: (nArguments: Size) => ShortRateModel;
  ofmInit: (nArguments: Size) => OneFactorModel;
  dynamics(): OneFactorModel.ShortRateDynamics;
  tree(grid: TimeGrid): Lattice;
  tcmInit: (termStructure:
                Handle<YieldTermStructure>) => TermStructureConsistentModel;
  termStructure: () => Handle<YieldTermStructure>;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _arguments: Parameter[];
  _constraint: Constraint;
  _shortRateEndCriteria: EndCriteria.Type;
  _problemValues: Real[];
  _functionEvaluation: Integer;
  _termStructure: Handle<YieldTermStructure>;
}

export declare class TermStructureConsistentModelLazyObject implements
    Observable, Observer, TermStructureConsistentModel, LazyObject {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  recalculate: () => void;
  freeze: () => void;
  unfreeze: () => void;
  alwaysForwardNotifications: () => void;
  calculate: () => void;
  performCalculations(): void;
  tcmInit: (termStructure:
                Handle<YieldTermStructure>) => TermStructureConsistentModel;
  termStructure: () => Handle<YieldTermStructure>;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _calculated: boolean;
  _frozen: boolean;
  _alwaysForward: boolean;
  _termStructure: Handle<YieldTermStructure>;
}

declare class TwoFactorModelAffineModelTermStructureConsistentModel implements
    Observable, Observer, CalibratedModel, ShortRateModel, TwoFactorModel,
    AffineModel, TermStructureConsistentModel {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  discount(t: Time): DiscountFactor;
  discountBond1(now: Time, maturity: Time, factors: Real[]): Real;
  discountBondOption1(
      type: Option.Type, strike: Real, maturity: Time,
      bondMaturity: Time): Real;
  discountBondOption2:
      (type: Option.Type, strike: Real, maturity: Time, bondStart: Time,
       bondMaturity: Time) => Real;
  cmInit: (nArguments: Size) => CalibratedModel;
  calibrate1(
      instruments: CalibrationHelperBase[], method: OptimizationMethod,
      endCriteria: EndCriteria, additionalConstraint?: Constraint,
      weights?: Real[], fixParameters?: boolean[]): void;
  calibrate2(
      instruments: BlackCalibrationHelper[], method: OptimizationMethod,
      endCriteria: EndCriteria, additionalConstraint?: Constraint,
      weights?: Real[], fixParameters?: boolean[]): void;
  value1(params: Real[], instruments: CalibrationHelperBase[]): Real;
  value2(params: Real[], instruments: BlackCalibrationHelper[]): Real;
  constraint: () => Constraint;
  endCriteria: () => EndCriteria.Type;
  problemValues: () => Real[];
  params: () => Real[];
  setParams: (params: Real[]) => void;
  functionEvaluation: () => Integer;
  generateArguments(): void;
  srmInit: (nArguments: Size) => ShortRateModel;
  termStructure: () => Handle<YieldTermStructure>;
  tfmInit: (nParams: Size) => TwoFactorModel;
  dynamics(): TwoFactorModel.ShortRateDynamics;
  tree: (grid: TimeGrid) => Lattice;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _arguments: Parameter[];
  _constraint: Constraint;
  _shortRateEndCriteria: EndCriteria.Type;
  _problemValues: Real[];
  _functionEvaluation: Integer;
  tcmInit: (termStructure:
                Handle<YieldTermStructure>) => TermStructureConsistentModel;
  _termStructure: Handle<YieldTermStructure>;
}

export declare class VasicekTermStructureConsistentModel implements
    Observable, Observer, CalibratedModel, ShortRateModel, OneFactorModel,
    AffineModel, OneFactorAffineModel, Vasicek, TermStructureConsistentModel {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  discount: (t: Time) => DiscountFactor;
  discountBond1: (now: Time, maturity: Time, factors: Real[]) => Real;
  discountBondOption1(
      type: Option.Type, strike: Real, maturity: Time,
      bondMaturity: Time): Real;
  discountBondOption2(
      type: Option.Type, strike: Real, maturity: Time, bondStart: Time,
      bondMaturity: Time): Real;
  cmInit: (nArguments: Size) => CalibratedModel;
  calibrate1(
      instruments: CalibrationHelperBase[], method: OptimizationMethod,
      endCriteria: EndCriteria, additionalConstraint?: Constraint,
      weights?: Real[], fixParameters?: boolean[]): void;
  calibrate2(
      instruments: BlackCalibrationHelper[], method: OptimizationMethod,
      endCriteria: EndCriteria, additionalConstraint?: Constraint,
      weights?: Real[], fixParameters?: boolean[]): void;
  value1(params: Real[], instruments: CalibrationHelperBase[]): Real;
  value2(params: Real[], instruments: BlackCalibrationHelper[]): Real;
  constraint: () => Constraint;
  endCriteria: () => EndCriteria.Type;
  problemValues: () => Real[];
  params: () => Real[];
  setParams: (params: Real[]) => void;
  functionEvaluation: () => Integer;
  generateArguments(): void;
  srmInit: (nArguments: Size) => ShortRateModel;
  ofmInit: (nArguments: Size) => OneFactorModel;
  dynamics(): OneFactorModel.ShortRateDynamics;
  tree(grid: TimeGrid): Lattice;
  ofamInit: (nArguments: Size) => OneFactorAffineModel;
  discountBond2: (now: Time, maturity: Time, rate: Rate) => Real;
  A(t: Time, T: Time): Real;
  B: (t: Time, T: Time) => Real;
  tcmInit: (termStructure:
                Handle<YieldTermStructure>) => TermStructureConsistentModel;
  termStructure: () => Handle<YieldTermStructure>;
  vInit:
      (r0?: Rate, a?: Real, b?: Real, sigma?: Real, lambda?: Real) => Vasicek;
  a: () => Real;
  b: () => Real;
  lambda: () => Real;
  sigma: () => Real;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _arguments: Parameter[];
  _constraint: Constraint;
  _shortRateEndCriteria: EndCriteria.Type;
  _problemValues: Real[];
  _functionEvaluation: Integer;
  _termStructure: Handle<YieldTermStructure>;
  _r0: Real;
  _a: Parameter;
  _b: Parameter;
  _sigma: Parameter;
  _lambda: Parameter;
}

declare class ObserverObservable implements Observer, Observable {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate(): void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
}

export declare class BarrierOptionEngineMcSimulation implements
    Observable, Observer, PricingEngine,
    GenericEngine<BarrierOptionEngine.Arguments, BarrierOptionEngine.Results>,
    BarrierOptionEngine.engine, McSimulation {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update: () => void;
  deepUpdate: () => void;
  getArguments: () => BarrierOptionEngine.Arguments;
  getResults: () => BarrierOptionEngine.Results;
  reset: () => void;
  calculate(): void;
  triggered: (underlying: Real) => boolean;
  mcsInit:
      (antitheticVariate: boolean, controlVariate: boolean) => McSimulation;
  value: (tolerance: Real, maxSamples: Size, minSamples: Size) => Real;
  valueWithSamples: (samples: Size) => Real;
  errorEstimate: () => Real;
  sampleAccumulator: () => RiskStatistics;
  calculate1:
      (requiredTolerance: Real, requiredSamples: Size,
       maxSamples: Size) => void;
  pathPricer(): PathPricer<Path|MultiPath>;
  pathGenerator(): PathGenerator;
  timeGrid(): TimeGrid;
  controlPathPricer: () => PathPricer<Path|MultiPath>;
  controlPathGenerator: () => PathGenerator;
  controlPricingEngine: () => PricingEngine;
  controlVariateValue: () => Real;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _mcModel: MonteCarloModel;
  _antitheticVariate: boolean;
  _controlVariate: boolean;
  MC: MonteCarloModel.mc_traits;
  RNG: MonteCarloModel.rng_traits;
  S: any;
  _arguments: BarrierOptionEngine.Arguments;
  _results: BarrierOptionEngine.Results;
}

declare class BasketGeneratingEngineGenericModelEngine<
    ModelType extends Observable, ArgumentsType extends
        PricingEngine.Arguments, ResultsType extends PricingEngine.Results>
    implements BasketGeneratingEngine, PricingEngine, Observer, Observable,
               GenericEngine<ArgumentsType, ResultsType>,
               GenericModelEngine<ModelType, ArgumentsType, ResultsType> {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update: () => void;
  deepUpdate: () => void;
  getArguments: () => ArgumentsType;
  getResults: () => ResultsType;
  reset: () => void;
  calculate: () => void;
  init1: (model: Handle<ModelType>) =>
      GenericModelEngine<ModelType, ArgumentsType, ResultsType>;
  init2: (model: ModelType) =>
      GenericModelEngine<ModelType, ArgumentsType, ResultsType>;
  bgeInit1:
      (model: Gaussian1dModel, oas: Handle<Quote>,
       discountCurve: Handle<YieldTermStructure>) => BasketGeneratingEngine;
  bgeInit2:
      (model: Handle<Gaussian1dModel>, oas: Handle<Quote>,
       discountCurve: Handle<YieldTermStructure>) => BasketGeneratingEngine;
  calibrationBasket:
      (exercise: Exercise, standardSwapBase: SwapIndex,
       swaptionVolatility: SwaptionVolatilityStructure,
       basketType?:
           BasketGeneratingEngine.CalibrationBasketType) => CalibrationHelper[];
  underlyingNpv(expiry: Date, y: Real): Real;
  underlyingType(): VanillaSwap.Type;
  underlyingLastDate(): Date;
  initialGuess(expiry: Date): Real[];
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _arguments: ArgumentsType;
  _results: ResultsType;
  _model: Handle<ModelType>;
  _onefactormodel: Handle<Gaussian1dModel>;
  _oas: Handle<Quote>;
  _discountCurve: Handle<YieldTermStructure>;
}

export declare class BasketOptionEngineMcSimulation implements
    Observable, Observer, PricingEngine,
    GenericEngine<BasketOption.Arguments, BasketOption.Results>,
    BasketOption.engine, McSimulation {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update: () => void;
  deepUpdate: () => void;
  getArguments: () => BasketOption.Arguments;
  getResults: () => BasketOption.Results;
  reset: () => void;
  calculate(): void;
  mcsInit:
      (antitheticVariate: boolean, controlVariate: boolean) => McSimulation;
  value: (tolerance: Real, maxSamples: Size, minSamples: Size) => Real;
  valueWithSamples: (samples: Size) => Real;
  errorEstimate: () => Real;
  sampleAccumulator: () => RiskStatistics;
  calculate1:
      (requiredTolerance: Real, requiredSamples: Size,
       maxSamples: Size) => void;
  pathPricer(): PathPricer<MultiPath>;
  pathGenerator(): MultiPathGenerator;
  timeGrid(): TimeGrid;
  controlPathPricer: () => PathPricer<MultiPath>;
  controlPathGenerator: () => PathGenerator;
  controlPricingEngine: () => PricingEngine;
  controlVariateValue: () => Real;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _mcModel: MonteCarloModel;
  _antitheticVariate: boolean;
  _controlVariate: boolean;
  MC: MonteCarloModel.mc_traits;
  RNG: MonteCarloModel.rng_traits;
  S: any;
  _arguments: BasketOption.Arguments;
  _results: BasketOption.Results;
}

export declare class CapFloorEngineMcSimulation implements
    Observable, Observer, PricingEngine,
    GenericEngine<CapFloorEngine.Arguments, CapFloorEngine.Results>,
    CapFloorEngine.engine, McSimulation {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update: () => void;
  deepUpdate: () => void;
  getArguments: () => CapFloorEngine.Arguments;
  getResults: () => CapFloorEngine.Results;
  reset: () => void;
  calculate(): void;
  mcsInit:
      (antitheticVariate: boolean, controlVariate: boolean) => McSimulation;
  value: (tolerance: Real, maxSamples: Size, minSamples: Size) => Real;
  valueWithSamples: (samples: Size) => Real;
  errorEstimate: () => Real;
  sampleAccumulator: () => RiskStatistics;
  calculate1:
      (requiredTolerance: Real, requiredSamples: Size,
       maxSamples: Size) => void;
  pathPricer(): PathPricer<Path|MultiPath>;
  pathGenerator(): PathGenerator;
  timeGrid(): TimeGrid;
  controlPathPricer: () => PathPricer<Path|MultiPath>;
  controlPathGenerator: () => PathGenerator;
  controlPricingEngine: () => PricingEngine;
  controlVariateValue: () => Real;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _mcModel: MonteCarloModel;
  _antitheticVariate: boolean;
  _controlVariate: boolean;
  MC: MonteCarloModel.mc_traits;
  RNG: MonteCarloModel.rng_traits;
  S: any;
  _arguments: CapFloorEngine.Arguments;
  _results: CapFloorEngine.Results;
}

export declare class CliquetOptionEngineMcSimulation implements
    Observable, Observer, PricingEngine,
    GenericEngine<CliquetOption.Arguments, CliquetOption.Results>,
    CliquetOption.engine, McSimulation {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update: () => void;
  deepUpdate: () => void;
  getArguments: () => CliquetOption.Arguments;
  getResults: () => CliquetOption.Results;
  reset: () => void;
  calculate(): void;
  init: (...args: any[]) => CliquetOption.engine;
  mcsInit:
      (antitheticVariate: boolean, controlVariate: boolean) => McSimulation;
  value: (tolerance: Real, maxSamples: Size, minSamples: Size) => Real;
  valueWithSamples: (samples: Size) => Real;
  errorEstimate: () => Real;
  sampleAccumulator: () => RiskStatistics;
  calculate1:
      (requiredTolerance: Real, requiredSamples: Size,
       maxSamples: Size) => void;
  pathPricer(): PathPricer<Path|MultiPath>;
  pathGenerator(): PathGenerator;
  timeGrid(): TimeGrid;
  controlPathPricer: () => PathPricer<Path|MultiPath>;
  controlPathGenerator: () => PathGenerator;
  controlPricingEngine: () => PricingEngine;
  controlVariateValue: () => Real;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _mcModel: MonteCarloModel;
  _antitheticVariate: boolean;
  _controlVariate: boolean;
  MC: MonteCarloModel.mc_traits;
  RNG: MonteCarloModel.rng_traits;
  S: any;
  _arguments: CliquetOption.Arguments;
  _results: CliquetOption.Results;
}

export declare class DiscreteAveragingAsianOptionEngineMcSimulation implements
    Observable, Observer, PricingEngine,
    GenericEngine<
        DiscreteAveragingAsianOption.Arguments,
        DiscreteAveragingAsianOption.Results>,
    DiscreteAveragingAsianOption.engine, McSimulation {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update: () => void;
  deepUpdate: () => void;
  getArguments: () => DiscreteAveragingAsianOption.Arguments;
  getResults: () => DiscreteAveragingAsianOption.Results;
  reset: () => void;
  calculate(): void;
  mcsInit:
      (antitheticVariate: boolean, controlVariate: boolean) => McSimulation;
  value: (tolerance: Real, maxSamples: Size, minSamples: Size) => Real;
  valueWithSamples: (samples: Size) => Real;
  errorEstimate: () => Real;
  sampleAccumulator: () => RiskStatistics;
  calculate1:
      (requiredTolerance: Real, requiredSamples: Size,
       maxSamples: Size) => void;
  pathPricer(): PathPricer<Path|MultiPath>;
  pathGenerator(): PathGenerator;
  timeGrid(): TimeGrid;
  controlPathPricer(): PathPricer<Path|MultiPath>;
  controlPathGenerator: () => PathGenerator;
  controlPricingEngine(): PricingEngine;
  controlVariateValue(): Real;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _mcModel: MonteCarloModel;
  _antitheticVariate: boolean;
  _controlVariate: boolean;
  MC: MonteCarloModel.mc_traits;
  RNG: MonteCarloModel.rng_traits;
  S: any;
  _arguments: DiscreteAveragingAsianOption.Arguments;
  _results: DiscreteAveragingAsianOption.Results;
}

export declare class FDEngineAdapterOneAssetOptionEngine implements
    Observable, Observer, PricingEngine,
    GenericEngine<OneAssetOption.Arguments, OneAssetOption.Results>,
    OneAssetOption.engine, FDEngineAdapter {
  constructor(base: FDVanillaEngine, engine: PricingEngine);
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update: () => void;
  deepUpdate: () => void;
  getArguments: () => OneAssetOption.Arguments;
  getResults: () => OneAssetOption.Results;
  reset: () => void;
  calculate: () => void;
  init(
      process: GeneralizedBlackScholesProcess, timeSteps?: Size,
      gridPoints?: Size, timeDependent?: boolean): FDEngineAdapter;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _arguments: OneAssetOption.Arguments;
  _results: OneAssetOption.Results;
  base: FDVanillaEngine;
  engine: PricingEngine;
}

export declare class FloatFloatSwapOptionArguments implements
    FloatFloatSwap.Arguments, Swap.Arguments, PricingEngine.Arguments,
    Option.Arguments {
  validate(): void;
  type: VanillaSwap.Type;
  legs: Leg[];
  payer: Real[];
  payoff: Payoff;
  exercise: Exercise;
  nominal1: Real[];
  nominal2: Real[];
  leg1ResetDates: Date[];
  leg1FixingDates: Date[];
  leg1PayDates: Date[];
  leg2ResetDates: Date[];
  leg2FixingDates: Date[];
  leg2PayDates: Date[];
  leg1Spreads: Real[];
  leg2Spreads: Real[];
  leg1Gearings: Real[];
  leg2Gearings: Real[];
  leg1CappedRates: Real[];
  leg1FlooredRates: Real[];
  leg2CappedRates: Real[];
  leg2FlooredRates: Real[];
  leg1Coupons: Real[];
  leg2Coupons: Real[];
  leg1AccrualTimes: Real[];
  leg2AccrualTimes: Real[];
  index1: InterestRateIndex;
  index2: InterestRateIndex;
  leg1IsRedemptionFlow: boolean[];
  leg2IsRedemptionFlow: boolean[];
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
}

export declare class GenericEngineMcSimulation implements
    Observable, Observer, PricingEngine,
    GenericEngine<Option.Arguments, Instrument.Results>, McSimulation {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update: () => void;
  deepUpdate: () => void;
  getArguments: () => Option.Arguments;
  getResults: () => Instrument.Results;
  reset: () => void;
  calculate(): void;
  mcsInit:
      (antitheticVariate: boolean, controlVariate: boolean) => McSimulation;
  value: (tolerance: Real, maxSamples: Size, minSamples: Size) => Real;
  valueWithSamples: (samples: Size) => Real;
  errorEstimate: () => Real;
  sampleAccumulator: () => RiskStatistics;
  calculate1:
      (requiredTolerance: Real, requiredSamples: Size,
       maxSamples: Size) => void;
  pathPricer(): PathPricer<Path|MultiPath>;
  pathGenerator(): PathGenerator|MultiPathGenerator;
  timeGrid(): TimeGrid;
  controlPathPricer(): PathPricer<Path|MultiPath>;
  controlPathGenerator: () => PathGenerator;
  controlPricingEngine(): PricingEngine;
  controlVariateValue(): Real;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _arguments: Option.Arguments;
  _results: Instrument.Results;
  _mcModel: MonteCarloModel;
  _antitheticVariate: boolean;
  _controlVariate: boolean;
  MC: MonteCarloModel.mc_traits;
  RNG: MonteCarloModel.rng_traits;
  S: any;
}

export declare class OneAssetOptionEngineFDVanillaEngine implements
    Observable, Observer, PricingEngine, OneAssetOption.engine,
    FDVanillaEngine {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update: () => void;
  deepUpdate: () => void;
  getArguments: () => OneAssetOption.Arguments;
  getResults: () => OneAssetOption.Results;
  reset: () => void;
  calculate: () => void;
  init:
      (process: GeneralizedBlackScholesProcess, timeSteps: Size,
       gridPoints: Size, timeDependent?: boolean) => FDVanillaEngine;
  grid: () => Real[];
  setupArguments: (a: PricingEngine.Arguments) => void;
  ensureStrikeInGrid: () => void;
  setGridLimits1: () => void;
  setGridLimits2: (center: Real, t: Time) => void;
  initializeInitialCondition: () => void;
  initializeBoundaryConditions: () => void;
  initializeOperator: () => void;
  getResidualTime: () => Time;
  safeGridPoints: (gridPoints: Size, residualTime: Time) => Size;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _arguments: OneAssetOption.Arguments;
  _results: OneAssetOption.Results;
  _process: GeneralizedBlackScholesProcess;
  _timeSteps: Size;
  _gridPoints: Size;
  _timeDependent: boolean;
  _exerciseDate: Date;
  _payoff: Payoff;
  _finiteDifferenceOperator: TridiagonalOperator;
  _intrinsicValues: SampledCurve;
  _BCs: FDVanillaEngine.bc_type[];
  _sMin: Real;
  _center: Real;
  _sMax: Real;
  static _safetyZoneFactor: Real;
}

declare class PricingEngineObserver implements Observable, Observer,
                                               PricingEngine {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  getArguments(): PricingEngine.Arguments;
  getResults(): PricingEngine.Results;
  reset(): void;
  calculate(): void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
}

declare class VanillaOptionEngineFDMultiPeriodEngine implements
    Observable, Observer, PricingEngine, VanillaOptionEngine.engine,
    FDVanillaEngine, FDMultiPeriodEngine {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update: () => void;
  deepUpdate: () => void;
  getArguments: () => VanillaOptionEngine.Arguments;
  getResults: () => VanillaOptionEngine.Results;
  reset: () => void;
  calculate(): void;
  init:
      (process: GeneralizedBlackScholesProcess, timeSteps: Size,
       gridPoints: Size, timeDependent?: boolean) => FDVanillaEngine;
  grid: () => Real[];
  setupArguments: (a: PricingEngine.Arguments) => void;
  ensureStrikeInGrid: () => void;
  setGridLimits1: () => void;
  setGridLimits2: (center: Real, t: Time) => void;
  initializeInitialCondition: () => void;
  initializeBoundaryConditions: () => void;
  initializeOperator: () => void;
  getResidualTime: () => Time;
  safeGridPoints: (gridPoints: Size, residualTime: Time) => Size;
  init1(
      process: GeneralizedBlackScholesProcess, timeSteps?: Size,
      gridPoints?: Size, timeDependent?: boolean): FDMultiPeriodEngine;
  calculate2: (r: PricingEngine.Results) => void;
  setupArguments2: (args: PricingEngine.Arguments, schedule: Event[]) => void;
  executeIntermediateStep(step: Size): void;
  initializeStepCondition(): void;
  initializeModel: () => void;
  getDividendTime: (i: Size) => Time;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _arguments: VanillaOptionEngine.Arguments;
  _results: VanillaOptionEngine.Results;
  _process: GeneralizedBlackScholesProcess;
  _timeSteps: Size;
  _gridPoints: Size;
  _timeDependent: boolean;
  _exerciseDate: Date;
  _payoff: Payoff;
  _finiteDifferenceOperator: TridiagonalOperator;
  _intrinsicValues: SampledCurve;
  _BCs: FDVanillaEngine.bc_type[];
  _sMin: Real;
  _center: Real;
  _sMax: Real;
  static _safetyZoneFactor: Real;
  _events: Event[];
  _stoppingTimes: Time[];
  _timeStepPerPeriod: Size;
  _prices: SampledCurve;
  _stepCondition: StandardStepCondition;
  _model: FiniteDifferenceModel;
  Scheme: any;
}

declare class VarianceSwapEngineMcSimulation implements
    Observable, Observer, PricingEngine,
    GenericEngine<VarianceSwap.Arguments, VarianceSwap.Results>,
    VarianceSwap.engine, McSimulation {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update: () => void;
  deepUpdate: () => void;
  getArguments: () => VarianceSwap.Arguments;
  getResults: () => VarianceSwap.Results;
  reset: () => void;
  calculate: () => void;
  mcsInit:
      (antitheticVariate: boolean, controlVariate: boolean) => McSimulation;
  value: (tolerance: Real, maxSamples: Size, minSamples: Size) => Real;
  valueWithSamples: (samples: Size) => Real;
  errorEstimate: () => Real;
  sampleAccumulator: () => RiskStatistics;
  calculate1:
      (requiredTolerance: Real, requiredSamples: Size,
       maxSamples: Size) => void;
  pathPricer(): PathPricer<Path|MultiPath>;
  pathGenerator(): PathGenerator;
  timeGrid(): TimeGrid;
  controlPathPricer: () => PathPricer<Path|MultiPath>;
  controlPathGenerator: () => PathGenerator;
  controlPricingEngine: () => PricingEngine;
  controlVariateValue: () => Real;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _arguments: VarianceSwap.Arguments;
  _results: VarianceSwap.Results;
  _mcModel: MonteCarloModel;
  _antitheticVariate: boolean;
  _controlVariate: boolean;
  MC: MonteCarloModel.mc_traits;
  RNG: MonteCarloModel.rng_traits;
  S: any;
}

declare class VanillaOptionEngineMcSimulation implements
    Observable, Observer, PricingEngine,
    GenericEngine<VanillaOptionEngine.Arguments, VanillaOptionEngine.Results>,
    OneAssetOption.engine, VanillaOptionEngine.engine, McSimulation {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update: () => void;
  deepUpdate: () => void;
  getArguments: () => VanillaOptionEngine.Arguments;
  getResults: () => VanillaOptionEngine.Results;
  reset: () => void;
  calculate(): void;
  mcsInit:
      (antitheticVariate: boolean, controlVariate: boolean) => McSimulation;
  value: (tolerance: Real, maxSamples: Size, minSamples: Size) => Real;
  valueWithSamples: (samples: Size) => Real;
  errorEstimate: () => Real;
  sampleAccumulator: () => RiskStatistics;
  calculate1:
      (requiredTolerance: Real, requiredSamples: Size,
       maxSamples: Size) => void;
  pathPricer(): PathPricer<Path|MultiPath>;
  pathGenerator(): PathGenerator;
  timeGrid(): TimeGrid;
  controlPathPricer: () => PathPricer<Path|MultiPath>;
  controlPathGenerator: () => PathGenerator;
  controlPricingEngine: () => PricingEngine;
  controlVariateValue(): Real;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _arguments: VanillaOptionEngine.Arguments;
  _results: VanillaOptionEngine.Results;
  _mcModel: MonteCarloModel;
  _antitheticVariate: boolean;
  _controlVariate: boolean;
  MC: MonteCarloModel.mc_traits;
  RNG: MonteCarloModel.rng_traits;
  S: any;
}

declare class QuoteObserver implements Observable, Observer, Quote {
  value(): Real;
  isValid(): boolean;
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
}

declare class QuoteLazyObject implements Observable, Observer, Quote,
                                         LazyObject {
  value(): Real;
  isValid(): boolean;
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  recalculate: () => void;
  freeze: () => void;
  unfreeze: () => void;
  alwaysForwardNotifications: () => void;
  calculate: () => void;
  performCalculations(): void;
  isDisposed: false;
  dispose: () => void;
  _isDisposed: false;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _calculated: boolean;
  _frozen: boolean;
  _alwaysForward: boolean;
}

declare class CapFloorTermVolatilityStructureLazyObject implements
    Observable, Observer, Extrapolator, TermStructure, VolatilityTermStructure,
    CapFloorTermVolatilityStructure, LazyObject {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  enableExtrapolation: (b: boolean) => void;
  disableExtrapolation: (b: boolean) => void;
  allowsExtrapolation: () => boolean;
  tsInit1: (dc: DayCounter) => TermStructure;
  tsInit2:
      (referenceDate: Date, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  tsInit3:
      (settlementDays: Natural, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  dayCounter: () => DayCounter;
  timeFromReference: (date: Date) => Time;
  maxDate(): Date;
  maxTime: () => Time;
  referenceDate: () => Date;
  calendar: () => Calendar;
  settlementDays: () => Natural;
  checkRange1: (d: Date, extrapolate: boolean) => void;
  checkRange2: (t: Time, extrapolate: boolean) => void;
  vtsInit1:
      (bdc: BusinessDayConvention, dc: DayCounter) => VolatilityTermStructure;
  vtsInit2:
      (referenceDate: Date, cal: Calendar, bdc: BusinessDayConvention,
       dc: DayCounter) => VolatilityTermStructure;
  vtsInit3:
      (settlementDays: Natural, cal: Calendar, bdc: BusinessDayConvention,
       dc: DayCounter) => VolatilityTermStructure;
  businessDayConvention: () => BusinessDayConvention;
  optionDateFromTenor: (p: Period) => Date;
  minStrike(): Rate;
  maxStrike(): Rate;
  checkStrike: (k: Rate, extrapolate: boolean) => void;
  volatility1: (optT: Period, strike: Rate, extrap: boolean) => Volatility;
  volatility2: (d: Date, strike: Rate, extrap: boolean) => Volatility;
  volatility3: (t: Time, strike: Rate, extrap: boolean) => Volatility;
  volatilityImpl(length: Time, strike: Rate): Volatility;
  recalculate: () => void;
  freeze: () => void;
  unfreeze: () => void;
  alwaysForwardNotifications: () => void;
  calculate: () => void;
  performCalculations(): void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _extrapolate: boolean;
  _moving: boolean;
  _updated: boolean;
  _calendar: Calendar;
  _referenceDate: Date;
  _settlementDays: Natural;
  _dayCounter: DayCounter;
  _bdc: BusinessDayConvention;
  _calculated: boolean;
  _frozen: boolean;
  _alwaysForward: boolean;
}

declare class DefaultDensityStructureInterpolatedCurve implements
    Observable, Observer, Extrapolator, TermStructure,
    DefaultProbabilityTermStructure, DefaultDensityStructure,
    InterpolatedCurve {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update: () => void;
  deepUpdate: () => void;
  enableExtrapolation: (b: boolean) => void;
  disableExtrapolation: (b: boolean) => void;
  allowsExtrapolation: () => boolean;
  tsInit1: (dc: DayCounter) => TermStructure;
  tsInit2:
      (referenceDate: Date, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  tsInit3:
      (settlementDays: Natural, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  dayCounter: () => DayCounter;
  timeFromReference: (date: Date) => Time;
  maxDate(): Date;
  maxTime: () => Time;
  referenceDate: () => Date;
  calendar: () => Calendar;
  settlementDays: () => Natural;
  checkRange1: (d: Date, extrapolate: boolean) => void;
  checkRange2: (t: Time, extrapolate: boolean) => void;
  dptInit1:
      (dc: DayCounter, jumps: Array<Handle<Quote>>,
       jumpDates: Date[]) => DefaultProbabilityTermStructure;
  dptInit2:
      (referenceDate: Date, calendar: Calendar, dc: DayCounter,
       jumps: Array<Handle<Quote>>,
       jumpDates: Date[]) => DefaultProbabilityTermStructure;
  dptInit3:
      (settlementDays: Natural, calendar: Calendar, dc: DayCounter,
       jumps: Array<Handle<Quote>>,
       jumpDates: Date[]) => DefaultProbabilityTermStructure;
  survivalProbability1: (d: Date, extrapolate: boolean) => Probability;
  survivalProbability2: (t: Time, extrapolate: boolean) => Probability;
  defaultProbability1: (d: Date, extrapolate: boolean) => Probability;
  defaultProbability2: (t: Time, extrapolate: boolean) => Probability;
  defaultProbability3:
      (d1: Date, d2: Date, extrapolate: boolean) => Probability;
  defaultProbability4:
      (t1: Time, t2: Time, extrapolate: boolean) => Probability;
  defaultDensity1: (d: Date, extrapolate: boolean) => Real;
  defaultDensity2: (t: Time, extrapolate: boolean) => Real;
  hazardRate1: (d: Date, extrapolate: boolean) => Rate;
  hazardRate2: (t: Time, extrapolate: boolean) => Rate;
  jumpDates: () => Date[];
  jumpTimes: () => Time[];
  setJumps: () => void;
  survivalProbabilityImpl(t: Time): Probability;
  defaultDensityImpl(t: Time): Real;
  icInit1: (times: Time[], data: Real[], i: Interpolator) => InterpolatedCurve;
  icInit2: (times: Time[], i: Interpolator) => InterpolatedCurve;
  icInit3: (n: Size, i: Interpolator) => InterpolatedCurve;
  icInit4: (i: Interpolator) => InterpolatedCurve;
  icInit5: (i: InterpolatedCurve) => InterpolatedCurve;
  setupInterpolation: () => void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _extrapolate: boolean;
  _moving: boolean;
  _updated: boolean;
  _calendar: Calendar;
  _referenceDate: Date;
  _settlementDays: Natural;
  _dayCounter: DayCounter;
  _jumps: Array<Handle<Quote>>;
  _jumpDates: Date[];
  _jumpTimes: Time[];
  _nJumps: Size;
  _latestReference: Date;
  _times: Time[];
  _data: Real[];
  _interpolation: Interpolation;
  _interpolator: Interpolator;
  _maxDate: Date;
}

declare class DefaultTermStructureInterpolatedCurveLazyObject implements
    Observable, Observer, Extrapolator, TermStructure,
    DefaultProbabilityTermStructure, InterpolatedCurve, LazyObject {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  enableExtrapolation: (b: boolean) => void;
  disableExtrapolation: (b: boolean) => void;
  allowsExtrapolation: () => boolean;
  tsInit1: (dc: DayCounter) => TermStructure;
  tsInit2:
      (referenceDate: Date, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  tsInit3:
      (settlementDays: Natural, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  dayCounter: () => DayCounter;
  timeFromReference: (date: Date) => Time;
  maxDate(): Date;
  maxTime: () => Time;
  referenceDate: () => Date;
  calendar: () => Calendar;
  settlementDays: () => Natural;
  checkRange1: (d: Date, extrapolate: boolean) => void;
  checkRange2: (t: Time, extrapolate: boolean) => void;
  dptInit1:
      (dc: DayCounter, jumps: Array<Handle<Quote>>,
       jumpDates: Date[]) => DefaultProbabilityTermStructure;
  dptInit2:
      (referenceDate: Date, calendar: Calendar, dc: DayCounter,
       jumps: Array<Handle<Quote>>,
       jumpDates: Date[]) => DefaultProbabilityTermStructure;
  dptInit3:
      (settlementDays: Natural, calendar: Calendar, dc: DayCounter,
       jumps: Array<Handle<Quote>>,
       jumpDates: Date[]) => DefaultProbabilityTermStructure;
  survivalProbability1: (d: Date, extrapolate?: boolean) => Probability;
  survivalProbability2: (t: Time, extrapolate?: boolean) => Probability;
  defaultProbability1: (d: Date, extrapolate?: boolean) => Probability;
  defaultProbability2: (t: Time, extrapolate?: boolean) => Probability;
  defaultProbability3:
      (d1: Date, d2: Date, extrapolate?: boolean) => Probability;
  defaultProbability4:
      (t1: Time, t2: Time, extrapolate?: boolean) => Probability;
  defaultDensity1: (d: Date, extrapolate?: boolean) => Real;
  defaultDensity2: (t: Time, extrapolate?: boolean) => Real;
  hazardRate1: (d: Date, extrapolate?: boolean) => Rate;
  hazardRate2: (t: Time, extrapolate?: boolean) => Rate;
  jumpDates: () => Date[];
  jumpTimes: () => Time[];
  setJumps: () => void;
  survivalProbabilityImpl(t: Time): Probability;
  defaultDensityImpl(t: Time): Real;
  icInit1: (times: Time[], data: Real[], i?: Interpolator) => InterpolatedCurve;
  icInit2: (times: Time[], i?: Interpolator) => InterpolatedCurve;
  icInit3: (n: Size, i?: Interpolator) => InterpolatedCurve;
  icInit4: (i?: Interpolator) => InterpolatedCurve;
  icInit5: (i: InterpolatedCurve) => InterpolatedCurve;
  setupInterpolation: () => void;
  curveInit1:
      (dates: Date[], dfs: DiscountFactor[], dayCounter: DayCounter,
       calendar?: Calendar, jumps?: Array<Handle<Quote>>,
       jumpDates?: Date[]) => DefaultCurve;
  curveInit2:
      (dates: Date[], dfs: DiscountFactor[], dayCounter: DayCounter,
       calendar: Calendar) => DefaultCurve;
  curveInit3:
      (dates: Date[], dfs: DiscountFactor[],
       dayCounter: DayCounter) => DefaultCurve;
  curveInit4:
      (dayCounter: DayCounter, jumps?: Array<Handle<Quote>>,
       jumpDates?: Date[]) => DefaultCurve;
  curveInit5:
      (referenceDate: Date, dayCounter: DayCounter,
       jumps?: Array<Handle<Quote>>, jumpDates?: Date[]) => DefaultCurve;
  curveInit6:
      (settlementDays: Natural, calendar: Calendar, dayCounter: DayCounter,
       jumps?: Array<Handle<Quote>>, jumpDates?: Date[]) => DefaultCurve;
  curveInit7:
      (referenceDate: Date, dayCounter: DayCounter, model: OneFactorAffineModel,
       jumps?: Array<Handle<Quote>>, jumpDates?: Date[],
       interpolator?: Interpolator) => DefaultCurve;
  data(): Real[];
  times(): Time[];
  dates(): Date[];
  nodes(): Array<[Date, Real]>;
  recalculate: () => void;
  freeze: () => void;
  unfreeze: () => void;
  alwaysForwardNotifications: () => void;
  calculate: () => void;
  performCalculations(): void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _extrapolate: boolean;
  _moving: boolean;
  _updated: boolean;
  _calendar: Calendar;
  _referenceDate: Date;
  _settlementDays: Natural;
  _dayCounter: DayCounter;
  _jumps: Array<Handle<Quote>>;
  _jumpDates: Date[];
  _jumpTimes: Time[];
  _nJumps: Size;
  _latestReference: Date;
  _times: Time[];
  _data: Real[];
  _interpolation: Interpolation;
  _interpolator: Interpolator;
  _maxDate: Date;
  _calculated: boolean;
  _frozen: boolean;
  _alwaysForward: boolean;
}

declare class ForwardRateStructureInterpolatedCurve implements
    Observable, Observer, Extrapolator, TermStructure, YieldTermStructure,
    ForwardRateStructure, InterpolatedCurve {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update: () => void;
  deepUpdate: () => void;
  enableExtrapolation: (b: boolean) => void;
  disableExtrapolation: (b: boolean) => void;
  allowsExtrapolation: () => boolean;
  tsInit1: (dc: DayCounter) => TermStructure;
  tsInit2:
      (referenceDate: Date, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  tsInit3:
      (settlementDays: Natural, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  dayCounter: () => DayCounter;
  timeFromReference: (date: Date) => Time;
  maxDate(): Date;
  maxTime: () => Time;
  referenceDate: () => Date;
  calendar: () => Calendar;
  settlementDays: () => Natural;
  checkRange1: (d: Date, extrapolate: boolean) => void;
  checkRange2: (t: Time, extrapolate: boolean) => void;
  ytsInit1:
      (dc: DayCounter, jumps?: Array<Handle<Quote>>,
       jumpDates?: Date[]) => YieldTermStructure;
  ytsInit2:
      (referenceDate: Date, calendar: Calendar, dc: DayCounter,
       jumps?: Array<Handle<Quote>>, jumpDates?: Date[]) => YieldTermStructure;
  ytsInit3:
      (settlementDays: Natural, calendar: Calendar, dc: DayCounter,
       jumps?: Array<Handle<Quote>>, jumpDates?: Date[]) => YieldTermStructure;
  discount1: (d: Date, extrapolate: boolean) => DiscountFactor;
  discount2: (t: Time, extrapolate: boolean) => DiscountFactor;
  zeroRate1:
      (d: Date, resultDayCounter: DayCounter, comp: Compounding,
       freq: Frequency, extrapolate: boolean) => InterestRate;
  zeroRate2:
      (t: Time, comp: Compounding, freq: Frequency,
       extrapolate: boolean) => InterestRate;
  forwardRate1:
      (d1: Date, d2: Date, resultDayCounter: DayCounter, comp: Compounding,
       freq: Frequency, extrapolate: boolean) => InterestRate;
  forwardRate2:
      (d: Date, p: Period, resultDayCounter: DayCounter, comp: Compounding,
       freq: Frequency, extrapolate: boolean) => InterestRate;
  forwardRate3:
      (t1: Time, t2: Time, comp: Compounding, freq: Frequency,
       extrapolate: boolean) => InterestRate;
  jumpDates: () => Date[];
  jumpTimes: () => Time[];
  discountImpl(t: Time): DiscountFactor;
  setJumps: () => void;
  icInit1: (times: Time[], data: Real[], i: Interpolator) => InterpolatedCurve;
  icInit2: (times: Time[], i: Interpolator) => InterpolatedCurve;
  icInit3: (n: Size, i: Interpolator) => InterpolatedCurve;
  icInit4: (i: Interpolator) => InterpolatedCurve;
  icInit5: (i: InterpolatedCurve) => InterpolatedCurve;
  setupInterpolation: () => void;
  forwardImpl(t: Time): Rate;
  zeroYieldImpl(t: Time): Rate;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _extrapolate: boolean;
  _moving: boolean;
  _updated: boolean;
  _calendar: Calendar;
  _referenceDate: Date;
  _settlementDays: Natural;
  _dayCounter: DayCounter;
  _jumps: Array<Handle<Quote>>;
  _jumpDates: Date[];
  _jumpTimes: Time[];
  _nJumps: Size;
  _latestReference: Date;
  _times: Time[];
  _data: Real[];
  _interpolation: Interpolation;
  _interpolator: Interpolator;
  _maxDate: Date;
}

declare class HazardRateStructureInterpolatedCurve implements
    Observable, Observer, Extrapolator, TermStructure,
    DefaultProbabilityTermStructure, HazardRateStructure, InterpolatedCurve {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update: () => void;
  deepUpdate: () => void;
  enableExtrapolation: (b: boolean) => void;
  disableExtrapolation: (b: boolean) => void;
  allowsExtrapolation: () => boolean;
  tsInit1: (dc: DayCounter) => TermStructure;
  tsInit2:
      (referenceDate: Date, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  tsInit3:
      (settlementDays: Natural, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  dayCounter: () => DayCounter;
  timeFromReference: (date: Date) => Time;
  maxDate(): Date;
  maxTime: () => Time;
  referenceDate: () => Date;
  calendar: () => Calendar;
  settlementDays: () => Natural;
  checkRange1: (d: Date, extrapolate: boolean) => void;
  checkRange2: (t: Time, extrapolate: boolean) => void;
  dptInit1:
      (dc: DayCounter, jumps: Array<Handle<Quote>>,
       jumpDates: Date[]) => DefaultProbabilityTermStructure;
  dptInit2:
      (referenceDate: Date, calendar: Calendar, dc: DayCounter,
       jumps: Array<Handle<Quote>>,
       jumpDates: Date[]) => DefaultProbabilityTermStructure;
  dptInit3:
      (settlementDays: Natural, calendar: Calendar, dc: DayCounter,
       jumps: Array<Handle<Quote>>,
       jumpDates: Date[]) => DefaultProbabilityTermStructure;
  survivalProbability1: (d: Date, extrapolate: boolean) => Probability;
  survivalProbability2: (t: Time, extrapolate: boolean) => Probability;
  defaultProbability1: (d: Date, extrapolate: boolean) => Probability;
  defaultProbability2: (t: Time, extrapolate: boolean) => Probability;
  defaultProbability3:
      (d1: Date, d2: Date, extrapolate: boolean) => Probability;
  defaultProbability4:
      (t1: Time, t2: Time, extrapolate: boolean) => Probability;
  defaultDensity1: (d: Date, extrapolate: boolean) => Real;
  defaultDensity2: (t: Time, extrapolate: boolean) => Real;
  hazardRate1: (d: Date, extrapolate: boolean) => Rate;
  hazardRate2: (t: Time, extrapolate: boolean) => Rate;
  jumpDates: () => Date[];
  jumpTimes: () => Time[];
  setJumps: () => void;
  survivalProbabilityImpl(t: Time): Probability;
  defaultDensityImpl(t: Time): Real;
  hazardRateImpl(_t: Time): Real;
  icInit1: (times: Time[], data: Real[], i: Interpolator) => InterpolatedCurve;
  icInit2: (times: Time[], i: Interpolator) => InterpolatedCurve;
  icInit3: (n: Size, i: Interpolator) => InterpolatedCurve;
  icInit4: (i: Interpolator) => InterpolatedCurve;
  icInit5: (i: InterpolatedCurve) => InterpolatedCurve;
  setupInterpolation: () => void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _extrapolate: boolean;
  _moving: boolean;
  _updated: boolean;
  _calendar: Calendar;
  _referenceDate: Date;
  _settlementDays: Natural;
  _dayCounter: DayCounter;
  _jumps: Array<Handle<Quote>>;
  _jumpDates: Date[];
  _jumpTimes: Time[];
  _nJumps: Size;
  _latestReference: Date;
  _times: Time[];
  _data: Real[];
  _interpolation: Interpolation;
  _interpolator: Interpolator;
  _maxDate: Date;
}

declare class SmileSectionLazyObject implements Observable, Observer,
                                                SmileSection, LazyObject {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  init1:
      (d: Date, dc?: DayCounter, referenceDate?: Date, type?: VolatilityType,
       shift?: Rate) => SmileSection;
  init2:
      (exerciseTime: Time, dc?: DayCounter, type?: VolatilityType,
       shift?: Rate) => SmileSection;
  minStrike: () => Real;
  maxStrike: () => Real;
  variance: (strike: Rate) => Real;
  volatility1: (strike: Rate) => Volatility;
  atmLevel: () => Real;
  exerciseDate: () => Date;
  volatilityType: () => VolatilityType;
  shift: () => Rate;
  referenceDate: () => Date;
  exerciseTime: () => Time;
  dayCounter: () => DayCounter;
  optionPrice: (strike: Rate, type?: Option.Type, discount?: Real) => Real;
  digitalOptionPrice:
      (strike: Rate, type?: Option.Type, discount?: Real, gap?: Real) => Real;
  vega: (strike: Rate, discount?: Real) => Real;
  density: (strike: Rate, discount?: Real, gap?: Real) => Real;
  volatility2:
      (strike: Rate, volatilityType: VolatilityType,
       shift?: Real) => Volatility;
  initializeExerciseTime: () => void;
  varianceImpl: (strike: Rate) => Real;
  volatilityImpl: (strike: Rate) => Volatility;
  recalculate: () => void;
  freeze: () => void;
  unfreeze: () => void;
  alwaysForwardNotifications: () => void;
  calculate: () => void;
  performCalculations(): void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _calculated: boolean;
  _frozen: boolean;
  _alwaysForward: boolean;
  _isFloating: boolean;
  _referenceDate: Date;
  _exerciseDate: Date;
  _dc: DayCounter;
  _exerciseTime: Time;
  _volatilityType: VolatilityType;
  _shift: Rate;
}

declare class OptionletVolatilityStructureLazyObject implements
    Observable, Observer, OptionletVolatilityStructure, VolatilityTermStructure,
    TermStructure, LazyObject {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  enableExtrapolation: (b: boolean) => void;
  disableExtrapolation: (b: boolean) => void;
  allowsExtrapolation: () => boolean;
  tsInit1: (dc: DayCounter) => TermStructure;
  tsInit2:
      (referenceDate: Date, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  tsInit3:
      (settlementDays: Natural, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  dayCounter: () => DayCounter;
  timeFromReference: (date: Date) => Time;
  maxDate(): Date;
  maxTime: () => Time;
  referenceDate: () => Date;
  calendar: () => Calendar;
  settlementDays: () => Natural;
  checkRange1: (d: Date, extrapolate: boolean) => void;
  checkRange2: (t: Time, extrapolate: boolean) => void;
  vtsInit1:
      (bdc: BusinessDayConvention, dc: DayCounter) => VolatilityTermStructure;
  vtsInit2:
      (referenceDate: Date, cal: Calendar, bdc: BusinessDayConvention,
       dc: DayCounter) => VolatilityTermStructure;
  vtsInit3:
      (settlementDays: Natural, cal: Calendar, bdc: BusinessDayConvention,
       dc: DayCounter) => VolatilityTermStructure;
  businessDayConvention: () => BusinessDayConvention;
  optionDateFromTenor: (p: Period) => Date;
  minStrike(): Rate;
  maxStrike(): Rate;
  checkStrike: (k: Rate, extrapolate: boolean) => void;
  ovsInit1:
      (bdc?: BusinessDayConvention,
       dc?: DayCounter) => OptionletVolatilityStructure;
  ovsInit2:
      (referenceDate: Date, cal: Calendar, bdc: BusinessDayConvention,
       dc?: DayCounter) => OptionletVolatilityStructure;
  ovsInit3:
      (settlementDays: Natural, cal: Calendar, bdc: BusinessDayConvention,
       dc?: DayCounter) => OptionletVolatilityStructure;
  volatility1:
      (optionTenor: Period, strike: Rate, extrapolate?: boolean) => Volatility;
  volatility2:
      (optionDate: Date, strike: Rate, extrapolate?: boolean) => Volatility;
  volatility3:
      (optionTime: Time, strike: Rate, extrapolate?: boolean) => Volatility;
  blackVariance1:
      (optionTenor: Period, strike: Rate, extrapolate?: boolean) => Volatility;
  blackVariance2:
      (optionDate: Date, strike: Rate, extrapolate?: boolean) => Volatility;
  blackVariance3:
      (optionTime: Time, strike: Rate, extrapolate?: boolean) => Volatility;
  smileSection1: (optionTenor: Period, extr?: boolean) => SmileSection;
  smileSection2: (optionDate: Date, extr?: boolean) => SmileSection;
  smileSection3: (optionTime: Time, extr?: boolean) => SmileSection;
  volatilityType: () => VolatilityType;
  displacement: () => Real;
  volatilityImpl1: (optionDate: Date, strike: Rate) => Volatility;
  volatilityImpl2: (optionTime: Time, strike: Rate) => Volatility;
  smileSectionImpl1: (optionDate: Date) => SmileSection;
  smileSectionImpl2: (optionTime: Time) => SmileSection;
  recalculate: () => void;
  freeze: () => void;
  unfreeze: () => void;
  alwaysForwardNotifications: () => void;
  calculate: () => void;
  performCalculations(): void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _calculated: boolean;
  _frozen: boolean;
  _alwaysForward: boolean;
  _extrapolate: boolean;
  _moving: boolean;
  _updated: boolean;
  _calendar: Calendar;
  _referenceDate: Date;
  _settlementDays: Natural;
  _dayCounter: DayCounter;
  _bdc: BusinessDayConvention;
}

export declare class SurvivalProbabilityStructureInterpolatedCurve implements
    Observable, Observer, Extrapolator, TermStructure,
    DefaultProbabilityTermStructure, SurvivalProbabilityStructure,
    InterpolatedCurve {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update: () => void;
  deepUpdate: () => void;
  enableExtrapolation: (b: boolean) => void;
  disableExtrapolation: (b: boolean) => void;
  allowsExtrapolation: () => boolean;
  tsInit1: (dc: DayCounter) => TermStructure;
  tsInit2:
      (referenceDate: Date, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  tsInit3:
      (settlementDays: Natural, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  dayCounter: () => DayCounter;
  timeFromReference: (date: Date) => Time;
  maxDate(): Date;
  maxTime: () => Time;
  referenceDate: () => Date;
  calendar: () => Calendar;
  settlementDays: () => Natural;
  checkRange1: (d: Date, extrapolate: boolean) => void;
  checkRange2: (t: Time, extrapolate: boolean) => void;
  dptInit1:
      (dc: DayCounter, jumps: Array<Handle<Quote>>,
       jumpDates: Date[]) => DefaultProbabilityTermStructure;
  dptInit2:
      (referenceDate: Date, calendar: Calendar, dc: DayCounter,
       jumps: Array<Handle<Quote>>,
       jumpDates: Date[]) => DefaultProbabilityTermStructure;
  dptInit3:
      (settlementDays: Natural, calendar: Calendar, dc: DayCounter,
       jumps: Array<Handle<Quote>>,
       jumpDates: Date[]) => DefaultProbabilityTermStructure;
  survivalProbability1: (d: Date, extrapolate: boolean) => Probability;
  survivalProbability2: (t: Time, extrapolate: boolean) => Probability;
  defaultProbability1: (d: Date, extrapolate: boolean) => Probability;
  defaultProbability2: (t: Time, extrapolate: boolean) => Probability;
  defaultProbability3:
      (d1: Date, d2: Date, extrapolate: boolean) => Probability;
  defaultProbability4:
      (t1: Time, t2: Time, extrapolate: boolean) => Probability;
  defaultDensity1: (d: Date, extrapolate: boolean) => Real;
  defaultDensity2: (t: Time, extrapolate: boolean) => Real;
  hazardRate1: (d: Date, extrapolate: boolean) => Rate;
  hazardRate2: (t: Time, extrapolate: boolean) => Rate;
  jumpDates: () => Date[];
  jumpTimes: () => Time[];
  setJumps: () => void;
  survivalProbabilityImpl(t: Time): Probability;
  defaultDensityImpl(t: Time): Real;
  icInit1: (times: Time[], data: Real[], i: Interpolator) => InterpolatedCurve;
  icInit2: (times: Time[], i: Interpolator) => InterpolatedCurve;
  icInit3: (n: Size, i: Interpolator) => InterpolatedCurve;
  icInit4: (i: Interpolator) => InterpolatedCurve;
  icInit5: (i: InterpolatedCurve) => InterpolatedCurve;
  setupInterpolation: () => void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _extrapolate: boolean;
  _moving: boolean;
  _updated: boolean;
  _calendar: Calendar;
  _referenceDate: Date;
  _settlementDays: Natural;
  _dayCounter: DayCounter;
  _jumps: Array<Handle<Quote>>;
  _jumpDates: Date[];
  _jumpTimes: Time[];
  _nJumps: Size;
  _latestReference: Date;
  _times: Time[];
  _data: Real[];
  _interpolation: Interpolation;
  _interpolator: Interpolator;
  _maxDate: Date;
}

export declare class SwaptionVolatilityStructureLazyObject implements
    Observable, Observer, Extrapolator, TermStructure, VolatilityTermStructure,
    SwaptionVolatilityStructure, LazyObject {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  enableExtrapolation: (b: boolean) => void;
  disableExtrapolation: (b: boolean) => void;
  allowsExtrapolation: () => boolean;
  tsInit1: (dc: DayCounter) => TermStructure;
  tsInit2:
      (referenceDate: Date, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  tsInit3:
      (settlementDays: Natural, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  dayCounter: () => DayCounter;
  timeFromReference: (date: Date) => Time;
  maxDate(): Date;
  maxTime: () => Time;
  referenceDate: () => Date;
  calendar: () => Calendar;
  settlementDays: () => Natural;
  checkRange1: (d: Date, extrapolate: boolean) => void;
  checkRange2: (t: Time, extrapolate: boolean) => void;
  vtsInit1:
      (bdc: BusinessDayConvention, dc: DayCounter) => VolatilityTermStructure;
  vtsInit2:
      (referenceDate: Date, cal: Calendar, bdc: BusinessDayConvention,
       dc: DayCounter) => VolatilityTermStructure;
  vtsInit3:
      (settlementDays: Natural, cal: Calendar, bdc: BusinessDayConvention,
       dc: DayCounter) => VolatilityTermStructure;
  businessDayConvention: () => BusinessDayConvention;
  optionDateFromTenor: (p: Period) => Date;
  minStrike(): Rate;
  maxStrike(): Rate;
  checkStrike: (k: Rate, extrapolate: boolean) => void;
  volatility1:
      (optionTenor: Period, swapTenor: Period, strike: Rate,
       extrapolate?: boolean) => Volatility;
  volatility2:
      (optionDate: Date, swapTenor: Period, strike: Rate,
       extrapolate?: boolean) => Volatility;
  volatility3:
      (optionTime: Time, swapTenor: Period, strike: Rate,
       extrapolate?: boolean) => Volatility;
  volatility4:
      (optionTenor: Period, swapLength: Time, strike: Rate,
       extrapolate?: boolean) => Volatility;
  volatility5:
      (optionDate: Date, swapLength: Time, strike: Rate,
       extrapolate?: boolean) => Volatility;
  volatility6:
      (optionTime: Time, swapLength: Time, strike: Rate,
       extrapolate?: boolean) => Volatility;
  blackVariance1:
      (optionTenor: Period, swapTenor: Period, strike: Rate,
       extrapolate?: boolean) => Real;
  blackVariance2:
      (optionDate: Date, swapTenor: Period, strike: Rate,
       extrapolate?: boolean) => Real;
  blackVariance3:
      (optionTime: Time, swapTenor: Period, strike: Rate,
       extrapolate?: boolean) => Real;
  blackVariance4:
      (optionTenor: Period, swapLength: Time, strike: Rate,
       extrapolate?: boolean) => Real;
  blackVariance5:
      (optionDate: Date, swapLength: Time, strike: Rate,
       extrapolate?: boolean) => Real;
  blackVariance6:
      (optionTime: Time, swapLength: Time, strike: Rate,
       extrapolate?: boolean) => Real;
  shift1:
      (optionTenor: Period, swapTenor: Period, extrapolate?: boolean) => Real;
  shift2: (optionDate: Date, swapTenor: Period, extrapolate?: boolean) => Real;
  shift3: (optionTime: Time, swapTenor: Period, extrapolate?: boolean) => Real;
  shift4:
      (optionTenor: Period, swapLength: Time, extrapolate?: boolean) => Real;
  shift5: (optionDate: Date, swapLength: Time, extrapolate?: boolean) => Real;
  shift6: (optionTime: Time, swapLength: Time, extrapolate?: boolean) => Real;
  smileSection1:
      (optionTenor: Period, swapTenor: Period,
       extrapolate?: boolean) => SmileSection;
  smileSection2:
      (optionDate: Date, swapTenor: Period,
       extrapolate?: boolean) => SmileSection;
  smileSection3:
      (optionTime: Time, swapTenor: Period,
       extrapolate?: boolean) => SmileSection;
  smileSection4:
      (optionTenor: Period, swapLength: Time,
       extrapolate?: boolean) => SmileSection;
  smileSection5:
      (optionDate: Date, swapLength: Time,
       extrapolate?: boolean) => SmileSection;
  smileSection6:
      (optionTime: Time, swapLength: Time,
       extrapolate?: boolean) => SmileSection;
  maxSwapTenor(): Period;
  maxSwapLength: () => Time;
  volatilityType(): VolatilityType;
  swapLength1: (swapTenor: Period) => Time;
  swapLength2: (start: Date, end: Date) => Time;
  smileSectionImpl1: (optionDate: Date, swapTenor: Period) => SmileSection;
  smileSectionImpl2: (optionTime: Time, swapLength: Time) => SmileSection;
  volatilityImpl1:
      (optionDate: Date, swapTenor: Period, strike: Rate) => Volatility;
  volatilityImpl2:
      (optionTime: Time, swapLength: Time, strike: Rate) => Volatility;
  shiftImpl1: (optionDate: Date, swapTenor: Period) => Real;
  shiftImpl2: (optionTime: Time, swapLength: Time) => Real;
  checkSwapTenor1: (swapTenor: Period, extrapolate: boolean) => void;
  checkSwapTenor2: (swapLength: Time, extrapolate: boolean) => void;
  recalculate: () => void;
  freeze: () => void;
  unfreeze: () => void;
  alwaysForwardNotifications: () => void;
  calculate: () => void;
  performCalculations(): void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _extrapolate: boolean;
  _moving: boolean;
  _updated: boolean;
  _calendar: Calendar;
  _referenceDate: Date;
  _settlementDays: Natural;
  _dayCounter: DayCounter;
  _bdc: BusinessDayConvention;
  _calculated: boolean;
  _frozen: boolean;
  _alwaysForward: boolean;
}

export declare class YieldTermStructureInterpolatedCurve implements
    Observable, Observer, Extrapolator, TermStructure, YieldTermStructure,
    InterpolatedCurve {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update: () => void;
  deepUpdate: () => void;
  enableExtrapolation: (b: boolean) => void;
  disableExtrapolation: (b: boolean) => void;
  allowsExtrapolation: () => boolean;
  tsInit1: (dc: DayCounter) => TermStructure;
  tsInit2:
      (referenceDate: Date, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  tsInit3:
      (settlementDays: Natural, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  dayCounter: () => DayCounter;
  timeFromReference: (date: Date) => Time;
  maxDate(): Date;
  maxTime: () => Time;
  referenceDate: () => Date;
  calendar: () => Calendar;
  settlementDays: () => Natural;
  checkRange1: (d: Date, extrapolate: boolean) => void;
  checkRange2: (t: Time, extrapolate: boolean) => void;
  ytsInit1:
      (dc: DayCounter, jumps?: Array<Handle<Quote>>,
       jumpDates?: Date[]) => YieldTermStructure;
  ytsInit2:
      (referenceDate: Date, calendar: Calendar, dc: DayCounter,
       jumps?: Array<Handle<Quote>>, jumpDates?: Date[]) => YieldTermStructure;
  ytsInit3:
      (settlementDays: Natural, calendar: Calendar, dc: DayCounter,
       jumps?: Array<Handle<Quote>>, jumpDates?: Date[]) => YieldTermStructure;
  discount1: (d: Date, extrapolate: boolean) => DiscountFactor;
  discount2: (t: Time, extrapolate: boolean) => DiscountFactor;
  zeroRate1:
      (d: Date, resultDayCounter: DayCounter, comp: Compounding,
       freq: Frequency, extrapolate: boolean) => InterestRate;
  zeroRate2:
      (t: Time, comp: Compounding, freq: Frequency,
       extrapolate: boolean) => InterestRate;
  forwardRate1:
      (d1: Date, d2: Date, resultDayCounter: DayCounter, comp: Compounding,
       freq: Frequency, extrapolate: boolean) => InterestRate;
  forwardRate2:
      (d: Date, p: Period, resultDayCounter: DayCounter, comp: Compounding,
       freq: Frequency, extrapolate: boolean) => InterestRate;
  forwardRate3:
      (t1: Time, t2: Time, comp: Compounding, freq: Frequency,
       extrapolate: boolean) => InterestRate;
  jumpDates: () => Date[];
  jumpTimes: () => Time[];
  discountImpl(t: Time): DiscountFactor;
  setJumps: () => void;
  icInit1: (times: Time[], data: Real[], i: Interpolator) => InterpolatedCurve;
  icInit2: (times: Time[], i: Interpolator) => InterpolatedCurve;
  icInit3: (n: Size, i: Interpolator) => InterpolatedCurve;
  icInit4: (i: Interpolator) => InterpolatedCurve;
  icInit5: (i: InterpolatedCurve) => InterpolatedCurve;
  setupInterpolation: () => void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _extrapolate: boolean;
  _moving: boolean;
  _updated: boolean;
  _calendar: Calendar;
  _referenceDate: Date;
  _settlementDays: Natural;
  _dayCounter: DayCounter;
  _jumps: Array<Handle<Quote>>;
  _jumpDates: Date[];
  _jumpTimes: Time[];
  _nJumps: Size;
  _latestReference: Date;
  _times: Time[];
  _data: Real[];
  _interpolation: Interpolation;
  _interpolator: Interpolator;
  _maxDate: Date;
}

export declare class YieldTermStructureInterpolatedCurveLazyObject implements
    Observable, Observer, Extrapolator, TermStructure, YieldTermStructure,
    InterpolatedCurve, LazyObject {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  enableExtrapolation: (b: boolean) => void;
  disableExtrapolation: (b: boolean) => void;
  allowsExtrapolation: () => boolean;
  tsInit1: (dc: DayCounter) => TermStructure;
  tsInit2:
      (referenceDate: Date, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  tsInit3:
      (settlementDays: Natural, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  dayCounter: () => DayCounter;
  timeFromReference: (date: Date) => Time;
  maxDate(): Date;
  maxTime: () => Time;
  referenceDate: () => Date;
  calendar: () => Calendar;
  settlementDays: () => Natural;
  checkRange1: (d: Date, extrapolate: boolean) => void;
  checkRange2: (t: Time, extrapolate: boolean) => void;
  ytsInit1:
      (dc: DayCounter, jumps?: Array<Handle<Quote>>,
       jumpDates?: Date[]) => YieldTermStructure;
  ytsInit2:
      (referenceDate: Date, calendar: Calendar, dc: DayCounter,
       jumps?: Array<Handle<Quote>>, jumpDates?: Date[]) => YieldTermStructure;
  ytsInit3:
      (settlementDays: Natural, calendar: Calendar, dc: DayCounter,
       jumps?: Array<Handle<Quote>>, jumpDates?: Date[]) => YieldTermStructure;
  discount1: (d: Date, extrapolate?: boolean) => DiscountFactor;
  discount2: (t: Time, extrapolate?: boolean) => DiscountFactor;
  zeroRate1:
      (d: Date, resultDayCounter: DayCounter, comp: Compounding,
       freq?: Frequency, extrapolate?: boolean) => InterestRate;
  zeroRate2:
      (t: Time, comp: Compounding, freq?: Frequency,
       extrapolate?: boolean) => InterestRate;
  forwardRate1:
      (d1: Date, d2: Date, resultDayCounter: DayCounter, comp: Compounding,
       freq?: Frequency, extrapolate?: boolean) => InterestRate;
  forwardRate2:
      (d: Date, p: Period, resultDayCounter: DayCounter, comp: Compounding,
       freq?: Frequency, extrapolate?: boolean) => InterestRate;
  forwardRate3:
      (t1: Time, t2: Time, comp: Compounding, freq?: Frequency,
       extrapolate?: boolean) => InterestRate;
  jumpDates: () => Date[];
  jumpTimes: () => Time[];
  discountImpl(t: Time): DiscountFactor;
  setJumps: () => void;
  icInit1: (times: Time[], data: Real[], i?: Interpolator) => InterpolatedCurve;
  icInit2: (times: Time[], i?: Interpolator) => InterpolatedCurve;
  icInit3: (n: Size, i?: Interpolator) => InterpolatedCurve;
  icInit4: (i?: Interpolator) => InterpolatedCurve;
  icInit5: (i: InterpolatedCurve) => InterpolatedCurve;
  setupInterpolation: () => void;
  curveInit1:
      (dates: Date[], dfs: DiscountFactor[], dayCounter: DayCounter,
       calendar?: Calendar, jumps?: Array<Handle<Quote>>,
       jumpDates?: Date[]) => YieldCurve;
  curveInit2:
      (dates: Date[], dfs: DiscountFactor[], dayCounter: DayCounter,
       calendar: Calendar) => YieldCurve;
  curveInit3:
      (dates: Date[], dfs: DiscountFactor[],
       dayCounter: DayCounter) => YieldCurve;
  curveInit4:
      (dayCounter: DayCounter, jumps?: Array<Handle<Quote>>,
       jumpDates?: Date[]) => YieldCurve;
  curveInit5:
      (referenceDate: Date, dayCounter: DayCounter,
       jumps?: Array<Handle<Quote>>, jumpDates?: Date[]) => YieldCurve;
  curveInit6:
      (settlementDays: Natural, calendar: Calendar, dayCounter: DayCounter,
       jumps?: Array<Handle<Quote>>, jumpDates?: Date[]) => YieldCurve;
  data(): Real[];
  times(): Time[];
  dates(): Date[];
  nodes(): Array<[Date, Real]>;
  recalculate: () => void;
  freeze: () => void;
  unfreeze: () => void;
  alwaysForwardNotifications: () => void;
  calculate: () => void;
  performCalculations(): void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _extrapolate: boolean;
  _moving: boolean;
  _updated: boolean;
  _calendar: Calendar;
  _referenceDate: Date;
  _settlementDays: Natural;
  _dayCounter: DayCounter;
  _jumps: Array<Handle<Quote>>;
  _jumpDates: Date[];
  _jumpTimes: Time[];
  _nJumps: Size;
  _latestReference: Date;
  _times: Time[];
  _data: Real[];
  _interpolation: Interpolation;
  _interpolator: Interpolator;
  _maxDate: Date;
  _calculated: boolean;
  _frozen: boolean;
  _alwaysForward: boolean;
}

declare class YieldTermStructureLazyObject implements Observable, Observer,
                                                      Extrapolator,
                                                      TermStructure,
                                                      YieldTermStructure,
                                                      LazyObject {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  enableExtrapolation: (b: boolean) => void;
  disableExtrapolation: (b: boolean) => void;
  allowsExtrapolation: () => boolean;
  tsInit1: (dc: DayCounter) => TermStructure;
  tsInit2:
      (referenceDate: Date, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  tsInit3:
      (settlementDays: Natural, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  dayCounter: () => DayCounter;
  timeFromReference: (date: Date) => Time;
  maxDate(): Date;
  maxTime: () => Time;
  referenceDate: () => Date;
  calendar: () => Calendar;
  settlementDays: () => Natural;
  checkRange1: (d: Date, extrapolate: boolean) => void;
  checkRange2: (t: Time, extrapolate: boolean) => void;
  ytsInit1:
      (dc: DayCounter, jumps?: Array<Handle<Quote>>,
       jumpDates?: Date[]) => YieldTermStructure;
  ytsInit2:
      (referenceDate: Date, calendar: Calendar, dc: DayCounter,
       jumps?: Array<Handle<Quote>>, jumpDates?: Date[]) => YieldTermStructure;
  ytsInit3:
      (settlementDays: Natural, calendar: Calendar, dc: DayCounter,
       jumps?: Array<Handle<Quote>>, jumpDates?: Date[]) => YieldTermStructure;
  discount1: (d: Date, extrapolate: boolean) => DiscountFactor;
  discount2: (t: Time, extrapolate: boolean) => DiscountFactor;
  zeroRate1:
      (d: Date, resultDayCounter: DayCounter, comp: Compounding,
       freq: Frequency, extrapolate: boolean) => InterestRate;
  zeroRate2:
      (t: Time, comp: Compounding, freq: Frequency,
       extrapolate: boolean) => InterestRate;
  forwardRate1:
      (d1: Date, d2: Date, resultDayCounter: DayCounter, comp: Compounding,
       freq: Frequency, extrapolate: boolean) => InterestRate;
  forwardRate2:
      (d: Date, p: Period, resultDayCounter: DayCounter, comp: Compounding,
       freq: Frequency, extrapolate: boolean) => InterestRate;
  forwardRate3:
      (t1: Time, t2: Time, comp: Compounding, freq: Frequency,
       extrapolate: boolean) => InterestRate;
  jumpDates: () => Date[];
  jumpTimes: () => Time[];
  discountImpl(t: Time): DiscountFactor;
  setJumps: () => void;
  recalculate: () => void;
  freeze: () => void;
  unfreeze: () => void;
  alwaysForwardNotifications: () => void;
  calculate: () => void;
  performCalculations(): void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _extrapolate: boolean;
  _moving: boolean;
  _updated: boolean;
  _calendar: Calendar;
  _referenceDate: Date;
  _settlementDays: Natural;
  _dayCounter: DayCounter;
  _jumps: Array<Handle<Quote>>;
  _jumpDates: Date[];
  _jumpTimes: Time[];
  _nJumps: Size;
  _latestReference: Date;
  _calculated: boolean;
  _frozen: boolean;
  _alwaysForward: boolean;
}

declare class YoYInflationTermStructureInterpolatedCurveLazyObject implements
    Observable, Observer, Extrapolator, TermStructure, InflationTermStructure,
    YoYInflationTermStructure, InterpolatedCurve, LazyObject {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  enableExtrapolation: (b: boolean) => void;
  disableExtrapolation: (b: boolean) => void;
  allowsExtrapolation: () => boolean;
  tsInit1: (dc: DayCounter) => TermStructure;
  tsInit2:
      (referenceDate: Date, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  tsInit3:
      (settlementDays: Natural, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  dayCounter: () => DayCounter;
  timeFromReference: (date: Date) => Time;
  maxDate(): Date;
  maxTime: () => Time;
  referenceDate: () => Date;
  calendar: () => Calendar;
  settlementDays: () => Natural;
  checkRange1: (d: Date, extrapolate: boolean) => void;
  checkRange2: (t: Time, extrapolate: boolean) => void;
  itsInit1:
      (baseRate: Rate, observationLag: Period, frequency: Frequency,
       indexIsInterpolated: boolean, yTS: Handle<YieldTermStructure>,
       dayCounter?: DayCounter,
       seasonality?: Seasonality) => InflationTermStructure;
  itsInit2:
      (referenceDate: Date, baseRate: Rate, observationLag: Period,
       frequency: Frequency, indexIsInterpolated: boolean,
       yTS: Handle<YieldTermStructure>, calendar?: Calendar,
       dayCounter?: DayCounter,
       seasonality?: Seasonality) => InflationTermStructure;
  itsInit3:
      (settlementDays: Natural, calendar: Calendar, baseRate: Rate,
       observationLag: Period, frequency: Frequency,
       indexIsInterpolated: boolean, yTS: Handle<YieldTermStructure>,
       dayCounter?: DayCounter,
       seasonality?: Seasonality) => InflationTermStructure;
  observationLag: () => Period;
  frequency: () => Frequency;
  indexIsInterpolated: () => boolean;
  baseRate: () => Rate;
  nominalTermStructure: () => Handle<YieldTermStructure>;
  baseDate(): Date;
  setSeasonality: (seasonality?: Seasonality) => void;
  seasonality: () => Seasonality;
  hasSeasonality: () => boolean;
  setBaseRate: (r: Rate) => void;
  yoyitsInit1:
      (dayCounter: DayCounter, baseYoYRate: Rate, lag: Period,
       frequency: Frequency, indexIsInterpolated: boolean,
       yieldTS: Handle<YieldTermStructure>,
       seasonality: Seasonality) => YoYInflationTermStructure;
  yoyitsInit2:
      (referenceDate: Date, calendar: Calendar, dayCounter: DayCounter,
       baseZeroRate: Rate, lag: Period, frequency: Frequency,
       indexIsInterpolated: boolean, yTS: Handle<YieldTermStructure>,
       seasonality?: Seasonality) => YoYInflationTermStructure;
  yoyitsInit3:
      (settlementDays: Natural, calendar: Calendar, dayCounter: DayCounter,
       baseZeroRate: Rate, lag: Period, frequency: Frequency,
       indexIsInterpolated: boolean, yTS: Handle<YieldTermStructure>,
       seasonality?: Seasonality) => YoYInflationTermStructure;
  yoyRate1:
      (d: Date, instObsLag?: Period, forceLinearInterpolation?: boolean,
       extrapolate?: boolean) => Rate;
  yoyRate2: (t: Time, extrapolate?: boolean) => Rate;
  yoyRateImpl: (t: Time) => Rate;
  icInit1: (times: Time[], data: Real[], i: Interpolator) => InterpolatedCurve;
  icInit2: (times: Time[], i: Interpolator) => InterpolatedCurve;
  icInit3: (n: Size, i: Interpolator) => InterpolatedCurve;
  icInit4: (i: Interpolator) => InterpolatedCurve;
  icInit5: (i: InterpolatedCurve) => InterpolatedCurve;
  setupInterpolation: () => void;
  curveInit1:
      (referenceDate: Date, calendar: Calendar, dayCounter: DayCounter,
       lag: Period, frequency: Frequency, indexIsInterpolated: boolean,
       yTS: Handle<YieldTermStructure>, dates: Date[], rates: Rate[],
       interpolator?: Interpolator) => InflationCurve;
  curveInit2:
      (referenceDate: Date, calendar: Calendar, dayCounter: DayCounter,
       baseRate: Rate, lag: Period, frequency: Frequency,
       indexIsInterpolated: boolean, yTS: Handle<YieldTermStructure>,
       interpolator?: Interpolator) => InflationCurve;
  recalculate: () => void;
  freeze: () => void;
  unfreeze: () => void;
  alwaysForwardNotifications: () => void;
  calculate: () => void;
  performCalculations(): void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _extrapolate: boolean;
  _moving: boolean;
  _updated: boolean;
  _calendar: Calendar;
  _referenceDate: Date;
  _settlementDays: Natural;
  _dayCounter: DayCounter;
  _seasonality: Seasonality;
  _observationLag: Period;
  _frequency: Frequency;
  _indexIsInterpolated: boolean;
  _baseRate: Rate;
  _nominalTermStructure: Handle<YieldTermStructure>;
  _times: Time[];
  _data: Real[];
  _interpolation: Interpolation;
  _interpolator: Interpolator;
  _maxDate: Date;
  _calculated: boolean;
  _frozen: boolean;
  _alwaysForward: boolean;
}

export declare class YoYInflationTermStructureInterpolatedCurve implements
    Observable, Observer, Extrapolator, TermStructure, InflationTermStructure,
    YoYInflationTermStructure, InterpolatedCurve {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update: () => void;
  deepUpdate: () => void;
  enableExtrapolation: (b: boolean) => void;
  disableExtrapolation: (b: boolean) => void;
  allowsExtrapolation: () => boolean;
  tsInit1: (dc: DayCounter) => TermStructure;
  tsInit2:
      (referenceDate: Date, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  tsInit3:
      (settlementDays: Natural, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  dayCounter: () => DayCounter;
  timeFromReference: (date: Date) => Time;
  maxDate(): Date;
  maxTime: () => Time;
  referenceDate: () => Date;
  calendar: () => Calendar;
  settlementDays: () => Natural;
  checkRange1: (d: Date, extrapolate: boolean) => void;
  checkRange2: (t: Time, extrapolate: boolean) => void;
  itsInit1:
      (baseRate: Rate, observationLag: Period, frequency: Frequency,
       indexIsInterpolated: boolean, yTS: Handle<YieldTermStructure>,
       dayCounter?: DayCounter,
       seasonality?: Seasonality) => InflationTermStructure;
  itsInit2:
      (referenceDate: Date, baseRate: Rate, observationLag: Period,
       frequency: Frequency, indexIsInterpolated: boolean,
       yTS: Handle<YieldTermStructure>, calendar?: Calendar,
       dayCounter?: DayCounter,
       seasonality?: Seasonality) => InflationTermStructure;
  itsInit3:
      (settlementDays: Natural, calendar: Calendar, baseRate: Rate,
       observationLag: Period, frequency: Frequency,
       indexIsInterpolated: boolean, yTS: Handle<YieldTermStructure>,
       dayCounter?: DayCounter,
       seasonality?: Seasonality) => InflationTermStructure;
  observationLag: () => Period;
  frequency: () => Frequency;
  indexIsInterpolated: () => boolean;
  baseRate: () => Rate;
  nominalTermStructure: () => Handle<YieldTermStructure>;
  baseDate(): Date;
  setSeasonality: (seasonality?: Seasonality) => void;
  seasonality: () => Seasonality;
  hasSeasonality: () => boolean;
  setBaseRate: (r: Rate) => void;
  yoyitsInit1:
      (dayCounter: DayCounter, baseYoYRate: Rate, lag: Period,
       frequency: Frequency, indexIsInterpolated: boolean,
       yieldTS: Handle<YieldTermStructure>,
       seasonality: Seasonality) => YoYInflationTermStructure;
  yoyitsInit2:
      (referenceDate: Date, calendar: Calendar, dayCounter: DayCounter,
       baseZeroRate: Rate, lag: Period, frequency: Frequency,
       indexIsInterpolated: boolean, yTS: Handle<YieldTermStructure>,
       seasonality?: Seasonality) => YoYInflationTermStructure;
  yoyitsInit3:
      (settlementDays: Natural, calendar: Calendar, dayCounter: DayCounter,
       baseZeroRate: Rate, lag: Period, frequency: Frequency,
       indexIsInterpolated: boolean, yTS: Handle<YieldTermStructure>,
       seasonality?: Seasonality) => YoYInflationTermStructure;
  yoyRate1:
      (d: Date, instObsLag?: Period, forceLinearInterpolation?: boolean,
       extrapolate?: boolean) => Rate;
  yoyRate2: (t: Time, extrapolate?: boolean) => Rate;
  yoyRateImpl(t: Time): Rate;
  icInit1: (times: Time[], data: Real[], i: Interpolator) => InterpolatedCurve;
  icInit2: (times: Time[], i: Interpolator) => InterpolatedCurve;
  icInit3: (n: Size, i: Interpolator) => InterpolatedCurve;
  icInit4: (i: Interpolator) => InterpolatedCurve;
  icInit5: (i: InterpolatedCurve) => InterpolatedCurve;
  setupInterpolation: () => void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _extrapolate: boolean;
  _moving: boolean;
  _updated: boolean;
  _calendar: Calendar;
  _referenceDate: Date;
  _settlementDays: Natural;
  _dayCounter: DayCounter;
  _seasonality: Seasonality;
  _observationLag: Period;
  _frequency: Frequency;
  _indexIsInterpolated: boolean;
  _baseRate: Rate;
  _nominalTermStructure: Handle<YieldTermStructure>;
  _times: Time[];
  _data: Real[];
  _interpolation: Interpolation;
  _interpolator: Interpolator;
  _maxDate: Date;
}

export declare class ZeroInflationTermStructureInterpolatedCurve implements
    Observable, Observer, Extrapolator, TermStructure, InflationTermStructure,
    ZeroInflationTermStructure, InterpolatedCurve {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update: () => void;
  deepUpdate: () => void;
  enableExtrapolation: (b: boolean) => void;
  disableExtrapolation: (b: boolean) => void;
  allowsExtrapolation: () => boolean;
  tsInit1: (dc: DayCounter) => TermStructure;
  tsInit2:
      (referenceDate: Date, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  tsInit3:
      (settlementDays: Natural, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  dayCounter: () => DayCounter;
  timeFromReference: (date: Date) => Time;
  maxDate(): Date;
  maxTime: () => Time;
  referenceDate: () => Date;
  calendar: () => Calendar;
  settlementDays: () => Natural;
  checkRange1: (d: Date, extrapolate: boolean) => void;
  checkRange2: (t: Time, extrapolate: boolean) => void;
  itsInit1:
      (baseRate: Rate, observationLag: Period, frequency: Frequency,
       indexIsInterpolated: boolean, yTS: Handle<YieldTermStructure>,
       dayCounter?: DayCounter,
       seasonality?: Seasonality) => InflationTermStructure;
  itsInit2:
      (referenceDate: Date, baseRate: Rate, observationLag: Period,
       frequency: Frequency, indexIsInterpolated: boolean,
       yTS: Handle<YieldTermStructure>, calendar?: Calendar,
       dayCounter?: DayCounter,
       seasonality?: Seasonality) => InflationTermStructure;
  itsInit3:
      (settlementDays: Natural, calendar: Calendar, baseRate: Rate,
       observationLag: Period, frequency: Frequency,
       indexIsInterpolated: boolean, yTS: Handle<YieldTermStructure>,
       dayCounter?: DayCounter,
       seasonality?: Seasonality) => InflationTermStructure;
  observationLag: () => Period;
  frequency: () => Frequency;
  indexIsInterpolated: () => boolean;
  baseRate: () => Rate;
  nominalTermStructure: () => Handle<YieldTermStructure>;
  baseDate(): Date;
  setSeasonality: (seasonality?: Seasonality) => void;
  seasonality: () => Seasonality;
  hasSeasonality: () => boolean;
  setBaseRate: (r: Rate) => void;
  zitsInit1:
      (dayCounter: DayCounter, baseZeroRate: Rate, lag: Period,
       frequency: Frequency, indexIsInterpolated: boolean,
       yTS: Handle<YieldTermStructure>,
       seasonality?: Seasonality) => ZeroInflationTermStructure;
  zitsInit2:
      (referenceDate: Date, calendar: Calendar, dayCounter: DayCounter,
       baseZeroRate: Rate, lag: Period, frequency: Frequency,
       indexIsInterpolated: boolean, yTS: Handle<YieldTermStructure>,
       seasonality?: Seasonality) => ZeroInflationTermStructure;
  zitsInit3:
      (settlementDays: Natural, calendar: Calendar, dayCounter: DayCounter,
       baseZeroRate: Rate, lag: Period, frequency: Frequency,
       indexIsInterpolated: boolean, yTS: Handle<YieldTermStructure>,
       seasonality?: Seasonality) => ZeroInflationTermStructure;
  zeroRate1:
      (d: Date, instObsLag?: Period, forceLinearInterpolation?: boolean,
       extrapolate?: boolean) => Rate;
  zeroRate2: (t: Time, extrapolate?: boolean) => Rate;
  zeroRateImpl(t: Time): Rate;
  icInit1: (times: Time[], data: Real[], i: Interpolator) => InterpolatedCurve;
  icInit2: (times: Time[], i: Interpolator) => InterpolatedCurve;
  icInit3: (n: Size, i: Interpolator) => InterpolatedCurve;
  icInit4: (i: Interpolator) => InterpolatedCurve;
  icInit5: (i: InterpolatedCurve) => InterpolatedCurve;
  setupInterpolation: () => void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _extrapolate: boolean;
  _moving: boolean;
  _updated: boolean;
  _calendar: Calendar;
  _referenceDate: Date;
  _settlementDays: Natural;
  _dayCounter: DayCounter;
  _seasonality: Seasonality;
  _observationLag: Period;
  _frequency: Frequency;
  _indexIsInterpolated: boolean;
  _baseRate: Rate;
  _nominalTermStructure: Handle<YieldTermStructure>;
  _times: Time[];
  _data: Real[];
  _interpolation: Interpolation;
  _interpolator: Interpolator;
  _maxDate: Date;
}

declare class ZeroInflationTermStructureInterpolatedCurveLazyObject implements
    Observable, Observer, Extrapolator, TermStructure, InflationTermStructure,
    ZeroInflationTermStructure, InterpolatedCurve, LazyObject {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update(): void;
  deepUpdate: () => void;
  enableExtrapolation: (b: boolean) => void;
  disableExtrapolation: (b: boolean) => void;
  allowsExtrapolation: () => boolean;
  tsInit1: (dc: DayCounter) => TermStructure;
  tsInit2:
      (referenceDate: Date, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  tsInit3:
      (settlementDays: Natural, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  dayCounter: () => DayCounter;
  timeFromReference: (date: Date) => Time;
  maxDate(): Date;
  maxTime: () => Time;
  referenceDate: () => Date;
  calendar: () => Calendar;
  settlementDays: () => Natural;
  checkRange1: (d: Date, extrapolate: boolean) => void;
  checkRange2: (t: Time, extrapolate: boolean) => void;
  itsInit1:
      (baseRate: Rate, observationLag: Period, frequency: Frequency,
       indexIsInterpolated: boolean, yTS: Handle<YieldTermStructure>,
       dayCounter?: DayCounter,
       seasonality?: Seasonality) => InflationTermStructure;
  itsInit2:
      (referenceDate: Date, baseRate: Rate, observationLag: Period,
       frequency: Frequency, indexIsInterpolated: boolean,
       yTS: Handle<YieldTermStructure>, calendar?: Calendar,
       dayCounter?: DayCounter,
       seasonality?: Seasonality) => InflationTermStructure;
  itsInit3:
      (settlementDays: Natural, calendar: Calendar, baseRate: Rate,
       observationLag: Period, frequency: Frequency,
       indexIsInterpolated: boolean, yTS: Handle<YieldTermStructure>,
       dayCounter?: DayCounter,
       seasonality?: Seasonality) => InflationTermStructure;
  observationLag: () => Period;
  frequency: () => Frequency;
  indexIsInterpolated: () => boolean;
  baseRate: () => Rate;
  nominalTermStructure: () => Handle<YieldTermStructure>;
  baseDate(): Date;
  setSeasonality: (seasonality?: Seasonality) => void;
  seasonality: () => Seasonality;
  hasSeasonality: () => boolean;
  setBaseRate: (r: Rate) => void;
  zitsInit1:
      (dayCounter: DayCounter, baseZeroRate: Rate, lag: Period,
       frequency: Frequency, indexIsInterpolated: boolean,
       yTS: Handle<YieldTermStructure>,
       seasonality?: Seasonality) => ZeroInflationTermStructure;
  zitsInit2:
      (referenceDate: Date, calendar: Calendar, dayCounter: DayCounter,
       baseZeroRate: Rate, lag: Period, frequency: Frequency,
       indexIsInterpolated: boolean, yTS: Handle<YieldTermStructure>,
       seasonality?: Seasonality) => ZeroInflationTermStructure;
  zitsInit3:
      (settlementDays: Natural, calendar: Calendar, dayCounter: DayCounter,
       baseZeroRate: Rate, lag: Period, frequency: Frequency,
       indexIsInterpolated: boolean, yTS: Handle<YieldTermStructure>,
       seasonality?: Seasonality) => ZeroInflationTermStructure;
  zeroRate1:
      (d: Date, instObsLag?: Period, forceLinearInterpolation?: boolean,
       extrapolate?: boolean) => Rate;
  zeroRate2: (t: Time, extrapolate?: boolean) => Rate;
  zeroRateImpl: (t: Time) => Rate;
  icInit1: (times: Time[], data: Real[], i: Interpolator) => InterpolatedCurve;
  icInit2: (times: Time[], i: Interpolator) => InterpolatedCurve;
  icInit3: (n: Size, i: Interpolator) => InterpolatedCurve;
  icInit4: (i: Interpolator) => InterpolatedCurve;
  icInit5: (i: InterpolatedCurve) => InterpolatedCurve;
  setupInterpolation: () => void;
  curveInit1:
      (referenceDate: Date, calendar: Calendar, dayCounter: DayCounter,
       lag: Period, frequency: Frequency, indexIsInterpolated: boolean,
       yTS: Handle<YieldTermStructure>, dates: Date[], rates: Rate[],
       interpolator?: Interpolator) => InflationCurve;
  curveInit2:
      (referenceDate: Date, calendar: Calendar, dayCounter: DayCounter,
       baseRate: Rate, lag: Period, frequency: Frequency,
       indexIsInterpolated: boolean, yTS: Handle<YieldTermStructure>,
       interpolator?: Interpolator) => InflationCurve;
  recalculate: () => void;
  freeze: () => void;
  unfreeze: () => void;
  alwaysForwardNotifications: () => void;
  calculate: () => void;
  performCalculations(): void;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _extrapolate: boolean;
  _moving: boolean;
  _updated: boolean;
  _calendar: Calendar;
  _referenceDate: Date;
  _settlementDays: Natural;
  _dayCounter: DayCounter;
  _seasonality: Seasonality;
  _observationLag: Period;
  _frequency: Frequency;
  _indexIsInterpolated: boolean;
  _baseRate: Rate;
  _nominalTermStructure: Handle<YieldTermStructure>;
  _times: Time[];
  _data: Real[];
  _interpolation: Interpolation;
  _interpolator: Interpolator;
  _maxDate: Date;
  _calculated: boolean;
  _frozen: boolean;
  _alwaysForward: boolean;
}

export declare class ZeroYieldStructureInterpolatedCurve implements
    Observable, Observer, Extrapolator, TermStructure, YieldTermStructure,
    ZeroYieldStructure, InterpolatedCurve {
  notifyObservers: () => void;
  registerObserver: (o: Observer) => void;
  unregisterObserver: (o: Observer) => void;
  registerWith: (h: Observable) => void;
  registerWithObservables: (o: Observer) => void;
  unregisterWith: (h: Observable) => Size;
  unregisterWithAll: () => void;
  update: () => void;
  deepUpdate: () => void;
  enableExtrapolation: (b: boolean) => void;
  disableExtrapolation: (b: boolean) => void;
  allowsExtrapolation: () => boolean;
  tsInit1: (dc: DayCounter) => TermStructure;
  tsInit2:
      (referenceDate: Date, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  tsInit3:
      (settlementDays: Natural, calendar: Calendar,
       dc: DayCounter) => TermStructure;
  dayCounter: () => DayCounter;
  timeFromReference: (date: Date) => Time;
  maxDate(): Date;
  maxTime: () => Time;
  referenceDate: () => Date;
  calendar: () => Calendar;
  settlementDays: () => Natural;
  checkRange1: (d: Date, extrapolate: boolean) => void;
  checkRange2: (t: Time, extrapolate: boolean) => void;
  ytsInit1:
      (dc: DayCounter, jumps?: Array<Handle<Quote>>,
       jumpDates?: Date[]) => YieldTermStructure;
  ytsInit2:
      (referenceDate: Date, calendar: Calendar, dc: DayCounter,
       jumps?: Array<Handle<Quote>>, jumpDates?: Date[]) => YieldTermStructure;
  ytsInit3:
      (settlementDays: Natural, calendar: Calendar, dc: DayCounter,
       jumps?: Array<Handle<Quote>>, jumpDates?: Date[]) => YieldTermStructure;
  discount1: (d: Date, extrapolate: boolean) => DiscountFactor;
  discount2: (t: Time, extrapolate: boolean) => DiscountFactor;
  zeroRate1:
      (d: Date, resultDayCounter: DayCounter, comp: Compounding,
       freq: Frequency, extrapolate: boolean) => InterestRate;
  zeroRate2:
      (t: Time, comp: Compounding, freq: Frequency,
       extrapolate: boolean) => InterestRate;
  forwardRate1:
      (d1: Date, d2: Date, resultDayCounter: DayCounter, comp: Compounding,
       freq: Frequency, extrapolate: boolean) => InterestRate;
  forwardRate2:
      (d: Date, p: Period, resultDayCounter: DayCounter, comp: Compounding,
       freq: Frequency, extrapolate: boolean) => InterestRate;
  forwardRate3:
      (t1: Time, t2: Time, comp: Compounding, freq: Frequency,
       extrapolate: boolean) => InterestRate;
  jumpDates: () => Date[];
  jumpTimes: () => Time[];
  discountImpl: (t: Time) => DiscountFactor;
  setJumps: () => void;
  icInit1: (times: Time[], data: Real[], i: Interpolator) => InterpolatedCurve;
  icInit2: (times: Time[], i: Interpolator) => InterpolatedCurve;
  icInit3: (n: Size, i: Interpolator) => InterpolatedCurve;
  icInit4: (i: Interpolator) => InterpolatedCurve;
  icInit5: (i: InterpolatedCurve) => InterpolatedCurve;
  setupInterpolation: () => void;
  zeroYieldImpl(t: Time): Rate;
  isDisposed: boolean;
  dispose: () => void;
  _isDisposed: boolean;
  _observers: Set<Observer>;
  _observables: Set<Observable>;
  _extrapolate: boolean;
  _moving: boolean;
  _updated: boolean;
  _calendar: Calendar;
  _referenceDate: Date;
  _settlementDays: Natural;
  _dayCounter: DayCounter;
  _jumps: Array<Handle<Quote>>;
  _jumpDates: Date[];
  _jumpTimes: Time[];
  _nJumps: Size;
  _latestReference: Date;
  _times: Time[];
  _data: Real[];
  _interpolation: Interpolation;
  _interpolator: Interpolator;
  _maxDate: Date;
}

export declare class LfmCovarianceParameterization {
  constructor(size: Size, factors: Size);
  size(): Size;
  factors(): Size;
  diffusion(t: Time, x?: Real[]): Matrix;
  covariance(t: Time, x?: Real[]): Matrix;
  integratedCovariance1(t: Time, x?: Real[]): Matrix;
  protected _size: Size;
  protected _factors: Size;
}

export declare class LfmCovarianceProxy extends LfmCovarianceParameterization {
  constructor(volaModel: LmVolatilityModel, corrModel: LmCorrelationModel);
  volatilityModel(): LmVolatilityModel;
  correlationModel(): LmCorrelationModel;
  diffusion(t: Time, x?: Real[]): Matrix;
  covariance(t: Time, x?: Real[]): Matrix;
  integratedCovariance2(i: Size, j: Size, t: Time, x?: Real[]): Real;
  protected _volaModel: LmVolatilityModel;
  protected _corrModel: LmCorrelationModel;
}

export declare class LfmHullWhiteParameterization extends
    LfmCovarianceParameterization {
  constructor(
      process: LiborForwardModelProcess,
      capletVol: OptionletVolatilityStructure, correlation?: Matrix,
      factors?: Size);
  diffusion(t: Time, x?: Real[]): Matrix;
  covariance(t: Time, x?: Real[]): Matrix;
  integratedCovariance(t: Time, x?: Real[]): Matrix;
  protected nextIndexReset(t: Time): Size;
  protected _diffusion: Matrix;
  protected _covariance: Matrix;
  protected _fixingTimes: Time[];
}

export declare class LiborForwardModelProcess extends StochasticProcess {
  constructor(size: Size, index: IborIndex);
  initialValues(): Real[];
  drift(t: Time, x: Real[]): Real[];
  diffusion(t: Time, x: Real[]): Matrix;
  covariance(t: Time, x: Real[], dt: Time): Matrix;
  apply(x0: Real[], dx: Real[]): Real[];
  evolve(t0: Time, x0: Real[], dt: Time, dw: Real[]): Real[];
  size(): Size;
  factors(): Size;
  index(): IborIndex;
  cashFlows(amount?: Real): Leg;
  setCovarParam(param: LfmCovarianceParameterization): void;
  covarParam(): LfmCovarianceParameterization;
  nextIndexReset(t: Time): Size;
  fixingTimes(): Time[];
  fixingDates(): Date[];
  accrualStartTimes(): Time[];
  accrualEndTimes(): Time[];
  discountBond(rates: Rate[]): DiscountFactor[];
  private _size;
  private _index;
  private _lfmParam;
  private _initialValues;
  private _fixingTimes;
  private _fixingDates;
  private _accrualStartTimes;
  private _accrualEndTimes;
  private _accrualPeriod;
  private m1;
  private m2;
}

export declare class LfmSwaptionEngine extends GenericModelEngine<
    LiborForwardModel, SwaptionEngine.Arguments, SwaptionEngine.Results> {
  constructor(
      model: LiborForwardModel, discountCurve: Handle<YieldTermStructure>);
  calculate(): void;
  private _discountCurve;
}

export declare class LiborForwardModel extends CalibratedModelAffineModel {
  constructor(
      process: LiborForwardModelProcess, volaModel: LmVolatilityModel,
      corrModel: LmCorrelationModel);
  S_0(alpha: Size, beta: Size): Rate;
  getSwaptionVolatilityMatrix(): SwaptionVolatilityMatrix;
  discount(t: Time): DiscountFactor;
  discountBond(now: Time, maturity: Time, factors: Real[]): Real;
  discountBondOption1(
      type: Option.Type, strike: Real, maturity: Time,
      bondMaturity: Time): Real;
  setParams(params: Real[]): void;
  protected w_0(alpha: Size, beta: Size): Real[];
  protected _f: Real[];
  protected _accrualPeriod: Time[];
  protected _covarProxy: LfmCovarianceProxy;
  protected _process: LiborForwardModelProcess;
  protected swaptionVola: SwaptionVolatilityMatrix;
}

export declare class LmConstWrapperCorrelationModel extends LmCorrelationModel {
  constructor(corrModel: LmCorrelationModel);
  factors(): Size;
  correlation1(t: Time, x?: Real[]): Matrix;
  pseudoSqrt(t: Time, x?: Real[]): Matrix;
  correlation2(i: Size, j: Size, t: Time, x?: Real[]): Real;
  isTimeIndependent(): boolean;
  protected generateArguments(): void;
  protected _corrModel: LmCorrelationModel;
}

export declare class LmCorrelationModel {
  constructor(size: Size, nArguments: Size);
  size(): Size;
  factors(): Size;
  params(): Parameter[];
  setParams(args: Parameter[]): void;
  correlation1(t: Time, x?: Real[]): Matrix;
  pseudoSqrt(t: Time, x?: Real[]): Matrix;
  correlation2(i: Size, j: Size, t: Time, x?: Real[]): Real;
  isTimeIndependent(): boolean;
  protected generateArguments(): void;
  protected _size: Size;
  protected _arguments: Parameter[];
}

export declare class LmConstWrapperVolatilityModel extends LmVolatilityModel {
  constructor(volaModel: LmVolatilityModel);
  volatility1(t: Time, x?: Real[]): Real[];
  volatility2(i: Size, t: Time, x?: Real[]): Volatility;
  integratedVariance(i: Size, j: Size, u: Time, x?: Real[]): Real;
  protected _volaModel: LmVolatilityModel;
}

export declare class LmExponentialCorrelationModel extends LmCorrelationModel {
  constructor(size: Size, rho: Real);
  correlation1(t: Time, x?: Real[]): Matrix;
  pseudoSqrt(t: Time, x?: Real[]): Matrix;
  correlation2(i: Size, j: Size, t: Time, x?: Real[]): Real;
  isTimeIndependent(): boolean;
  protected generateArguments(): void;
  private _corrMatrix;
  private _pseudoSqrt;
}

export declare class LmExtLinearExponentialVolModel extends
    LmLinearExponentialVolatilityModel {
  constructor(fixingTimes: Time[], a: Real, b: Real, c: Real, d: Real);
  volatility1(t: Time, x?: Real[]): Real[];
  volatility2(i: Size, t: Time, x?: Real[]): Volatility;
  integratedVariance(i: Size, j: Size, u: Time, x?: Real[]): Real;
}

export declare class LmFixedVolatilityModel extends LmVolatilityModel {
  constructor(volatilities: Real[], startTimes: Time[]);
  volatility1(t: Time, x?: Real[]): Real[];
  volatility2(i: Size, t: Time, x?: Real[]): Volatility;
  private _volatilities;
  private _startTimes;
}

export declare class LmLinearExponentialCorrelationModel extends
    LmCorrelationModel {
  constructor(size: Size, rho: Real, beta: Real, factors?: Size);
  correlation1(t: Time, x?: Real[]): Matrix;
  pseudoSqrt(t: Time, x?: Real[]): Matrix;
  correlation2(i: Size, j: Size, t: Time, x?: Real[]): Real;
  factors(): Size;
  isTimeIndependent(): boolean;
  protected generateArguments(): void;
  private _corrMatrix;
  private _pseudoSqrt;
  private _factors;
}

export declare class LmLinearExponentialVolatilityModel extends
    LmVolatilityModel {
  constructor(fixingTimes: Time[], a: Real, b: Real, c: Real, d: Real);
  volatility1(t: Time, x?: Real[]): Real[];
  volatility2(i: Size, t: Time, x?: Real[]): Volatility;
  integratedVariance(i: Size, j: Size, u: Time, x?: Real[]): Real;
  private _fixingTimes;
}

export declare class LmVolatilityModel {
  constructor(size: Size, nArguments: Size);
  size(): Size;
  params(): Parameter[];
  setParams(args: Parameter[]): void;
  volatility1(t: Time, x?: Real[]): Real[];
  volatility2(i: Size, t: Time, x?: Real[]): Volatility;
  integratedVariance(i: Size, j: Size, u: Time, x?: Real[]): Real;
  protected _size: Size;
  protected _arguments: Parameter[];
  private generateArguments;
}

export declare class AmericanPayoffAtExpiry {
  constructor(
      spot: Real, discount: DiscountFactor, dividendDiscount: DiscountFactor,
      variance: Real, payoff: StrikedTypePayoff, knock_in?: boolean);
  value(): Real;
  private _spot;
  private _discount;
  private _dividendDiscount;
  private _variance;
  private _forward;
  private _stdDev;
  private _strike;
  private _K;
  private _mu;
  private _log_H_S;
  private _D1;
  private _D2;
  private _cum_d1;
  private _cum_d2;
  _n_d1: Real;
  _n_d2: Real;
  private _inTheMoney;
  private _Y;
  private _X;
  private _knock_in;
}

export declare class AmericanPayoffAtHit {
  constructor(
      spot: Real, discount: DiscountFactor, dividendDiscount: DiscountFactor,
      variance: Real, payoff: StrikedTypePayoff);
  value(): Real;
  delta(): Real;
  gamma(): Real;
  rho(maturity: Time): Real;
  private _spot;
  private _discount;
  private _dividendDiscount;
  private _variance;
  private _stdDev;
  private _strike;
  private _K;
  _DKDstrike: Real;
  private _mu;
  private _lambda;
  private _muPlusLambda;
  private _muMinusLambda;
  private _log_H_S;
  private _D1;
  private _D2;
  private _cum_d1;
  private _cum_d2;
  private _alpha;
  private _beta;
  private _DalphaDd1;
  private _DbetaDd2;
  private _inTheMoney;
  private _forward;
  private _X;
  _DXDstrike: Real;
}

export declare class BlackCalculator {
  init1(
      payoff: StrikedTypePayoff, forward: Real, stdDev: Real,
      discount?: Real): BlackCalculator;
  init2(
      optionType: Option.Type, strike: Real, forward: Real, stdDev: Real,
      discount?: Real): BlackCalculator;
  value(): Real;
  deltaForward(): Real;
  delta(spot: Real): Real;
  elasticityForward(): Real;
  elasticity(spot: Real): Real;
  gammaForward(): Real;
  gamma(spot: Real): Real;
  theta(spot: Real, maturity: Time): Real;
  thetaPerDay(spot: Real, maturity: Time): Real;
  vega(maturity: Time): Real;
  rho(maturity: Time): Real;
  dividendRho(maturity: Time): Real;
  itmCashProbability(): Real;
  itmAssetProbability(): Real;
  strikeSensitivity(): Real;
  alpha(): Real;
  beta(): Real;
  protected initialize(p: StrikedTypePayoff): void;
  _strike: Real;
  _forward: Real;
  _stdDev: Real;
  _discount: Real;
  _variance: Real;
  _d1: Real;
  _d2: Real;
  _alpha: Real;
  _beta: Real;
  _DalphaDd1: Real;
  _DbetaDd2: Real;
  _n_d1: Real;
  _cum_d1: Real;
  _n_d2: Real;
  _cum_d2: Real;
  _x: Real;
  _DxDs: Real;
  _DxDstrike: Real;
}
export declare namespace BlackCalculator {
  class Calculator {
    constructor(black: BlackCalculator);
    visit(payoff: any): void;
    private _black;
  }
}

export declare function blackFormula1(
    optionType: Option.Type, strike: Real, forward: Real, stdDev: Real,
    discount?: Real, displacement?: Real): Real;
export declare function blackFormula2(
    payoff: PlainVanillaPayoff, forward: Real, stdDev: Real, discount?: Real,
    displacement?: Real): Real;
export declare function blackFormulaImpliedStdDevApproximation1(
    optionType: Option.Type, strike: Real, forward: Real, blackPrice: Real,
    discount?: Real, displacement?: Real): Real;
export declare function blackFormulaImpliedStdDevApproximation2(
    payoff: PlainVanillaPayoff, forward: Real, blackPrice: Real,
    discount?: Real, displacement?: Real): Real;
export declare function blackFormulaImpliedStdDevChambers1(
    optionType: Option.Type, strike: Real, forward: Real, blackPrice: Real,
    blackAtmPrice: Real, discount?: Real, displacement?: Real): Real;
export declare function blackFormulaImpliedStdDevChambers2(
    payoff: PlainVanillaPayoff, forward: Real, blackPrice: Real,
    blackAtmPrice: Real, discount?: Real, displacement?: Real): Real;
export declare function blackFormulaImpliedStdDevApproximationRS1(
    type: Option.Type, K: Real, F: Real, marketValue: Real, df?: Real,
    displacement?: Real): Real;
export declare function blackFormulaImpliedStdDevApproximationRS2(
    payoff: PlainVanillaPayoff, F: Real, marketValue: Real, df?: Real,
    displacement?: Real): Real;
export declare function blackFormulaImpliedStdDev1(
    optionType: Option.Type, strike: Real, forward: Real, blackPrice: Real,
    discount?: Real, displacement?: Real, guess?: Real, accuracy?: Real,
    maxIterations?: Natural): Real;
export declare function blackFormulaImpliedStdDev2(
    payoff: PlainVanillaPayoff, forward: Real, blackPrice: Real,
    discount?: Real, displacement?: Real, guess?: Real, accuracy?: Real,
    maxIterations?: Natural): Real;
export declare function blackFormulaImpliedStdDevLiRS1(
    optionType: Option.Type, strike: Real, forward: Real, blackPrice: Real,
    discount?: Real, displacement?: Real, guess?: Real, w?: Real,
    accuracy?: Real, maxIterations?: Natural): Real;
export declare function blackFormulaImpliedStdDevLiRS2(
    payoff: PlainVanillaPayoff, forward: Real, blackPrice: Real,
    discount?: Real, displacement?: Real, guess?: Real, omega?: Real,
    accuracy?: Real, maxIterations?: Natural): Real;
export declare function blackFormulaCashItmProbability1(
    optionType: Option.Type, strike: Real, forward: Real, stdDev: Real,
    displacement?: Real): Real;
export declare function blackFormulaCashItmProbability2(
    payoff: PlainVanillaPayoff, forward: Real, stdDev: Real,
    displacement?: Real): Real;
export declare function blackFormulaStdDevDerivative1(
    strike: Real, forward: Real, stdDev: Real, discount?: Real,
    displacement?: Real): Real;
export declare function blackFormulaStdDevDerivative2(
    payoff: PlainVanillaPayoff, forward: Real, stdDev: Real, discount?: Real,
    displacement?: Real): Real;
export declare function blackFormulaVolDerivative(
    strike: Real, forward: Real, stdDev: Real, expiry: Real, discount?: Real,
    displacement?: Real): Real;
export declare function blackFormulaStdDevSecondDerivative1(
    strike: Real, forward: Real, stdDev: Real, discount?: Real,
    displacement?: Real): Real;
export declare function blackFormulaStdDevSecondDerivative2(
    payoff: PlainVanillaPayoff, forward: Real, stdDev: Real, discount?: Real,
    displacement?: Real): Real;
export declare function bachelierBlackFormula1(
    optionType: Option.Type, strike: Real, forward: Real, stdDev: Real,
    discount?: Real): Real;
export declare function bachelierBlackFormula2(
    payoff: PlainVanillaPayoff, forward: Real, stdDev: Real,
    discount?: Real): Real;
export declare function bachelierBlackFormulaImpliedVol(
    optionType: Option.Type, strike: Real, forward: Real, tte: Real,
    bachelierPrice: Real, discount?: Real): Real;
export declare function bachelierBlackFormulaStdDevDerivative1(
    strike: Real, forward: Real, stdDev: Real, discount?: Real): Real;
export declare function bachelierBlackFormulaStdDevDerivative2(
    payoff: PlainVanillaPayoff, forward: Real, stdDev: Real,
    discount?: Real): Real;

export declare class BlackScholesCalculator extends BlackCalculator {
  bscInit1(
      payoff: StrikedTypePayoff, spot: Real, growth: DiscountFactor,
      stdDev: Real, discount: DiscountFactor): BlackScholesCalculator;
  bscInit2(
      type: Option.Type, strike: Real, spot: Real, growth: DiscountFactor,
      stdDev: Real, discount: DiscountFactor): BlackScholesCalculator;
  delta(): Real;
  elasticity(): Real;
  gamma(): Real;
  theta(maturity: Time): Real;
  thetaPerDay(maturity: Time): Real;
  protected _spot: Real;
  protected _growth: DiscountFactor;
}

export declare class GenericModelEngine<
    ModelType extends Observable, ArgumentsType extends
        PricingEngine.Arguments, ResultsType extends PricingEngine.Results>
    extends GenericEngine<ArgumentsType, ResultsType> {
  init1(model?: Handle<ModelType>):
      GenericModelEngine<ModelType, ArgumentsType, ResultsType>;
  init2(model: ModelType):
      GenericModelEngine<ModelType, ArgumentsType, ResultsType>;
  _model: Handle<ModelType>;
}

export declare function blackScholesTheta(
    p: GeneralizedBlackScholesProcess, value: Real, delta: Real,
    gamma: Real): Real;
export declare function defaultThetaPerDay(theta: Real): Real;

export declare class LatticeShortRateModelEngine<
    ArgumentsType extends PricingEngine.Arguments,
                          ResultsType extends PricingEngine.Results> extends
    GenericModelEngine<ShortRateModel, ArgumentsType, ResultsType> {
  lsrmeInit1(model: ShortRateModel, timeSteps: Size):
      LatticeShortRateModelEngine<ArgumentsType, ResultsType>;
  lsrmeInit2(model: Handle<ShortRateModel>, timeSteps: Size):
      LatticeShortRateModelEngine<ArgumentsType, ResultsType>;
  lsrmeInit3(model: ShortRateModel, timeGrid: TimeGrid):
      LatticeShortRateModelEngine<ArgumentsType, ResultsType>;
  update(): void;
  protected _timeGrid: TimeGrid;
  protected _timeSteps: Size;
  protected _lattice: Lattice;
}

export declare class MCLongstaffSchwartzEngine extends
    GenericEngineMcSimulation {
  constructor(
      GenericEngine: PricingEngine, MC: MonteCarloModel.mc_traits,
      RNG: MonteCarloModel.rng_traits, S?: any,
      RNG_Calibration?: MonteCarloModel.rng_traits);
  mclseInit(
      process: StochasticProcess, timeSteps: Size, timeStepsPerYear: Size,
      brownianBridge: boolean, antitheticVariate: boolean,
      controlVariate: boolean, requiredSamples: Size, requiredTolerance: Real,
      maxSamples: Size, seed: BigNatural, nCalibrationSamples?: Size,
      brownianBridgeCalibration?: boolean,
      antitheticVariateCalibration?: boolean,
      seedCalibration?: BigNatural): MCLongstaffSchwartzEngine;
  pathPricer(): PathPricer<Path>;
  pathGenerator(): PathGenerator|MultiPathGenerator;
  calculate(): void;
  timeGrid(): TimeGrid;
  lsmPathPricer(): LongstaffSchwartzPathPricer<Path|MultiPath>;
  MC: MonteCarloModel.mc_traits;
  RNG: MonteCarloModel.rng_traits;
  S: any;
  RNG_Calibration: MonteCarloModel.rng_traits;
  _process: StochasticProcess;
  _timeSteps: Size;
  _timeStepsPerYear: Size;
  _brownianBridge: boolean;
  _requiredSamples: Size;
  _requiredTolerance: Real;
  _maxSamples: Size;
  _seed: BigNatural;
  _nCalibrationSamples: Size;
  _brownianBridgeCalibration: boolean;
  _antitheticVariateCalibration: boolean;
  _seedCalibration: BigNatural;
  _pathPricer: LongstaffSchwartzPathPricer<Path|MultiPath>;
  _mcModelCalibration: MonteCarloModel;
}

export declare class McSimulation {
  constructor(
      MC: MonteCarloModel.mc_traits, RNG: MonteCarloModel.rng_traits, S?: any);
  mcsInit(antitheticVariate: boolean, controlVariate: boolean): McSimulation;
  value(tolerance: Real, maxSamples?: Size, minSamples?: Size): Real;
  valueWithSamples(samples: Size): Real;
  errorEstimate(): Real;
  sampleAccumulator(): RiskStatistics;
  calculate1(requiredTolerance: Real, requiredSamples: Size, maxSamples: Size):
      void;
  pathPricer(): PathPricer<Path|MultiPath>;
  pathGenerator(): PathGenerator|MultiPathGenerator;
  timeGrid(): TimeGrid;
  controlPathPricer(): PathPricer<Path|MultiPath>;
  controlPathGenerator(): PathGenerator;
  controlPricingEngine(): PricingEngine;
  controlVariateValue(): Real;
  static maxError1(sequence: Real[]): Real;
  static maxError2(error: Real): Real;
  MC: MonteCarloModel.mc_traits;
  RNG: MonteCarloModel.rng_traits;
  S: any;
  _mcModel: MonteCarloModel;
  _antitheticVariate: boolean;
  _controlVariate: boolean;
}

export declare class AnalyticContinuousGeometricAveragePriceAsianEngine extends
    ContinuousAveragingAsianOption.engine {
  constructor(process: GeneralizedBlackScholesProcess);
  calculate(): void;
  private _process;
}

export declare class AnalyticDiscreteGeometricAveragePriceAsianEngine extends
    DiscreteAveragingAsianOption.engine {
  constructor(process: GeneralizedBlackScholesProcess);
  calculate(): void;
  private _process;
}

export declare class AnalyticDiscreteGeometricAverageStrikeAsianEngine extends
    DiscreteAveragingAsianOption.engine {
  constructor(process: GeneralizedBlackScholesProcess);
  calculate(): void;
  private _process;
}

export declare class FdBlackScholesAsianEngine extends GenericEngine<
    DiscreteAveragingAsianOption.Arguments,
    DiscreteAveragingAsianOption.Results> {
  constructor(
      process: GeneralizedBlackScholesProcess, tGrid?: Size, xGrid?: Size,
      aGrid?: Size, schemeDesc?: FdmSchemeDesc);
  calculate(): void;
  private _process;
  private _tGrid;
  private _xGrid;
  private _aGrid;
  private _schemeDesc;
}

export declare class MCDiscreteAveragingAsianEngine extends
    DiscreteAveragingAsianOptionEngineMcSimulation {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  mcdaaeInit(
      process: GeneralizedBlackScholesProcess, brownianBridge: boolean,
      antitheticVariate: boolean, controlVariate: boolean,
      requiredSamples: Size, requiredTolerance: Real, maxSamples: Size,
      seed: BigNatural): MCDiscreteAveragingAsianEngine;
  calculate(): void;
  timeGrid(): TimeGrid;
  pathGenerator(): PathGenerator;
  controlVariateValue(): Real;
  protected _process: GeneralizedBlackScholesProcess;
  protected _requiredSamples: Size;
  protected _maxSamples: Size;
  protected _requiredTolerance: Real;
  protected _brownianBridge: boolean;
  protected _seed: BigNatural;
}

export declare class MCDiscreteArithmeticAPEngine extends
    MCDiscreteAveragingAsianEngine {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  mcdaapeInit(
      process: GeneralizedBlackScholesProcess, brownianBridge: boolean,
      antitheticVariate: boolean, controlVariate: boolean,
      requiredSamples: Size, requiredTolerance: Real, maxSamples: Size,
      seed: BigNatural): MCDiscreteArithmeticAPEngine;
  pathPricer(): PathPricer<Path>;
  controlPathPricer(): PathPricer<Path>;
  controlPricingEngine(): PricingEngine;
}
export declare class ArithmeticAPOPathPricer extends PathPricer<Path> {
  constructor(
      type: Option.Type, strike: Real, discount: DiscountFactor,
      runningSum?: Real, pastFixings?: Size);
  f(path: Path): Real;
  private _payoff;
  private _discount;
  private _runningSum;
  private _pastFixings;
}
export declare class MakeMCDiscreteArithmeticAPEngine implements
    NullaryFunction<PricingEngine> {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  init(process: GeneralizedBlackScholesProcess):
      MakeMCDiscreteArithmeticAPEngine;
  withBrownianBridge(b?: boolean): MakeMCDiscreteArithmeticAPEngine;
  withSamples(samples: Size): MakeMCDiscreteArithmeticAPEngine;
  withAbsoluteTolerance(tolerance: Real): MakeMCDiscreteArithmeticAPEngine;
  withMaxSamples(samples: Size): MakeMCDiscreteArithmeticAPEngine;
  withSeed(seed: BigNatural): MakeMCDiscreteArithmeticAPEngine;
  withAntitheticVariate(b?: boolean): MakeMCDiscreteArithmeticAPEngine;
  withControlVariate(b?: boolean): MakeMCDiscreteArithmeticAPEngine;
  f(): PricingEngine;
  RNG: MonteCarloModel.rng_traits;
  S: any;
  private _process;
  private _antithetic;
  private _controlVariate;
  private _samples;
  private _maxSamples;
  private _tolerance;
  private _brownianBridge;
  private _seed;
}

export declare class MCDiscreteArithmeticASEngine extends
    MCDiscreteAveragingAsianEngine {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  mcdaaseInit(
      process: GeneralizedBlackScholesProcess, brownianBridge: boolean,
      antitheticVariate: boolean, requiredSamples: Size,
      requiredTolerance: Real, maxSamples: Size,
      seed: BigNatural): MCDiscreteArithmeticASEngine;
  pathPricer(): PathPricer<Path>;
}
export declare class ArithmeticASOPathPricer extends PathPricer<Path> {
  constructor(
      type: Option.Type, discount: DiscountFactor, runningSum?: Real,
      pastFixings?: Size);
  f(path: Path): Real;
  private _type;
  private _discount;
  private _runningSum;
  private _pastFixings;
}
export declare class MakeMCDiscreteArithmeticASEngine implements
    NullaryFunction<PricingEngine> {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  init(process: GeneralizedBlackScholesProcess):
      MakeMCDiscreteArithmeticASEngine;
  withBrownianBridge(b?: boolean): MakeMCDiscreteArithmeticASEngine;
  withSamples(samples: Size): MakeMCDiscreteArithmeticASEngine;
  withAbsoluteTolerance(tolerance: Real): MakeMCDiscreteArithmeticASEngine;
  withMaxSamples(samples: Size): MakeMCDiscreteArithmeticASEngine;
  withSeed(seed: BigNatural): MakeMCDiscreteArithmeticASEngine;
  withAntitheticVariate(b?: boolean): MakeMCDiscreteArithmeticASEngine;
  f(): PricingEngine;
  RNG: MonteCarloModel.rng_traits;
  S: any;
  private _process;
  private _antithetic;
  private _samples;
  private _maxSamples;
  private _tolerance;
  private _brownianBridge;
  private _seed;
}

export declare class MCDiscreteGeometricAPEngine extends
    MCDiscreteAveragingAsianEngine {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  mcdgapeInit(
      process: GeneralizedBlackScholesProcess, brownianBridge: boolean,
      antitheticVariate: boolean, requiredSamples: Size,
      requiredTolerance: Real, maxSamples: Size,
      seed: BigNatural): MCDiscreteGeometricAPEngine;
  pathPricer(): PathPricer<Path>;
}
export declare class GeometricAPOPathPricer extends PathPricer<Path> {
  constructor(
      type: Option.Type, strike: Real, discount: DiscountFactor,
      runningProduct?: Real, pastFixings?: Size);
  f(path: Path): Real;
  private _payoff;
  private _discount;
  private _runningProduct;
  private _pastFixings;
}
export declare class MakeMCDiscreteGeometricAPEngine implements
    NullaryFunction<PricingEngine> {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  init(process: GeneralizedBlackScholesProcess):
      MakeMCDiscreteGeometricAPEngine;
  withBrownianBridge(b?: boolean): MakeMCDiscreteGeometricAPEngine;
  withSamples(samples: Size): MakeMCDiscreteGeometricAPEngine;
  withAbsoluteTolerance(tolerance: Real): MakeMCDiscreteGeometricAPEngine;
  withMaxSamples(samples: Size): MakeMCDiscreteGeometricAPEngine;
  withSeed(seed: BigNatural): MakeMCDiscreteGeometricAPEngine;
  withAntitheticVariate(b?: boolean): MakeMCDiscreteGeometricAPEngine;
  f(): PricingEngine;
  RNG: MonteCarloModel.rng_traits;
  S: any;
  private _process;
  private _antithetic;
  private _samples;
  private _maxSamples;
  private _tolerance;
  private _brownianBridge;
  private _seed;
}

export declare class AnalyticBarrierEngine extends BarrierOptionEngine.engine {
  init1: (process: GeneralizedBlackScholesProcess) => AnalyticBarrierEngine;
  calculate(): void;
  private underlying;
  private strike;
  private residualTime;
  private volatility;
  private barrier;
  private rebate;
  private stdDeviation;
  private riskFreeRate;
  private riskFreeDiscount;
  private dividendYield;
  private dividendDiscount;
  private mu;
  private muSigma;
  private A;
  private B;
  private C;
  private D;
  private E;
  private F;
  private _process;
  private _f;
}

export declare class AnalyticBinaryBarrierEngine extends
    BarrierOptionEngine.engine {
  constructor(process: GeneralizedBlackScholesProcess);
  calculate(): void;
  private _process;
}

export declare class BinomialBarrierEngine extends BarrierOptionEngine.engine {
  constructor(T: TreeLatticeImpl, D: DiscretizedAsset);
  init(
      process: GeneralizedBlackScholesProcess, timeSteps: Size,
      maxTimeSteps?: Size): BinomialBarrierEngine;
  calculate(): void;
  T: TreeLatticeImpl;
  D: DiscretizedAsset;
  private _process;
  private _timeSteps;
  private _maxTimeSteps;
}

export declare class DiscretizedBarrierOption extends DiscretizedAsset {
  init(
      args: BarrierOptionEngine.Arguments, process: StochasticProcess,
      grid?: TimeGrid): DiscretizedBarrierOption;
  reset(size: Size): void;
  vanilla(): Real[];
  arguments(): BarrierOptionEngine.Arguments;
  mandatoryTimes(): Time[];
  checkBarrier(optvalues: Real[], grid: Real[]): void;
  postAdjustValuesImpl(): void;
  private _arguments;
  private _stoppingTimes;
  private _vanilla;
}
export declare class DiscretizedDermanKaniBarrierOption extends
    DiscretizedAsset {
  init(
      args: BarrierOptionEngine.Arguments, process: StochasticProcess,
      grid?: TimeGrid): DiscretizedDermanKaniBarrierOption;
  reset(size: Size): void;
  mandatoryTimes(): Time[];
  postAdjustValuesImpl(): void;
  private adjustBarrier;
  private _unenhanced;
}

export declare class FdBlackScholesBarrierEngine extends
    DividendBarrierOption.engine {
  constructor(
      process: GeneralizedBlackScholesProcess, tGrid?: Size, xGrid?: Size,
      dampingSteps?: Size, schemeDesc?: FdmSchemeDesc, localVol?: boolean,
      illegalLocalVolOverwrite?: Real);
  calculate(): void;
  private _process;
  private _tGrid;
  private _xGrid;
  private _dampingSteps;
  private _schemeDesc;
  private _localVol;
  private _illegalLocalVolOverwrite;
}

export declare class FdBlackScholesRebateEngine extends
    DividendBarrierOption.engine {
  constructor(
      process: GeneralizedBlackScholesProcess, tGrid?: Size, xGrid?: Size,
      dampingSteps?: Size, schemeDesc?: FdmSchemeDesc, localVol?: boolean,
      illegalLocalVolOverwrite?: Real);
  calculate(): void;
  private _process;
  private _tGrid;
  private _xGrid;
  private _dampingSteps;
  private _schemeDesc;
  private _localVol;
  private _illegalLocalVolOverwrite;
}

export declare class FdHestonBarrierEngine extends GenericModelEngine<
    HestonModel, DividendBarrierOption.Arguments,
    DividendBarrierOption.Results> {
  constructor(
      model: HestonModel, tGrid?: number, xGrid?: number, vGrid?: number,
      dampingSteps?: number, schemeDesc?: FdmSchemeDesc,
      leverageFct?: LocalVolTermStructure);
  calculate(): void;
  private _tGrid;
  private _xGrid;
  private _vGrid;
  private _dampingSteps;
  private _schemeDesc;
  private _leverageFct;
}

export declare class FdHestonRebateEngine extends GenericModelEngine<
    HestonModel, DividendBarrierOption.Arguments,
    DividendBarrierOption.Results> {
  constructor(
      model: HestonModel, tGrid?: number, xGrid?: number, vGrid?: number,
      dampingSteps?: number, schemeDesc?: FdmSchemeDesc,
      leverageFct?: LocalVolTermStructure);
  calculate(): void;
  private _tGrid;
  private _xGrid;
  private _vGrid;
  private _dampingSteps;
  private _schemeDesc;
  private _leverageFct;
}

export declare class MCBarrierEngine extends BarrierOptionEngineMcSimulation {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  mcbeInit(
      process: GeneralizedBlackScholesProcess, timeSteps: Size,
      timeStepsPerYear: Size, brownianBridge: boolean,
      antitheticVariate: boolean, requiredSamples: Size,
      requiredTolerance: Real, maxSamples: Size, isBiased: boolean,
      seed: BigNatural): MCBarrierEngine;
  calculate(): void;
  pathGenerator(): PathGenerator;
  timeGrid(): TimeGrid;
  pathPricer(): PathPricer<Path>;
  protected _process: GeneralizedBlackScholesProcess;
  protected _timeSteps: Size;
  protected _timeStepsPerYear: Size;
  protected _requiredSamples: Size;
  protected _maxSamples: Size;
  protected _requiredTolerance: Real;
  protected _isBiased: boolean;
  protected _brownianBridge: boolean;
  protected _seed: BigNatural;
}
export declare class MakeMCBarrierEngine implements
    NullaryFunction<PricingEngine> {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  init(process: GeneralizedBlackScholesProcess): MakeMCBarrierEngine;
  withSteps(steps: Size): MakeMCBarrierEngine;
  withStepsPerYear(steps: Size): MakeMCBarrierEngine;
  withBrownianBridge(b?: boolean): MakeMCBarrierEngine;
  withAntitheticVariate(b?: boolean): MakeMCBarrierEngine;
  withSamples(samples: Size): MakeMCBarrierEngine;
  withAbsoluteTolerance(tolerance: Real): MakeMCBarrierEngine;
  withMaxSamples(samples: Size): MakeMCBarrierEngine;
  withBias(flag?: boolean): MakeMCBarrierEngine;
  withSeed(seed: BigNatural): MakeMCBarrierEngine;
  f(): PricingEngine;
  RNG: MonteCarloModel.rng_traits;
  S: any;
  private _process;
  private _brownianBridge;
  private _antithetic;
  private _biased;
  private _steps;
  private _stepsPerYear;
  private _samples;
  private _maxSamples;
  private _tolerance;
  private _seed;
}
export declare class BarrierPathPricer extends PathPricer<Path> {
  constructor(
      barrierType: Barrier.Type, barrier: Real, rebate: Real, type: Option.Type,
      strike: Real, discounts: DiscountFactor[],
      diffProcess: StochasticProcess1D, sequenceGen: PseudoRandom.ursg_type);
  f(path: Path): Real;
  private _barrierType;
  private _barrier;
  private _rebate;
  private _diffProcess;
  private _sequenceGen;
  private _payoff;
  private _discounts;
}
export declare class BiasedBarrierPathPricer extends PathPricer<Path> {
  constructor(
      barrierType: Barrier.Type, barrier: Real, rebate: Real, type: Option.Type,
      strike: Real, discounts: DiscountFactor[]);
  f(path: Path): Real;
  private _barrierType;
  private _barrier;
  private _rebate;
  private _payoff;
  private _discounts;
}

export declare class Fd2dBlackScholesVanillaEngine extends BasketOption.engine {
  constructor(
      p1: GeneralizedBlackScholesProcess, p2: GeneralizedBlackScholesProcess,
      correlation: Real, xGrid?: Size, yGrid?: Size, tGrid?: Size,
      dampingSteps?: Size, schemeDesc?: FdmSchemeDesc, localVol?: boolean,
      illegalLocalVolOverwrite?: Real);
  calculate(): void;
  private _p1;
  private _p2;
  private _correlation;
  private _xGrid;
  private _yGrid;
  private _tGrid;
  private _dampingSteps;
  private _schemeDesc;
  private _localVol;
  private _illegalLocalVolOverwrite;
}

export declare class KirkEngine extends BasketOption.engine {
  constructor(
      process1: GeneralizedBlackScholesProcess,
      process2: GeneralizedBlackScholesProcess, correlation: Real);
  calculate(): void;
  private _process1;
  private _process2;
  private _rho;
}

export declare class MCAmericanBasketEngine extends MCLongstaffSchwartzEngine {
  constructor(RNG?: MonteCarloModel.rng_traits);
  mcabeInit(
      processes: StochasticProcessArray, timeSteps: Size,
      timeStepsPerYear: Size, brownianBridge: boolean,
      antitheticVariate: boolean, requiredSamples: Size,
      requiredTolerance: Real, maxSamples: Size, seed: BigNatural,
      nCalibrationSamples?: Size): MCAmericanBasketEngine;
  lsmPathPricer(): LongstaffSchwartzPathPricer<MultiPath>;
}
export declare class MakeMCAmericanBasketEngine implements
    NullaryFunction<PricingEngine> {
  constructor(RNG?: MonteCarloModel.rng_traits);
  mmcabeInit(process: StochasticProcessArray): MakeMCAmericanBasketEngine;
  withSteps(steps: Size): MakeMCAmericanBasketEngine;
  withStepsPerYear(steps: Size): MakeMCAmericanBasketEngine;
  withBrownianBridge(b?: boolean): MakeMCAmericanBasketEngine;
  withAntitheticVariate(b?: boolean): MakeMCAmericanBasketEngine;
  withSamples(samples: Size): MakeMCAmericanBasketEngine;
  withAbsoluteTolerance(tolerance: Real): MakeMCAmericanBasketEngine;
  withMaxSamples(samples: Size): MakeMCAmericanBasketEngine;
  withSeed(seed: BigNatural): MakeMCAmericanBasketEngine;
  withCalibrationSamples(samples: Size): MakeMCAmericanBasketEngine;
  f(): MCAmericanBasketEngine;
  RNG: MonteCarloModel.rng_traits;
  private _process;
  private _brownianBridge;
  private _antithetic;
  private _steps;
  private _stepsPerYear;
  private _samples;
  private _maxSamples;
  private _calibrationSamples;
  private _tolerance;
  private _seed;
}
export declare class AmericanBasketPathPricer extends
    EarlyExercisePathPricer<MultiPath> {
  constructor(
      assetNumber: Size, payoff: Payoff, polynomOrder?: Size,
      polynomType?: LsmBasisSystem.PolynomType);
  state(path: MultiPath, t: Size): Real[];
  f(path: MultiPath, t: Size): Real;
  basisSystem(): Array<UnaryFunction<Real[], Real>>;
  protected payoff(state: Real[]): Real;
  protected _assetNumber: Size;
  protected _payoff: Payoff;
  protected _scalingValue: Real;
  protected _v: Array<UnaryFunction<Real[], Real>>;
}

export declare class MCEuropeanBasketEngine extends
    BasketOptionEngineMcSimulation {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  mcebeInit(
      processes: StochasticProcessArray, timeSteps: Size,
      timeStepsPerYear: Size, brownianBridge: boolean,
      antitheticVariate: boolean, requiredSamples: Size,
      requiredTolerance: Real, maxSamples: Size,
      seed: BigNatural): MCEuropeanBasketEngine;
  calculate(): void;
  timeGrid(): TimeGrid;
  pathGenerator(): MultiPathGenerator;
  pathPricer(): PathPricer<MultiPath>;
  protected _processes: StochasticProcessArray;
  protected _timeSteps: Size;
  protected _timeStepsPerYear: Size;
  protected _requiredSamples: Size;
  protected _maxSamples: Size;
  protected _requiredTolerance: Real;
  protected _brownianBridge: boolean;
  protected _seed: BigNatural;
}
export declare class MakeMCEuropeanBasketEngine implements
    NullaryFunction<PricingEngine> {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  mmcebeInit(process: StochasticProcessArray): MakeMCEuropeanBasketEngine;
  withSteps(steps: Size): MakeMCEuropeanBasketEngine;
  withStepsPerYear(steps: Size): MakeMCEuropeanBasketEngine;
  withBrownianBridge(b?: boolean): MakeMCEuropeanBasketEngine;
  withAntitheticVariate(b?: boolean): MakeMCEuropeanBasketEngine;
  withSamples(samples: Size): MakeMCEuropeanBasketEngine;
  withAbsoluteTolerance(tolerance: Real): MakeMCEuropeanBasketEngine;
  withMaxSamples(samples: Size): MakeMCEuropeanBasketEngine;
  withSeed(seed: BigNatural): MakeMCEuropeanBasketEngine;
  f(): PricingEngine;
  RNG: MonteCarloModel.rng_traits;
  S: any;
  private _process;
  private _brownianBridge;
  private _antithetic;
  private _steps;
  private _stepsPerYear;
  private _samples;
  private _maxSamples;
  private _tolerance;
  private _seed;
}
export declare class EuropeanMultiPathPricer extends PathPricer<MultiPath> {
  constructor(payoff: BasketPayoff, discount: DiscountFactor);
  f(multiPath: MultiPath): Real;
  private _payoff;
  private _discount;
}

export declare class StulzEngine extends BasketOption.engine {
  constructor(
      process1: GeneralizedBlackScholesProcess,
      process2: GeneralizedBlackScholesProcess, correlation: Real);
  calculate(): void;
  private _process1;
  private _process2;
  private _rho;
}

export declare class BondFunctions {
  static startDate(bond: Bond): Date;
  static maturityDate(bond: Bond): Date;
  static isTradable(bond: Bond, settlementDate?: Date): boolean;
  static previousCashFlow1(bond: Bond, settlementDate?: Date): CashFlow;
  static previousCashFlow2(bond: Bond, settlementDate?: Date): Size;
  static nextCashFlow1(bond: Bond, settlementDate?: Date): CashFlow;
  static nextCashFlow2(bond: Bond, settlementDate?: Date): Size;
  static previousCashFlowDate(bond: Bond, settlementDate?: Date): Date;
  static nextCashFlowDate(bond: Bond, settlementDate?: Date): Date;
  static previousCashFlowAmount(bond: Bond, settlementDate?: Date): Real;
  static nextCashFlowAmount(bond: Bond, settlementDate?: Date): Real;
  static previousCouponRate(bond: Bond, settlementDate?: Date): Rate;
  static nextCouponRate(bond: Bond, settlementDate?: Date): Rate;
  static accrualStartDate(bond: Bond, settlementDate?: Date): Date;
  static accrualEndDate(bond: Bond, settlementDate?: Date): Date;
  static referencePeriodStart(bond: Bond, settlementDate?: Date): Date;
  static referencePeriodEnd(bond: Bond, settlementDate?: Date): Date;
  static accrualPeriod(bond: Bond, settlementDate?: Date): Time;
  static accrualDays(bond: Bond, settlementDate?: Date): Integer;
  static accruedPeriod(bond: Bond, settlementDate?: Date): Time;
  static accruedDays(bond: Bond, settlementDate?: Date): Integer;
  static accruedAmount(bond: Bond, settlementDate?: Date): Integer;
  static cleanPrice1(
      bond: Bond, discountCurve: YieldTermStructure,
      settlementDate?: Date): Real;
  static bps1(
      bond: Bond, discountCurve: YieldTermStructure,
      settlementDate?: Date): Real;
  static atmRate(
      bond: Bond, discountCurve: YieldTermStructure, settlementDate?: Date,
      cleanPrice?: Real): Rate;
  static cleanPrice2(bond: Bond, y: InterestRate, settlementDate?: Date): Real;
  static cleanPrice3(
      bond: Bond, y: Rate, dc: DayCounter, comp: Compounding, freq: Frequency,
      settlementDate?: Date): Real;
  static dirtyPrice1(bond: Bond, y: InterestRate, settlementDate?: Date): Real;
  static dirtyPrice2(
      bond: Bond, y: Rate, dc: DayCounter, comp: Compounding, freq: Frequency,
      settlement?: Date): Real;
  static bps2(bond: Bond, y: InterestRate, settlement?: Date): Real;
  static bps3(
      bond: Bond, y: Rate, dc: DayCounter, comp: Compounding, freq: Frequency,
      settlement?: Date): Real;
  static yield1(
      bond: Bond, cleanPrice: Real, dc: DayCounter, comp: Compounding,
      freq: Frequency, settlement?: Date, accuracy?: Real, maxIterations?: Size,
      guess?: Rate): Rate;
  static yield2(
      solver: ISolver1D, bond: Bond, cleanPrice: Real, dc: DayCounter,
      comp: Compounding, freq: Frequency, settlementDate?: Date,
      accuracy?: Real, maxIterations?: Size, guess?: Rate): Rate;
  static duration1(
      bond: Bond, y: InterestRate, type?: Duration.Type,
      settlementDate?: Date): Time;
  static duration2(
      bond: Bond, y: Rate, dc: DayCounter, comp: Compounding, freq: Frequency,
      type?: Duration.Type, settlement?: Date): Time;
  static convexity1(bond: Bond, y: InterestRate, settlementDate?: Date): Real;
  static convexity2(
      bond: Bond, y: Rate, dc: DayCounter, comp: Compounding, freq: Frequency,
      settlement?: Date): Real;
  static basisPointValue1(bond: Bond, y: InterestRate, settlementDate?: Date):
      Real;
  static basisPointValue2(
      bond: Bond, y: Rate, dc: DayCounter, comp: Compounding, freq: Frequency,
      settlement?: Date): Real;
  static yieldValueBasisPoint1(
      bond: Bond, y: InterestRate, settlementDate?: Date): Real;
  static yieldValueBasisPoint2(
      bond: Bond, y: Rate, dc: DayCounter, comp: Compounding, freq: Frequency,
      settlement?: Date): Real;
  static cleanPrice4(
      bond: Bond, d: YieldTermStructure, zSpread: Spread, dc: DayCounter,
      comp: Compounding, freq: Frequency, settlementDate?: Date): Real;
  static zSpread(
      bond: Bond, cleanPrice: Real, d: YieldTermStructure, dc: DayCounter,
      comp: Compounding, freq: Frequency, settlement?: Date, accuracy?: Real,
      maxIterations?: Size, guess?: Rate): Real;
}

export declare class DiscountingBondEngine extends Bond.engine {
  constructor(
      discountCurve?: Handle<YieldTermStructure>,
      includeSettlementDateFlows?: boolean);
  calculate(): void;
  discountCurve(): Handle<YieldTermStructure>;
  private _discountCurve;
  private _includeSettlementDateFlows;
}

export declare class AnalyticCapFloorEngine extends GenericModelEngine<
    AffineModel, CapFloorEngine.Arguments, CapFloorEngine.Results> {
  constructor(model: AffineModel, termStructure?: Handle<YieldTermStructure>);
  calculate(): void;
  private _termStructure;
}

export declare class BachelierCapFloorEngine extends CapFloorEngine.engine {
  init1(
      discountCurve: Handle<YieldTermStructure>, vol: Volatility,
      dc?: DayCounter): BachelierCapFloorEngine;
  init2(
      discountCurve: Handle<YieldTermStructure>, vol: Handle<Quote>,
      dc?: DayCounter): BachelierCapFloorEngine;
  init3(
      discountCurve: Handle<YieldTermStructure>,
      vol: Handle<OptionletVolatilityStructure>): BachelierCapFloorEngine;
  calculate(): void;
  termStructure(): Handle<YieldTermStructure>;
  volatility(): Handle<OptionletVolatilityStructure>;
  private _discountCurve;
  private _vol;
}

export declare class BlackCapFloorEngine extends CapFloorEngine.engine {
  init1(
      discountCurve: Handle<YieldTermStructure>, vol: Volatility,
      dc?: DayCounter, displacement?: Real): BlackCapFloorEngine;
  init2(
      discountCurve: Handle<YieldTermStructure>, vol: Handle<Quote>,
      dc?: DayCounter, displacement?: Real): BlackCapFloorEngine;
  init3(
      discountCurve: Handle<YieldTermStructure>,
      vol: Handle<OptionletVolatilityStructure>,
      displacement?: Real): BlackCapFloorEngine;
  calculate(): void;
  termStructure(): Handle<YieldTermStructure>;
  volatility(): Handle<OptionletVolatilityStructure>;
  displacement(): Real;
  private _discountCurve;
  private _vol;
  private _displacement;
}

export declare class DiscretizedCapFloor extends DiscretizedAsset {
  constructor(
      args: CapFloorEngine.Arguments, referenceDate: Date,
      dayCounter: DayCounter);
  reset(size: Size): void;
  mandatoryTimes(): Time[];
  preAdjustValuesImpl(): void;
  postAdjustValuesImpl(): void;
  private _arguments;
  private _startTimes;
  private _endTimes;
}

export declare class Gaussian1dCapFloorEngine extends GenericModelEngine<
    Gaussian1dModel, CapFloorEngine.Arguments, CapFloorEngine.Results> {
  constructor(
      model: Gaussian1dModel, integrationPoints?: Integer, stddevs?: Real,
      extrapolatePayoff?: boolean, flatPayoffExtrapolation?: boolean,
      discountCurve?: Handle<YieldTermStructure>);
  calculate(): void;
  private _integrationPoints;
  private _stddevs;
  private _extrapolatePayoff;
  private _flatPayoffExtrapolation;
  private _discountCurve;
}

export declare class MCHullWhiteCapFloorEngine extends
    CapFloorEngineMcSimulation {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  mchwcfeInit(
      model: HullWhite, brownianBridge: boolean, antitheticVariate: boolean,
      requiredSamples: Size, requiredTolerance: Real, maxSamples: Size,
      seed: BigNatural): MCHullWhiteCapFloorEngine;
  calculate(): void;
  pathPricer(): PathPricer<Path>;
  timeGrid(): TimeGrid;
  pathGenerator(): PathGenerator;
  protected _model: HullWhite;
  protected _requiredSamples: Size;
  protected _maxSamples: Size;
  protected _requiredTolerance: Real;
  protected _brownianBridge: boolean;
  protected _seed: BigNatural;
}
export declare class MakeMCHullWhiteCapFloorEngine implements
    NullaryFunction<PricingEngine> {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  mmchwcfeInit(model: HullWhite): MakeMCHullWhiteCapFloorEngine;
  withBrownianBridge(b?: boolean): MakeMCHullWhiteCapFloorEngine;
  withSamples(samples: Size): MakeMCHullWhiteCapFloorEngine;
  withAbsoluteTolerance(tolerance: Real): MakeMCHullWhiteCapFloorEngine;
  withMaxSamples(samples: Size): MakeMCHullWhiteCapFloorEngine;
  withSeed(seed: BigNatural): MakeMCHullWhiteCapFloorEngine;
  withAntitheticVariate(b?: boolean): MakeMCHullWhiteCapFloorEngine;
  f(): PricingEngine;
  RNG: MonteCarloModel.rng_traits;
  S: any;
  private _model;
  private _antithetic;
  private _samples;
  private _maxSamples;
  private _tolerance;
  private _brownianBridge;
  private _seed;
}
export declare class HullWhiteCapFloorPricer extends PathPricer<Path> {
  constructor(
      args: CapFloorEngine.Arguments, model: HullWhite,
      forwardMeasureTime: Time);
  f(path: Path): Real;
  private _args;
  private _model;
  private _forwardMeasureTime;
  private _endDiscount;
  private _startTimes;
  private _endTimes;
  private _fixingTimes;
}

export declare class TreeCapFloorEngine extends LatticeShortRateModelEngine<
    CapFloorEngine.Arguments, CapFloorEngine.Results> {
  tcfeInit1(
      model: ShortRateModel, timeSteps: Size,
      termStructure?: Handle<YieldTermStructure>): TreeCapFloorEngine;
  tcfeInit2(
      model: ShortRateModel, timeGrid: TimeGrid,
      termStructure?: Handle<YieldTermStructure>): TreeCapFloorEngine;
  calculate(): void;
  private _termStructure;
}

export declare class AnalyticCliquetEngine extends CliquetOption.engine {
  constructor(process?: GeneralizedBlackScholesProcess);
  init(process?: GeneralizedBlackScholesProcess): this;
  calculate(): void;
  private _process;
}

export declare class AnalyticPerformanceEngine extends CliquetOption.engine {
  constructor(process?: GeneralizedBlackScholesProcess);
  init(process?: GeneralizedBlackScholesProcess): this;
  calculate(): void;
  private _process;
}

export declare class MCPerformanceEngine extends
    CliquetOptionEngineMcSimulation {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  mcpeInit(
      process: GeneralizedBlackScholesProcess, brownianBridge: boolean,
      antitheticVariate: boolean, requiredSamples: Size,
      requiredTolerance: Real, maxSamples: Size,
      seed: BigNatural): MCPerformanceEngine;
  calculate(): void;
  timeGrid(): TimeGrid;
  pathGenerator(): PathGenerator;
  pathPricer(): PathPricer;
  protected _process: GeneralizedBlackScholesProcess;
  protected _requiredSamples: Size;
  protected _maxSamples: Size;
  protected _requiredTolerance: Real;
  protected _brownianBridge: boolean;
  protected _seed: BigNatural;
}
export declare class MakeMCPerformanceEngine implements
    NullaryFunction<PricingEngine> {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  mmcpeInit(process: GeneralizedBlackScholesProcess): MakeMCPerformanceEngine;
  withBrownianBridge(b?: boolean): MakeMCPerformanceEngine;
  withAntitheticVariate(b?: boolean): MakeMCPerformanceEngine;
  withSamples(samples: Size): MakeMCPerformanceEngine;
  withAbsoluteTolerance(tolerance: Real): MakeMCPerformanceEngine;
  withMaxSamples(samples: Size): MakeMCPerformanceEngine;
  withSeed(seed: BigNatural): MakeMCPerformanceEngine;
  f(): PricingEngine;
  RNG: MonteCarloModel.rng_traits;
  S: any;
  private _process;
  private _brownianBridge;
  private _antithetic;
  private _samples;
  private _maxSamples;
  private _tolerance;
  private _seed;
}
export declare class PerformanceOptionPathPricer extends PathPricer<Path> {
  constructor(type: Option.Type, strike: Real, discounts: DiscountFactor[]);
  f(path: Path): Real;
  private _strike;
  private _type;
  private _discounts;
}

export declare class IntegralCdsEngine extends CreditDefaultSwapEngine.engine {
  constructor(
      integrationStep: Period,
      probability: Handle<DefaultProbabilityTermStructure>, recoveryRate: Real,
      discountCurve: Handle<YieldTermStructure>,
      includeSettlementDateFlows?: boolean);
}

export declare class IsdaCdsEngine extends CreditDefaultSwapEngine.engine {
  constructor(
      probability: Handle<DefaultProbabilityTermStructure>, recoveryRate: Real,
      discountCurve: Handle<YieldTermStructure>,
      includeSettlementDateFlows?: boolean,
      numericalFix?: IsdaCdsEngine.NumericalFix,
      accrualBias?: IsdaCdsEngine.AccrualBias,
      forwardsInCouponPeriod?: IsdaCdsEngine.ForwardsInCouponPeriod);
}
export declare namespace IsdaCdsEngine {
  enum NumericalFix { None = 0, Taylor = 1 }
  enum AccrualBias { HalfDayBias = 0, NoBias = 1 }
  enum ForwardsInCouponPeriod { Flat = 0, Piecewise = 1 }
}

export declare class MidPointCdsEngine extends CreditDefaultSwapEngine.engine {
  constructor(
      probability: Handle<DefaultProbabilityTermStructure>, recoveryRate: Real,
      discountCurve: Handle<YieldTermStructure>,
      includeSettlementDateFlows?: boolean);
  calculate(): void;
  private _probability;
  private _recoveryRate;
  private _discountCurve;
  private _includeSettlementDateFlows;
}

export declare class ForwardVanillaEngine extends
    GenericEngine<ForwardOptionArguments, VanillaOptionEngine.Results> {
  constructor(Engine?: any);
  init1(process: GeneralizedBlackScholesProcess): ForwardVanillaEngine;
  calculate(): void;
  protected setup(): void;
  protected getOriginalResults(): void;
  Engine: any;
  protected _process: GeneralizedBlackScholesProcess;
  protected _originalEngine: PricingEngine;
  protected _originalArguments: VanillaOptionEngine.Arguments;
  protected _originalResults: VanillaOptionEngine.Results;
}

export declare class ForwardPerformanceVanillaEngine extends
    ForwardVanillaEngine {}

export declare class MCVarianceSwapEngine extends
    VarianceSwapEngineMcSimulation {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  mcvseInit(
      process: GeneralizedBlackScholesProcess, timeSteps: Size,
      timeStepsPerYear: Size, brownianBridge: boolean,
      antitheticVariate: boolean, requiredSamples: Size,
      requiredTolerance: Real, maxSamples: Size,
      seed: BigNatural): MCVarianceSwapEngine;
  pathPricer(): PathPricer<Path>;
  timeGrid(): TimeGrid;
  protected _process: GeneralizedBlackScholesProcess;
  protected _timeSteps: Size;
  protected _timeStepsPerYear: Size;
  protected _requiredSamples: Size;
  protected _maxSamples: Size;
  protected _requiredTolerance: Real;
  protected _brownianBridge: boolean;
  protected _seed: BigNatural;
}
export declare class MakeMCVarianceSwapEngine implements
    NullaryFunction<PricingEngine> {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  init(process: GeneralizedBlackScholesProcess): MakeMCVarianceSwapEngine;
  withSteps(steps: Size): MakeMCVarianceSwapEngine;
  withStepsPerYear(steps: Size): MakeMCVarianceSwapEngine;
  withBrownianBridge(b?: boolean): MakeMCVarianceSwapEngine;
  withSamples(samples: Size): MakeMCVarianceSwapEngine;
  withAbsoluteTolerance(tolerance: Real): MakeMCVarianceSwapEngine;
  withMaxSamples(samples: Size): MakeMCVarianceSwapEngine;
  withSeed(seed: BigNatural): MakeMCVarianceSwapEngine;
  withAntitheticVariate(b?: boolean): MakeMCVarianceSwapEngine;
  f(): PricingEngine;
  RNG: MonteCarloModel.rng_traits;
  S: any;
  private _process;
  private _antithetic;
  private _steps;
  private _stepsPerYear;
  private _samples;
  private _maxSamples;
  private _tolerance;
  private _brownianBridge;
  private _seed;
}
export declare class VariancePathPricer extends PathPricer<Path> {
  constructor(process: GeneralizedBlackScholesProcess);
  f(path: Path): Real;
  private _process;
}

export declare class ReplicatingVarianceSwapEngine extends VarianceSwap.engine {
  constructor(
      process: GeneralizedBlackScholesProcess, dk?: Real, callStrikes?: Real[],
      putStrikes?: Real[]);
  calculate(): void;
  protected computeOptionWeights(
      availStrikes: Real[], type: Option.Type,
      optionWeights: weights_type): void;
  protected computeLogPayoff(strike: Real, callPutStrikeBoundary: Real): Real;
  protected computeReplicatingPortfolio(optionWeights: weights_type): Real;
  protected riskFreeRate(): Rate;
  protected riskFreeDiscount(): DiscountFactor;
  protected underlying(): Real;
  protected residualTime(): Time;
  private _process;
  private _dk;
  private _callStrikes;
  private _putStrikes;
}
declare type weights_type = Array<[StrikedTypePayoff, Real]>;


export declare class YoYInflationCapFloorEngine extends
    YoYInflationCapFloor.engine {
  constructor(
      index: YoYInflationIndex,
      volatility: Handle<YoYOptionletVolatilitySurface>);
  index(): YoYInflationIndex;
  volatility(): Handle<YoYOptionletVolatilitySurface>;
  setVolatility(v: Handle<YoYOptionletVolatilitySurface>): void;
  calculate(): void;
  optionletImpl(
      type: Option.Type, strike: Real, forward: Rate, stdDev: Real,
      d: Real): Real;
  protected _index: YoYInflationIndex;
  protected _volatility: Handle<YoYOptionletVolatilitySurface>;
}
export declare class YoYInflationBlackCapFloorEngine extends
    YoYInflationCapFloorEngine {
  constructor(
      index: YoYInflationIndex,
      volatility: Handle<YoYOptionletVolatilitySurface>);
  optionletImpl(
      type: Option.Type, strike: Real, forward: Rate, stdDev: Real,
      d: Real): Real;
}
export declare class YoYInflationUnitDisplacedBlackCapFloorEngine extends
    YoYInflationCapFloorEngine {
  constructor(
      index: YoYInflationIndex,
      volatility: Handle<YoYOptionletVolatilitySurface>);
  optionletImpl(
      type: Option.Type, strike: Real, forward: Rate, stdDev: Real,
      d: Real): Real;
}
export declare class YoYInflationBachelierCapFloorEngine extends
    YoYInflationCapFloorEngine {
  constructor(
      index: YoYInflationIndex,
      volatility: Handle<YoYOptionletVolatilitySurface>);
  optionletImpl(
      type: Option.Type, strike: Real, forward: Rate, stdDev: Real,
      d: Real): Real;
}

export declare class AnalyticContinuousFixedLookbackEngine extends
    ContinuousFixedLookbackOption.engine {
  constructor(process: GeneralizedBlackScholesProcess);
  calculate(): void;
  private underlying;
  private strike;
  private residualTime;
  private volatility;
  private minmax;
  private stdDeviation;
  private riskFreeRate;
  private riskFreeDiscount;
  private dividendYield;
  private dividendDiscount;
  private A;
  private B;
  private C;
  private _process;
  private _f;
}

export declare class AnalyticContinuousFloatingLookbackEngine extends
    ContinuousFloatingLookbackOption.engine {
  constructor(process: GeneralizedBlackScholesProcess);
  calculate(): void;
  private underlying;
  private residualTime;
  private volatility;
  private minmax;
  private stdDeviation;
  private riskFreeRate;
  private riskFreeDiscount;
  private dividendYield;
  private dividendDiscount;
  private A;
  private _process;
  private _f;
}

export declare class AnalyticContinuousPartialFixedLookbackEngine extends
    ContinuousPartialFixedLookbackOption.engine {
  constructor(process: GeneralizedBlackScholesProcess);
  calculate(): void;
  private underlying;
  private strike;
  private residualTime;
  private volatility;
  private lookbackPeriodStartTime;
  private stdDeviation;
  private riskFreeRate;
  private riskFreeDiscount;
  private dividendYield;
  private dividendDiscount;
  private A;
  private _process;
  private _f;
}

export declare class AnalyticContinuousPartialFloatingLookbackEngine extends
    ContinuousPartialFloatingLookbackOption.engine {
  constructor(process: GeneralizedBlackScholesProcess);
  calculate(): void;
  private underlying;
  private residualTime;
  private volatility;
  minmax(): Real;
  lambda(): Real;
  private lookbackPeriodEndTime;
  private stdDeviation;
  private riskFreeRate;
  private riskFreeDiscount;
  private dividendYield;
  private dividendDiscount;
  private A;
  private _process;
  private _f;
}

export declare class QuantoEngine extends
    GenericEngine<PricingEngine.Arguments, QuantoOptionResults> {
  constructor(Arguments: any, Results: any, Engine: any);
  qeInit(
      process: GeneralizedBlackScholesProcess,
      foreignRiskFreeRate: Handle<YieldTermStructure>,
      exchangeRateVolatility: Handle<BlackVolTermStructure>,
      correlation: Handle<Quote>): QuantoEngine;
  calculate(): void;
  Engine: any;
  protected _process: GeneralizedBlackScholesProcess;
  protected _foreignRiskFreeRate: Handle<YieldTermStructure>;
  protected _exchangeRateVolatility: Handle<BlackVolTermStructure>;
  protected _correlation: Handle<Quote>;
}

export declare class CounterpartyAdjSwapEngine extends VanillaSwap.engine {
  init1(
      discountCurve: Handle<YieldTermStructure>,
      swaptionEngine: Handle<PricingEngine>,
      ctptyDTS: Handle<DefaultProbabilityTermStructure>,
      ctptyRecoveryRate: Real,
      invstDTS?: Handle<DefaultProbabilityTermStructure>,
      invstRecoveryRate?: Real): CounterpartyAdjSwapEngine;
  init2(
      discountCurve: Handle<YieldTermStructure>, blackVol: Volatility,
      ctptyDTS: Handle<DefaultProbabilityTermStructure>,
      ctptyRecoveryRate: Real,
      invstDTS?: Handle<DefaultProbabilityTermStructure>,
      invstRecoveryRate?: Real): CounterpartyAdjSwapEngine;
  init3(
      discountCurve: Handle<YieldTermStructure>, blackVol: Handle<Quote>,
      ctptyDTS: Handle<DefaultProbabilityTermStructure>,
      ctptyRecoveryRate: Real,
      invstDTS?: Handle<DefaultProbabilityTermStructure>,
      invstRecoveryRate?: Real): CounterpartyAdjSwapEngine;
  calculate(): void;
  private _baseSwapEngine;
  private _swaptionletEngine;
  private _discountCurve;
  private _defaultTS;
  private _ctptyRecoveryRate;
  private _invstDTS;
  private _invstRecoveryRate;
}

export declare class DiscountingSwapEngine extends Swap.engine {
  constructor(
      discountCurve?: Handle<YieldTermStructure>,
      includeSettlementDateFlows?: boolean, settlementDate?: Date,
      npvDate?: Date);
  discountCurve(): Handle<YieldTermStructure>;
  calculate(): void;
  private _discountCurve;
  private _includeSettlementDateFlows;
  private _settlementDate;
  private _npvDate;
}

export declare class DiscretizedSwap extends DiscretizedAsset {
  constructor(
      args: VanillaSwap.Arguments, referenceDate: Date, dayCounter: DayCounter);
  reset(size: Size): void;
  mandatoryTimes(): Time[];
  preAdjustValuesImpl(): void;
  postAdjustValuesImpl(): void;
  private _arguments;
  private _fixedResetTimes;
  private _fixedPayTimes;
  private _floatingResetTimes;
  private _floatingPayTimes;
}

export declare class TreeVanillaSwapEngine extends
    LatticeShortRateModelEngine<VanillaSwap.Arguments, VanillaSwap.Results> {
  tvseInit1(
      model: ShortRateModel, timeSteps: Size,
      termStructure?: Handle<YieldTermStructure>): TreeVanillaSwapEngine;
  tvseInit2(
      model: ShortRateModel, timeGrid: TimeGrid,
      termStructure?: Handle<YieldTermStructure>): TreeVanillaSwapEngine;
  calculate(): void;
  private _termStructure;
}

export declare class BasketGeneratingEngine extends PricingEngine {
  bgeInit1(
      model: Gaussian1dModel, oas: Handle<Quote>,
      discountCurve: Handle<YieldTermStructure>): BasketGeneratingEngine;
  bgeInit2(
      model: Handle<Gaussian1dModel>, oas: Handle<Quote>,
      discountCurve: Handle<YieldTermStructure>): BasketGeneratingEngine;
  calibrationBasket(
      exercise: Exercise, standardSwapBase: SwapIndex,
      swaptionVolatility: SwaptionVolatilityStructure,
      basketType?: BasketGeneratingEngine.CalibrationBasketType):
      BlackCalibrationHelper[];
  underlyingNpv(expiry: Date, y: Real): Real;
  underlyingType(): VanillaSwap.Type;
  underlyingLastDate(): Date;
  initialGuess(expiry: Date): Real[];
  _onefactormodel: Handle<Gaussian1dModel>;
  _oas: Handle<Quote>;
  _discountCurve: Handle<YieldTermStructure>;
}
export declare namespace BasketGeneratingEngine {
  enum CalibrationBasketType { Naive = 0, MaturityStrikeByDeltaGamma = 1 }
  class MatchHelper extends CostFunction {
    constructor(
        type: VanillaSwap.Type, npv: Real, delta: Real, gamma: Real,
        model: Gaussian1dModel, indexBase: SwapIndex, expiry: Date,
        maxMaturity: Real, h: Real);
    NPV(swap: VanillaSwap, fixedRate: Real, nominal: Real, y: Real,
        type: Integer): Real;
    value(v: Real[]): Real;
    values(v: Real[]): Real[];
    _type: VanillaSwap.Type;
    _mdl: Gaussian1dModel;
    _indexBase: SwapIndex;
    _expiry: Date;
    _maxMaturity: Real;
    _npv: Real;
    _delta: Real;
    _gamma: Real;
    _h: Real;
  }
}

export declare class BlackStyleSwaptionEngine extends SwaptionEngine.engine {
  constructor(spec: Black76Spec|BachelierSpec);
  bsseInit1(
      discountCurve: Handle<YieldTermStructure>, vol: Volatility,
      dc?: DayCounter, displacement?: Real,
      model?: BlackStyleSwaptionEngine.CashAnnuityModel):
      BlackStyleSwaptionEngine;
  bsseInit2(
      discountCurve: Handle<YieldTermStructure>, vol: Handle<Quote>,
      dc?: DayCounter, displacement?: Real,
      model?: BlackStyleSwaptionEngine.CashAnnuityModel):
      BlackStyleSwaptionEngine;
  bsseInit3(
      discountCurve: Handle<YieldTermStructure>,
      vol: Handle<SwaptionVolatilityStructure>,
      model?: BlackStyleSwaptionEngine.CashAnnuityModel):
      BlackStyleSwaptionEngine;
  calculate(): void;
  termStructure(): Handle<YieldTermStructure>;
  volatility(): Handle<SwaptionVolatilityStructure>;
  spec: Black76Spec|BachelierSpec;
  private _discountCurve;
  private _vol;
  private _model;
}
export declare namespace BlackStyleSwaptionEngine {
  enum CashAnnuityModel { SwapRate = 0, DiscountCurve = 1 }
}
export declare class Black76Spec {
  type: VolatilityType;
  value(
      type: Option.Type, strike: Real, atmForward: Real, stdDev: Real,
      annuity: Real, displacement: Real): Real;
  vega(
      strike: Real, atmForward: Real, stdDev: Real, exerciseTime: Real,
      annuity: Real, displacement: Real): Real;
}
export declare class BachelierSpec {
  type: VolatilityType;
  value(
      type: Option.Type, strike: Real, atmForward: Real, stdDev: Real,
      annuity: Real, displacement: Real): Real;
  vega(
      strike: Real, atmForward: Real, stdDev: Real, exerciseTime: Real,
      annuity: Real, displacement: Real): Real;
}
export declare class BlackSwaptionEngine extends BlackStyleSwaptionEngine {
  constructor();
  bseInit1(
      discountCurve: Handle<YieldTermStructure>, vol: Volatility,
      dc?: DayCounter, displacement?: Real,
      model?: BlackStyleSwaptionEngine.CashAnnuityModel): BlackSwaptionEngine;
  bseInit2(
      discountCurve: Handle<YieldTermStructure>, vol: Handle<Quote>,
      dc?: DayCounter, displacement?: Real,
      model?: BlackStyleSwaptionEngine.CashAnnuityModel): BlackSwaptionEngine;
  bseInit3(
      discountCurve: Handle<YieldTermStructure>,
      vol: Handle<SwaptionVolatilityStructure>,
      model?: BlackStyleSwaptionEngine.CashAnnuityModel): BlackSwaptionEngine;
}
export declare class BachelierSwaptionEngine extends BlackStyleSwaptionEngine {
  constructor();
  bseInit1(
      discountCurve: Handle<YieldTermStructure>, vol: Volatility,
      dc?: DayCounter, displacement?: Real,
      model?: BlackStyleSwaptionEngine.CashAnnuityModel): BlackSwaptionEngine;
  bseInit2(
      discountCurve: Handle<YieldTermStructure>, vol: Handle<Quote>,
      dc?: DayCounter, displacement?: Real,
      model?: BlackStyleSwaptionEngine.CashAnnuityModel): BlackSwaptionEngine;
  bseInit3(
      discountCurve: Handle<YieldTermStructure>,
      vol: Handle<SwaptionVolatilityStructure>,
      model?: BlackStyleSwaptionEngine.CashAnnuityModel): BlackSwaptionEngine;
}

export declare class DiscretizedSwaption extends DiscretizedOption {
  constructor(
      args: SwaptionEngine.Arguments, referenceDate: Date,
      dayCounter: DayCounter);
  reset(size: Size): void;
  private _arguments;
  private _lastPayment;
}

export declare class FdG2SwaptionEngine extends
    GenericModelEngine<G2, SwaptionEngine.Arguments, SwaptionEngine.Results> {
  constructor(
      model: G2, tGrid?: Size, xGrid?: Size, yGrid?: Size, dampingSteps?: Size,
      invEps?: Real, schemeDesc?: FdmSchemeDesc);
}

export declare class FdHullWhiteSwaptionEngine extends GenericModelEngine<
    HullWhite, SwaptionEngine.Arguments, SwaptionEngine.Results> {
  constructor(
      model: HullWhite, tGrid?: Size, xGrid?: Size, dampingSteps?: Size,
      invEps?: Real, schemeDesc?: FdmSchemeDesc);
}

export declare class G2SwaptionEngine extends
    GenericModelEngine<G2, SwaptionEngine.Arguments, SwaptionEngine.Results> {
  constructor(model: G2, range: Real, intervals: Size);
}

export declare class Gaussian1dFloatFloatSwaptionEngine extends
    BasketGeneratingEngineGenericModelEngine<
        Gaussian1dModel, FloatFloatSwaption.Arguments,
        FloatFloatSwaption.Results> {
  g1dffseInit1(
      model: Gaussian1dModel, integrationPoints?: Integer, stddevs?: Real,
      extrapolatePayoff?: boolean, flatPayoffExtrapolation?: boolean,
      oas?: Handle<Quote>, discountCurve?: Handle<YieldTermStructure>,
      includeTodaysExercise?: boolean,
      probabilities?: Gaussian1dFloatFloatSwaptionEngine.Probabilities):
      Gaussian1dFloatFloatSwaptionEngine;
  g1dffseInit2(
      model: Handle<Gaussian1dModel>, integrationPoints?: Integer,
      stddevs?: Real, extrapolatePayoff?: boolean,
      flatPayoffExtrapolation?: boolean, oas?: Handle<Quote>,
      discountCurve?: Handle<YieldTermStructure>,
      includeTodaysExercise?: boolean,
      probabilities?: Gaussian1dFloatFloatSwaptionEngine.Probabilities):
      Gaussian1dFloatFloatSwaptionEngine;
  discountingCurve(): Handle<YieldTermStructure>;
  underlyingNpv(expiry: Date, y: Real): Real;
  underlyingType(): VanillaSwap.Type;
  underlyingLastDate(): Date;
  initialGuess(expiry: Date): Real[];
  private npvs;
  private _integrationPoints;
  private _stddevs;
  private _extrapolatePayoff;
  private _flatPayoffExtrapolation;
  private _includeTodaysExercise;
  private _probabilities;
  private _rebatedExercise;
}
export declare namespace Gaussian1dFloatFloatSwaptionEngine {
  enum Probabilities { None = 0, Naive = 1, Digital = 2 }
}

export declare class Gaussian1dJamshidianSwaptionEngine extends
    GenericModelEngine<
        Gaussian1dModel, SwaptionEngine.Arguments, SwaptionEngine.Results> {
  constructor(model: Gaussian1dModel);
}

export declare class Gaussian1dNonstandardSwaptionEngine extends
    BasketGeneratingEngineGenericModelEngine<
        Gaussian1dModel, NonstandardSwaption.Arguments,
        NonstandardSwaption.Results> {
  g1dnsseInit1(
      model: Gaussian1dModel, integrationPoints?: Integer, stddevs?: Real,
      extrapolatePayoff?: boolean, flatPayoffExtrapolation?: boolean,
      oas?: Handle<Quote>, discountCurve?: Handle<YieldTermStructure>,
      probabilities?: Gaussian1dNonstandardSwaptionEngine.Probabilities):
      Gaussian1dNonstandardSwaptionEngine;
  g1dnsseInit2(
      model: Handle<Gaussian1dModel>, integrationPoints?: Integer,
      stddevs?: Real, extrapolatePayoff?: boolean,
      flatPayoffExtrapolation?: boolean, oas?: Handle<Quote>,
      discountCurve?: Handle<YieldTermStructure>,
      probabilities?: Gaussian1dNonstandardSwaptionEngine.Probabilities):
      Gaussian1dNonstandardSwaptionEngine;
}
export declare namespace Gaussian1dNonstandardSwaptionEngine {
  enum Probabilities { None = 0, Naive = 1, Digital = 2 }
}

export declare class Gaussian1dSwaptionEngine extends GenericModelEngine<
    Gaussian1dModel, SwaptionEngine.Arguments, SwaptionEngine.Results> {
  g1dseInit1(
      model: Gaussian1dModel, integrationPoints?: Integer, stddevs?: Real,
      extrapolatePayoff?: boolean, flatPayoffExtrapolation?: boolean,
      discountCurve?: Handle<YieldTermStructure>,
      probabilities?: Gaussian1dSwaptionEngine.Probabilities):
      Gaussian1dSwaptionEngine;
  g1dseInit2(
      model: Handle<Gaussian1dModel>, integrationPoints?: Integer,
      stddevs?: Real, extrapolatePayoff?: boolean,
      flatPayoffExtrapolation?: boolean,
      discountCurve?: Handle<YieldTermStructure>,
      probabilities?: Gaussian1dSwaptionEngine.Probabilities):
      Gaussian1dSwaptionEngine;
}
export declare namespace Gaussian1dSwaptionEngine {
  enum Probabilities { None = 0, Naive = 1, Digital = 2 }
}

export declare class JamshidianSwaptionEngine extends GenericModelEngine<
    OneFactorAffineTermStructureConsistent, SwaptionEngine.Arguments,
    SwaptionEngine.Results> {
  constructor(
      model: OneFactorAffineTermStructureConsistent,
      termStructure?: Handle<YieldTermStructure>);
  calculate(): void;
  private _termStructure;
}
export declare namespace JamshidianSwaptionEngine {
  class rStarFinder implements UnaryFunction<Rate, Real> {
    constructor(
        model: OneFactorAffineTermStructureConsistent, nominal: Real,
        maturity: Time, valueTime: Time, fixedPayTimes: Time[],
        amounts: Time[]);
    f(x: Rate): Real;
    private _strike;
    private _maturity;
    private _valueTime;
    private _times;
    private _amounts;
    private _model;
  }
}

export declare class TreeSwaptionEngine extends LatticeShortRateModelEngine<
    SwaptionEngine.Arguments, SwaptionEngine.Results> {
  tseInit1(
      model: ShortRateModel, timeSteps: Size,
      termStructure?: Handle<YieldTermStructure>): TreeSwaptionEngine;
  tseInit2(
      model: ShortRateModel, timeGrid: TimeGrid,
      termStructure?: Handle<YieldTermStructure>): TreeSwaptionEngine;
  tseInit3(
      model: Handle<ShortRateModel>, timeSteps: Size,
      termStructure?: Handle<YieldTermStructure>): TreeSwaptionEngine;
}

export declare class AnalyticBSMHullWhiteEngine extends GenericModelEngine<
    HullWhite, VanillaOptionEngine.Arguments, VanillaOptionEngine.Results> {
  constructor(
      equityShortRateCorrelation: Real, process: GeneralizedBlackScholesProcess,
      model: HullWhite);
  calculate(): void;
  private _rho;
  private _process;
}

export declare class AnalyticDigitalAmericanEngine extends
    VanillaOption.engine {
  constructor(process: GeneralizedBlackScholesProcess);
  calculate(): void;
  knock_in(): boolean;
  private _process;
}
export declare class AnalyticDigitalAmericanKOEngine extends
    AnalyticDigitalAmericanEngine {
  knock_in(): boolean;
}

export declare class AnalyticDividendEuropeanEngine extends
    DividendVanillaOptionEngine.engine {
  constructor(process: GeneralizedBlackScholesProcess);
  calculate(): void;
  private _process;
}

export declare class AnalyticEuropeanEngine extends VanillaOptionEngine.engine {
  init1(process: GeneralizedBlackScholesProcess): AnalyticEuropeanEngine;
  init2(
      process: GeneralizedBlackScholesProcess,
      discountCurve: Handle<YieldTermStructure>): AnalyticEuropeanEngine;
  calculate(): void;
  private _process;
  private _discountCurve;
}

export declare class AnalyticGJRGARCHEngine extends GenericModelEngine<
    GJRGARCHModel, VanillaOptionEngine.Arguments, VanillaOptionEngine.Results> {
  constructor(model: GJRGARCHModel);
  calculate(): void;
  private _init;
  private _h1;
  private _b0;
  private _b1;
  private _b2;
  private _b3;
  private _la;
  private _r;
  private _T;
  private _m1;
  private _m2;
  private _m3;
  private _v1;
  private _v2;
  _v3: Real;
  private _z1;
  _z2: Real;
  private _x1;
  private _ex;
  private _sigma;
  private _k3;
  private _k4;
}

export declare class AnalyticH1HWEngine extends AnalyticHestonHullWhiteEngine {
  ah1hweInit1(
      model: HestonModel, hullWhiteModel: HullWhite, rhoSr: Real,
      integrationOrder?: Size): AnalyticH1HWEngine;
  ah1hweInit2(
      model: HestonModel, hullWhiteModel: HullWhite, rhoSr: Real,
      relTolerance: Real, maxEvaluations: Size): AnalyticH1HWEngine;
  addOnTerm(u: Real, t: Time, j: Size): Complex;
  private _rhoSr;
}

export declare class AnalyticHestonEngine extends GenericModelEngine<
    HestonModel, VanillaOptionEngine.Arguments, VanillaOptionEngine.Results> {
  aheInit1(model: HestonModel, relTolerance: Real, maxEvaluations: Size):
      AnalyticHestonEngine;
  aheInit2(model: HestonModel, integrationOrder?: Size): AnalyticHestonEngine;
  aheInit3(
      model: HestonModel, cpxLog: AnalyticHestonEngine.ComplexLogFormula,
      integration: AnalyticHestonEngine.Integration,
      andersenPiterbargEpsilon?: Real): AnalyticHestonEngine;
  chF(z: Complex, T: Time): Complex;
  lnChF(z: Complex, t: Time): Complex;
  calculate(): void;
  numberOfEvaluations(): Size;
  static doCalculation(
      riskFreeDiscount: Real, dividendDiscount: Real, spotPrice: Real,
      strikePrice: Real, term: Real, kappa: Real, theta: Real, sigma: Real,
      v0: Real, rho: Real, type: TypePayoff,
      integration: AnalyticHestonEngine.Integration,
      cpxLog: AnalyticHestonEngine.ComplexLogFormula,
      enginePtr: AnalyticHestonEngine, ref: byRef): void;
  addOnTerm(phi: Real, t: Time, j: Size): Complex;
  private _evaluations;
  private _cpxLog;
  private _integration;
  private _andersenPiterbargEpsilon;
}
export declare namespace AnalyticHestonEngine {
  enum ComplexLogFormula {
    Gatheral = 0,
    BranchCorrection = 1,
    AndersenPiterbarg = 2
  }
  class Integration {
    init1(
        intAlgo: Integration.Algorithm,
        gaussianQuadrature: GaussianQuadrature): Integration;
    init2(intAlgo: Integration.Algorithm, integrator: Integrator): Integration;
    static gaussLaguerre(intOrder?: Size): Integration;
    static gaussLegendre(intOrder?: Size): Integration;
    static gaussChebyshev(intOrder?: Size): Integration;
    static gaussChebyshev2nd(intOrder?: Size): Integration;
    static gaussLobatto(
        relTolerance: Real, absTolerance: Real,
        maxEvaluations?: Size): Integration;
    static gaussKronrod(absTolerance: Real, maxEvaluations?: Size): Integration;
    static simpson(absTolerance: Real, maxEvaluations?: Size): Integration;
    static trapezoid(absTolerance: Real, maxEvaluations?: Size): Integration;
    static discreteSimpson(evaluations?: Size): Integration;
    static discreteTrapezoid(evaluations?: Size): Integration;
    static andersenPiterbargIntegrationLimit(
        c_inf: Real, epsilon: Real, v0: Real, t: Real): Real;
    calculate(c_inf: Real, f: UnaryFunction<Real, Real>, maxBound?: Real): Real;
    numberOfEvaluations(): Size;
    isAdaptiveIntegration(): boolean;
    _intAlgo: Integration.Algorithm;
    _integrator: Integrator;
    _gaussianQuadrature: GaussianQuadrature;
  }
  namespace Integration {
    enum Algorithm {
      GaussLobatto = 0,
      GaussKronrod = 1,
      Simpson = 2,
      Trapezoid = 3,
      DiscreteTrapezoid = 4,
      DiscreteSimpson = 5,
      GaussLaguerre = 6,
      GaussLegendre = 7,
      GaussChebyshev = 8,
      GaussChebyshev2nd = 9
    }
  }
  class Fj_Helper implements UnaryFunction<Real, Real> {
    init1(
        args: VanillaOptionEngine.Arguments, model: HestonModel,
        engine: AnalyticHestonEngine, cpxLog: ComplexLogFormula, term: Time,
        ratio: Real, j: Size): Fj_Helper;
    init2(
        kappa: Real, theta: Real, sigma: Real, v0: Real, s0: Real, rho: Real,
        engine: AnalyticHestonEngine, cpxLog: ComplexLogFormula, term: Time,
        strike: Real, ratio: Real, j: Size): Fj_Helper;
    init3(
        kappa: Real, theta: Real, sigma: Real, v0: Real, s0: Real, rho: Real,
        cpxLog: ComplexLogFormula, term: Time, strike: Real, ratio: Real,
        j: Size): Fj_Helper;
    f(phi: Real): Real;
    private _j;
    private _kappa;
    private _theta;
    private _sigma;
    private _v0;
    private _cpxLog;
    private _term;
    private _x;
    private _sx;
    private _dd;
    private _sigma2;
    private _rsigma;
    private _t0;
    private _b;
    private _g_km1;
    private _engine;
  }
  class AP_Helper implements UnaryFunction<Real, Real> {
    constructor(
        term: Time, s0: Real, strike: Real, ratio: Real, sigmaBS: Volatility,
        enginePtr: AnalyticHestonEngine);
    f(u: Real): Real;
    private _term;
    private _sigmaBS;
    private _x;
    private _sx;
    private _dd;
    private _enginePtr;
  }
}
interface byRef {
  value: Real;
  evaluations: Size;
}


export declare class AnalyticHestonHullWhiteEngine extends
    AnalyticHestonEngine {
  ahhweInit1(
      hestonModel: HestonModel, hullWhiteModel: HullWhite,
      integrationOrder?: Size): AnalyticHestonHullWhiteEngine;
  ahhweInit2(
      hestonModel: HestonModel, hullWhiteModel: HullWhite, relTolerance: Real,
      maxEvaluations: Size): AnalyticHestonHullWhiteEngine;
  update(): void;
  calculate(): void;
  addOnTerm(u: Real, t: Time, j: Size): Complex;
  protected _hullWhiteModel: HullWhite;
  private _m;
  private _a;
  private _sigma;
}

export declare class AnalyticPTDHestonEngine extends GenericModelEngine<
    PiecewiseTimeDependentHestonModel, VanillaOptionEngine.Arguments,
    VanillaOptionEngine.Results> {
  aptdheInit1(
      model: PiecewiseTimeDependentHestonModel, relTolerance: Real,
      maxEvaluations: Size): AnalyticPTDHestonEngine;
  aptdheInit2(
      model: PiecewiseTimeDependentHestonModel,
      integrationOrder?: Size): AnalyticPTDHestonEngine;
  aptdheInit3(
      model: PiecewiseTimeDependentHestonModel,
      cpxLog: AnalyticPTDHestonEngine.ComplexLogFormula,
      itg: AnalyticHestonEngine.Integration,
      andersenPiterbargEpsilon?: Real): AnalyticPTDHestonEngine;
  calculate(): void;
  numberOfEvaluations(): Size;
  chF(z: Complex, T: Time): Complex;
  lnChF(z: Complex, T: Time): Complex;
  private _evaluations;
  private _cpxLog;
  private _integration;
  private _andersenPiterbargEpsilon;
}
export declare namespace AnalyticPTDHestonEngine {
  enum ComplexLogFormula { Gatheral = 0, AndersenPiterbarg = 1 }
  type Integration = AnalyticHestonEngine.Integration;
  class Fj_Helper {
    constructor(
        model: Handle<PiecewiseTimeDependentHestonModel>, term: Time,
        strike: Real, j: Size);
    f(phi: Real): Real;
    private _j;
    private _term;
    private _v0;
    private _x;
    private _sx;
    private _r;
    private _q;
    _qTS: YieldTermStructure;
    private _model;
    private _timeGrid;
  }
  class AP_Helper {
    constructor(
        term: Time, s0: Real, strike: Real, ratio: Real, sigmaBS: Volatility,
        enginePtr: AnalyticPTDHestonEngine);
    f(u: Real): Real;
    private _term;
    private _sigmaBS;
    private _x;
    private _sx;
    private _dd;
    private _enginePtr;
  }
}

export declare class BaroneAdesiWhaleyApproximationEngine extends
    VanillaOption.engine {
  constructor(process: GeneralizedBlackScholesProcess);
  calculate(): void;
  static criticalPrice(
      payoff: StrikedTypePayoff, riskFreeDiscount: DiscountFactor,
      dividendDiscount: DiscountFactor, variance: Real, tolerance?: Real): Real;
  private _process;
}

export declare class BatesEngine extends AnalyticHestonEngine {
  beInit1(model: BatesModel, integrationOrder?: Size): BatesEngine;
  beInit2(model: BatesModel, relTolerance: Real, maxEvaluations: Size):
      BatesEngine;
  addOnTerm(phi: Real, t: Time, j: Size): Complex;
}
export declare class BatesDetJumpEngine extends BatesEngine {
  bdjeInit1(model: BatesDetJumpModel, integrationOrder?: Size):
      BatesDetJumpEngine;
  bdjeInit2(model: BatesDetJumpModel, relTolerance: Real, maxEvaluations: Size):
      BatesDetJumpEngine;
  addOnTerm(phi: Real, t: Time, j: Size): Complex;
}
export declare class BatesDoubleExpEngine extends AnalyticHestonEngine {
  bdeeInit1(model: BatesDoubleExpModel, integrationOrder?: Size):
      BatesDoubleExpEngine;
  bdeeInit2(
      model: BatesDoubleExpModel, relTolerance: Real,
      maxEvaluations: Size): BatesDoubleExpEngine;
  addOnTerm(phi: Real, t: Time, j: Size): Complex;
}
export declare class BatesDoubleExpDetJumpEngine extends BatesDoubleExpEngine {
  bdedjeInit1(model: BatesDoubleExpDetJumpModel, integrationOrder?: Size):
      BatesDoubleExpDetJumpEngine;
  bdedjeInit2(
      model: BatesDoubleExpDetJumpModel, relTolerance: Real,
      maxEvaluations: Size): BatesDoubleExpDetJumpEngine;
  addOnTerm(phi: Real, t: Time, j: Size): Complex;
}

export declare class BinomialVanillaEngine extends VanillaOption.engine {
  constructor(T: any);
  bveInit(process: GeneralizedBlackScholesProcess, timeSteps: Size):
      BinomialVanillaEngine;
  calculate(): void;
  T: any;
  private _process;
  private _timeSteps;
}

export declare class BjerksundStenslandApproximationEngine extends
    VanillaOption.engine {
  constructor(process: GeneralizedBlackScholesProcess);
  calculate(): void;
  private _process;
}

export declare class COSHestonEngine extends GenericModelEngine<
    HestonModel, VanillaOptionEngine.Arguments, VanillaOptionEngine.Results> {
  constructor(model: HestonModel, L?: Real, N?: Size);
  update(): void;
  calculate(): void;
  chF(u: Real, t: Real): Complex;
  c1(t: Time): Real;
  c2(t: Time): Real;
  c3(t: Time): Real;
  c4(t: Time): Real;
  muT(t: Time): Real;
  private _L;
  private _N;
  private _kappa;
  private _theta;
  private _sigma;
  private _rho;
  private _v0;
}

export declare class DiscretizedVanillaOption extends DiscretizedAsset {
  constructor(
      args: VanillaOptionEngine.Arguments, process: StochasticProcess,
      grid?: TimeGrid);
  reset(size: Size): void;
  mandatoryTimes(): Time[];
  postAdjustValuesImpl(): void;
  private applySpecificCondition;
  private _arguments;
  private _stoppingTimes;
}

export declare class FDAmericanEngine extends
    FDEngineAdapterOneAssetOptionEngine {
  constructor(Scheme: any);
  fdmaeInit(
      process: GeneralizedBlackScholesProcess, timeSteps?: Size,
      gridPoints?: Size, timeDependent?: boolean): FDAmericanEngine;
  Scheme: any;
}

export declare class FdBatesVanillaEngine extends GenericModelEngine<
    BatesModel, DividendVanillaOptionEngine.Arguments,
    DividendVanillaOptionEngine.Results> {
  constructor(
      model: BatesModel, tGrid?: Size, xGrid?: Size, vGrid?: Size,
      dampingSteps?: Size, schemeDesc?: FdmSchemeDesc);
  calculate(): void;
  private _tGrid;
  private _xGrid;
  private _vGrid;
  private _dampingSteps;
  private _schemeDesc;
}

export declare class FDBermudanEngine extends
    VanillaOptionEngineFDMultiPeriodEngine {
  constructor(Scheme: any);
  init1(
      process: GeneralizedBlackScholesProcess, timeSteps?: Size,
      gridPoints?: Size, timeDependent?: boolean): FDBermudanEngine;
  initializeStepCondition(): void;
  executeIntermediateStep(s: Size): void;
  protected extraTermInBermudan: Real;
}

export declare class FdBlackScholesVanillaEngine extends
    DividendVanillaOptionEngine.engine {
  constructor(
      process: GeneralizedBlackScholesProcess, tGrid?: Size, xGrid?: Size,
      dampingSteps?: Size, schemeDesc?: FdmSchemeDesc, localVol?: boolean,
      illegalLocalVolOverwrite?: Real);
  calculate(): void;
  private _process;
  private _tGrid;
  private _xGrid;
  private _dampingSteps;
  private _schemeDesc;
  private _localVol;
  private _illegalLocalVolOverwrite;
}

export declare class FDAmericanCondition extends FDVanillaEngine {
  constructor(baseEngine: FDVanillaEngine);
  init(
      process: GeneralizedBlackScholesProcess, timeSteps?: Size,
      gridPoints?: Size, timeDependent?: boolean): FDAmericanCondition;
  initializeStepCondition(): void;
  baseEngine: FDVanillaEngine;
}
export declare class FDShoutCondition extends FDVanillaEngine {
  constructor(baseEngine: FDStepConditionEngine);
  init(
      process: GeneralizedBlackScholesProcess, timeSteps?: Size,
      gridPoints?: Size, timeDependent?: boolean): FDShoutCondition;
  baseEngine: FDStepConditionEngine;
}

export declare class FDDividendAmericanEngine extends FDEngineAdapter {
  constructor(Scheme?: any);
  fdInit(
      process: GeneralizedBlackScholesProcess, timeSteps?: Size,
      gridPoints?: Size, timeDependent?: boolean): FDDividendAmericanEngine;
  Scheme: any;
}
export declare class FDDividendAmericanEngineMerton73 extends FDEngineAdapter {
  constructor(Scheme?: any);
  fdInit(
      process: GeneralizedBlackScholesProcess, timeSteps?: Size,
      gridPoints?: Size, timeDependent?: boolean): FDDividendAmericanEngine;
  Scheme: any;
}
export declare class FDDividendAmericanEngineShiftScale extends
    FDEngineAdapter {
  constructor(Scheme?: any);
  fdInit(
      process: GeneralizedBlackScholesProcess, timeSteps?: Size,
      gridPoints?: Size, timeDependent?: boolean): FDDividendAmericanEngine;
  Scheme: any;
}

export declare class FDDividendEngineBase extends FDMultiPeriodEngine {
  constructor(Scheme?: any);
  fdInit(
      process: GeneralizedBlackScholesProcess, timeSteps?: Size,
      gridPoints?: Size, timeDependent?: boolean): FDDividendEngineBase;
  setupArguments(a: PricingEngine.Arguments): void;
  protected setGridLimits(): void;
  executeIntermediateStep(step: Size): void;
  protected getDividendAmount(i: Size): Real;
  protected getDiscountedDividend(i: Size): Real;
}
export declare class FDDividendEngineMerton73 extends FDDividendEngineBase {
  constructor(Scheme?: any);
  fdInit(
      process: GeneralizedBlackScholesProcess, timeSteps?: Size,
      gridPoints?: Size, timeDependent?: boolean): FDDividendEngineMerton73;
  setGridLimits(): void;
  executeIntermediateStep(step: Size): void;
}
export declare class FDDividendEngineShiftScale extends FDDividendEngineBase {
  constructor(Scheme?: any);
  fdInit(
      process: GeneralizedBlackScholesProcess, timeSteps?: Size,
      gridPoints?: Size, timeDependent?: boolean): FDDividendEngineShiftScale;
  setGridLimits(): void;
  executeIntermediateStep(step: Size): void;
}
export declare class FDDividendEngine extends FDDividendEngineMerton73 {
  constructor(Scheme?: any);
  fdInit(
      process: GeneralizedBlackScholesProcess, timeSteps?: Size,
      gridPoints?: Size, timeDependent?: boolean): FDDividendEngine;
}

export declare class FDDividendEuropeanEngine extends FDEngineAdapter {
  constructor(Scheme: any);
  fdInit(
      process: GeneralizedBlackScholesProcess, timeSteps?: Size,
      gridPoints?: Size, timeDependent?: boolean): FDDividendEuropeanEngine;
  Scheme: any;
}
export declare class FDDividendEuropeanEngineMerton73 extends FDEngineAdapter {
  constructor(Scheme: any);
  fdInit(
      process: GeneralizedBlackScholesProcess, timeSteps?: Size,
      gridPoints?: Size,
      timeDependent?: boolean): FDDividendEuropeanEngineMerton73;
  Scheme: any;
}
export declare class FDDividendEuropeanEngineShiftScale extends
    FDEngineAdapter {
  constructor(Scheme: any);
  fdInit(
      process: GeneralizedBlackScholesProcess, timeSteps?: Size,
      gridPoints?: Size,
      timeDependent?: boolean): FDDividendEuropeanEngineShiftScale;
  Scheme: any;
}

export declare class FDDividendShoutEngine extends FDEngineAdapter {
  constructor(Scheme: any);
  fdInit(
      process: GeneralizedBlackScholesProcess, timeSteps?: Size,
      gridPoints?: Size, timeDependent?: boolean): FDDividendShoutEngine;
  Scheme: any;
}
export declare class FDDividendShoutEngineMerton73 extends FDEngineAdapter {
  constructor(Scheme: any);
  fdInit(
      process: GeneralizedBlackScholesProcess, timeSteps?: Size,
      gridPoints?: Size,
      timeDependent?: boolean): FDDividendShoutEngineMerton73;
  Scheme: any;
}
export declare class FDDividendShoutEngineShiftScale extends FDEngineAdapter {
  constructor(Scheme: any);
  fdInit(
      process: GeneralizedBlackScholesProcess, timeSteps?: Size,
      gridPoints?: Size,
      timeDependent?: boolean): FDDividendShoutEngineShiftScale;
  Scheme: any;
}

export declare class FDEuropeanEngine extends
    OneAssetOptionEngineFDVanillaEngine {
  constructor(Scheme: any);
  init1(
      process: GeneralizedBlackScholesProcess, timeSteps?: Size,
      gridPoints?: Size, timeDependent?: boolean): FDEuropeanEngine;
  Scheme: any;
  private _prices;
}

export declare class FdHestonHullWhiteVanillaEngine extends GenericModelEngine<
    HestonModel, DividendVanillaOptionEngine.Arguments,
    DividendVanillaOptionEngine.Results> {
  constructor(
      model: HestonModel, hwProcess: HullWhiteProcess,
      corrEquityShortRate: Real, tGrid?: Size, xGrid?: Size, vGrid?: Size,
      rGrid?: Size, dampingSteps?: Size, controlVariate?: boolean,
      schemeDesc?: FdmSchemeDesc);
  calculate(): void;
  update(): void;
  enableMultipleStrikesCaching(strikes: Real[]): void;
  private _hwProcess;
  private _corrEquityShortRate;
  private _tGrid;
  private _xGrid;
  private _vGrid;
  private _rGrid;
  private _dampingSteps;
  private _schemeDesc;
  private _controlVariate;
  private _strikes;
  private _cachedArgs2results;
}

export declare class FdHestonVanillaEngine extends GenericModelEngine<
    HestonModel, DividendVanillaOptionEngine.Arguments,
    DividendVanillaOptionEngine.Results> {
  constructor(
      model: HestonModel, tGrid?: number, xGrid?: number, vGrid?: number,
      dampingSteps?: number, schemeDesc?: FdmSchemeDesc,
      leverageFct?: LocalVolTermStructure);
  calculate(): void;
  update(): void;
  enableMultipleStrikesCaching(strikes: Real[]): void;
  getSolverDesc(equityScaleFactor: Real): FdmSolverDesc;
  private _tGrid;
  private _xGrid;
  private _vGrid;
  private _dampingSteps;
  private _schemeDesc;
  private _leverageFct;
  private _strikes;
  private _cachedArgs2results;
}

export declare class FDMultiPeriodEngine extends FDVanillaEngine {
  constructor(Scheme?: any);
  init1(
      process: GeneralizedBlackScholesProcess, timeSteps?: Size,
      gridPoints?: Size, timeDependent?: boolean): FDMultiPeriodEngine;
  setupArguments2(args: PricingEngine.Arguments, schedule: Event[]): void;
  setupArguments(a: PricingEngine.Arguments): void;
  calculate2(r: PricingEngine.Results): void;
  executeIntermediateStep(step: Size): void;
  initializeStepCondition(): void;
  initializeModel(): void;
  getDividendTime(i: Size): Time;
  Scheme: any;
  _events: Event[];
  _stoppingTimes: Time[];
  _timeStepPerPeriod: Size;
  _prices: SampledCurve;
  _stepCondition: StandardStepCondition;
  _model: any;
}

export declare class FDShoutEngine extends FDEngineAdapterOneAssetOptionEngine {
  constructor(Scheme?: any);
  fdInit(
      process: GeneralizedBlackScholesProcess, timeSteps?: Size,
      gridPoints?: Size, timeDependent?: boolean): FDShoutEngine;
  Scheme: any;
}

export declare class FdSimpleBSSwingEngine extends
    GenericEngine<VanillaSwingOption.Arguments, VanillaSwingOption.Results> {
  constructor(
      process: GeneralizedBlackScholesProcess, tGrid?: Size, xGrid?: Size,
      schemeDesc?: FdmSchemeDesc);
  calculate(): void;
  private _process;
  private _tGrid;
  private _xGrid;
  private _schemeDesc;
}

export declare class FDStepConditionEngine extends FDVanillaEngine {
  protected _stepCondition: StandardStepCondition;
  protected _prices: SampledCurve;
  protected _controlOperator: TridiagonalOperator;
}

export declare class FDVanillaEngine {
  init(
      process: GeneralizedBlackScholesProcess, timeSteps: Size,
      gridPoints: Size, timeDependent?: boolean): FDVanillaEngine;
  grid(): Real[];
  setupArguments(a: PricingEngine.Arguments): void;
  ensureStrikeInGrid(): void;
  setGridLimits1(): void;
  setGridLimits2(center: Real, t: Time): void;
  initializeInitialCondition(): void;
  initializeBoundaryConditions(): void;
  initializeOperator(): void;
  getResidualTime(): Time;
  _process: GeneralizedBlackScholesProcess;
  _timeSteps: Size;
  _gridPoints: Size;
  _timeDependent: boolean;
  _exerciseDate: Date;
  _payoff: Payoff;
  _finiteDifferenceOperator: TridiagonalOperator;
  _intrinsicValues: SampledCurve;
  _BCs: FDVanillaEngine.bc_type[];
  _sMin: Real;
  _center: Real;
  _sMax: Real;
  safeGridPoints(gridPoints: Size, residualTime: Time): Size;
  static _safetyZoneFactor: Real;
}
export declare namespace FDVanillaEngine {
  type bc_type = BoundaryCondition<TridiagonalOperator>;
}
export declare class FDEngineAdapter extends
    GenericEngine<PricingEngine.Arguments, PricingEngine.Results> {
  constructor(base: FDVanillaEngine, engine: PricingEngine);
  init(
      process: GeneralizedBlackScholesProcess, timeSteps?: Size,
      gridPoints?: Size, timeDependent?: boolean): FDEngineAdapter;
  calculate(): void;
  base: FDVanillaEngine;
  engine: PricingEngine;
}

export declare class HestonExpansionEngine extends GenericModelEngine<
    HestonModel, VanillaOptionEngine.Arguments, VanillaOptionEngine.Results> {
  constructor(
      model: HestonModel,
      formula: HestonExpansionEngine.HestonExpansionFormula);
  calculate(): void;
  private _formula;
}
export declare namespace HestonExpansionEngine {
  enum HestonExpansionFormula { LPP2 = 0, LPP3 = 1, Forde = 2 }
}
export declare class HestonExpansion {
  impliedVolatility(strike: Real, forward: Real): Real;
}
export declare class LPP2HestonExpansion extends HestonExpansion {
  constructor(
      kappa: Real, theta: Real, sigma: Real, v0: Real, rho: Real, term: Real);
  impliedVolatility(strike: Real, forward: Real): Real;
  private z0;
  private z1;
  private z2;
  private coeffs;
  private ekt;
  private e2kt;
  private e3kt;
  e4kt: Real;
}
export declare class LPP3HestonExpansion extends HestonExpansion {
  constructor(
      kappa: Real, theta: Real, sigma: Real, v0: Real, rho: Real, term: Real);
  impliedVolatility(strike: Real, forward: Real): Real;
  private z0;
  private z1;
  private z2;
  private z3;
  private coeffs;
  private ekt;
  private e2kt;
  private e3kt;
  private e4kt;
}
export declare class FordeHestonExpansion extends HestonExpansion {
  constructor(
      kappa: Real, theta: Real, sigma: Real, v0: Real, rho: Real, term: Real);
  impliedVolatility(strike: Real, forward: Real): Real;
  private coeffs;
}

export declare class IntegralEngine extends VanillaOption.engine {
  constructor(process: GeneralizedBlackScholesProcess);
}

export declare class JumpDiffusionEngine extends VanillaOptionEngine.engine {
  constructor(
      process: Merton76Process, relativeAccuracy?: Real, maxIterations?: Size);
  calculate(): void;
  private _process;
  private _relativeAccuracy;
  private _maxIterations;
}

export declare class JuQuadraticApproximationEngine extends
    VanillaOption.engine {
  constructor(process: GeneralizedBlackScholesProcess);
  calculate(): void;
  private _process;
}

export declare class MCAmericanEngine extends MCLongstaffSchwartzEngine {
  constructor(
      RNG?: MonteCarloModel.rng_traits, S?: any,
      RNG_Calibration?: MonteCarloModel.rng_traits);
  mcaeInit(
      process: GeneralizedBlackScholesProcess, timeSteps: Size,
      timeStepsPerYear: Size, antitheticVariate: boolean,
      controlVariate: boolean, requiredSamples: Size, requiredTolerance: Real,
      maxSamples: Size, seed: BigNatural, polynomOrder: Size,
      polynomType: LsmBasisSystem.PolynomType, nCalibrationSamples?: Size,
      antitheticVariateCalibration?: boolean,
      seedCalibration?: BigNatural): MCAmericanEngine;
  calculate(): void;
  lsmPathPricer(): LongstaffSchwartzPathPricer<Path>;
  controlVariateValue(): Real;
  controlPricingEngine(): PricingEngine;
  controlPathPricer(): PathPricer<Path>;
  private _polynomOrder;
  private _polynomType;
}
export declare class AmericanPathPricer extends
    EarlyExercisePathPricer<Path> implements BinaryFunction<Path, Size, Real> {
  constructor(
      payoff: Payoff, polynomOrder: Size,
      polynomType: LsmBasisSystem.PolynomType);
  state(path: Path, t: Size): Real;
  f(path: Path, t: Size): Real;
  basisSystem(): Array<UnaryFunction<Real, Real>>;
  protected payoff(state: Real): Real;
  protected _scalingValue: Real;
  protected _payoff: Payoff;
  protected _v: Array<UnaryFunction<Real, Real>>;
}
export declare class MakeMCAmericanEngine implements
    NullaryFunction<PricingEngine> {
  constructor(
      RNG?: MonteCarloModel.rng_traits, S?: any,
      RNG_Calibration?: MonteCarloModel.rng_traits);
  mmcaeInit(process: GeneralizedBlackScholesProcess): MakeMCAmericanEngine;
  withSteps(steps: Size): MakeMCAmericanEngine;
  withStepsPerYear(steps: Size): MakeMCAmericanEngine;
  withSamples(samples: Size): MakeMCAmericanEngine;
  withAbsoluteTolerance(tolerance: Real): MakeMCAmericanEngine;
  withMaxSamples(samples: Size): MakeMCAmericanEngine;
  withSeed(seed: BigNatural): MakeMCAmericanEngine;
  withAntitheticVariate(b?: boolean): MakeMCAmericanEngine;
  withControlVariate(b?: boolean): MakeMCAmericanEngine;
  withPolynomOrder(polynomOrer: Size): MakeMCAmericanEngine;
  withBasisSystem(polynomType: LsmBasisSystem.PolynomType):
      MakeMCAmericanEngine;
  withCalibrationSamples(samples: Size): MakeMCAmericanEngine;
  withAntitheticVariateCalibration(b?: boolean): MakeMCAmericanEngine;
  withSeedCalibration(seed: BigNatural): MakeMCAmericanEngine;
  f(): PricingEngine;
  RNG: MonteCarloModel.rng_traits;
  S: any;
  RNG_Calibration: MonteCarloModel.rng_traits;
  private _process;
  private _antithetic;
  private _controlVariate;
  private _steps;
  private _stepsPerYear;
  private _samples;
  private _maxSamples;
  private _calibrationSamples;
  private _tolerance;
  private _seed;
  private _polynomOrder;
  private _polynomType;
  private _antitheticCalibration;
  private _seedCalibration;
}

export declare class MCDigitalEngine extends MCVanillaEngine {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  mcdeInit(
      process: GeneralizedBlackScholesProcess, timeSteps: Size,
      timeStepsPerYear: Size, brownianBridge: boolean,
      antitheticVariate: boolean, requiredSamples: Size,
      requiredTolerance: Real, maxSamples: Size,
      seed: BigNatural): MCDigitalEngine;
  pathPricer(): PathPricer<Path>;
}
export declare class MakeMCDigitalEngine implements
    NullaryFunction<PricingEngine> {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  mmcdeInit(process: GeneralizedBlackScholesProcess): MakeMCDigitalEngine;
  withSteps(steps: Size): MakeMCDigitalEngine;
  withStepsPerYear(steps: Size): MakeMCDigitalEngine;
  withBrownianBridge(b?: boolean): MakeMCDigitalEngine;
  withSamples(samples: Size): MakeMCDigitalEngine;
  withAbsoluteTolerance(tolerance: Real): MakeMCDigitalEngine;
  withMaxSamples(samples: Size): MakeMCDigitalEngine;
  withSeed(seed: BigNatural): MakeMCDigitalEngine;
  withAntitheticVariate(b?: boolean): MakeMCDigitalEngine;
  f(): PricingEngine;
  RNG: MonteCarloModel.rng_traits;
  S: any;
  private _process;
  private _antithetic;
  private _steps;
  private _stepsPerYear;
  private _samples;
  private _maxSamples;
  private _tolerance;
  private _brownianBridge;
  private _seed;
}

export declare class MCEuropeanEngine extends MCVanillaEngine {
  constructor(
      process: GeneralizedBlackScholesProcess, timeSteps: Size,
      timeStepsPerYear: Size, brownianBridge: boolean,
      antitheticVariate: boolean, requiredSamples: Size,
      requiredTolerance: Real, maxSamples: Size, seed: BigNatural);
  pathPricer(): PathPricer<Path|MultiPath>;
}
export declare class MakeMCEuropeanEngine implements
    NullaryFunction<PricingEngine> {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  mmceeInit(process: GeneralizedBlackScholesProcess): MakeMCEuropeanEngine;
  withSteps(steps: Size): MakeMCEuropeanEngine;
  withStepsPerYear(steps: Size): MakeMCEuropeanEngine;
  withBrownianBridge(b?: boolean): MakeMCEuropeanEngine;
  withSamples(samples: Size): MakeMCEuropeanEngine;
  withAbsoluteTolerance(tolerance: Real): MakeMCEuropeanEngine;
  withMaxSamples(samples: Size): MakeMCEuropeanEngine;
  withSeed(seed: BigNatural): MakeMCEuropeanEngine;
  withAntitheticVariate(b?: boolean): MakeMCEuropeanEngine;
  f(): PricingEngine;
  RNG: MonteCarloModel.rng_traits;
  S: any;
  private _process;
  private _antithetic;
  private _steps;
  private _stepsPerYear;
  private _samples;
  private _maxSamples;
  private _tolerance;
  private _brownianBridge;
  private _seed;
}
export declare class EuropeanPathPricer extends PathPricer<Path> implements
    UnaryFunction<Path, Real> {
  constructor(type: Option.Type, strike: Real, discount: DiscountFactor);
  f(path: Path): Real;
  private _payoff;
  private _discount;
}

export declare class MCEuropeanGJRGARCHEngine extends MCVanillaEngine {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  mcegeInit(
      process: GJRGARCHProcess, timeSteps: Size, timeStepsPerYear: Size,
      antitheticVariate: boolean, requiredSamples: Size,
      requiredTolerance: Real, maxSamples: Size,
      seed: BigNatural): MCEuropeanGJRGARCHEngine;
  pathPricer(): PathPricer;
}
export declare class MakeMCEuropeanGJRGARCHEngine {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  mmcegeInit(process: GJRGARCHProcess): MakeMCEuropeanGJRGARCHEngine;
  withSteps(steps: Size): MakeMCEuropeanGJRGARCHEngine;
  withStepsPerYear(steps: Size): MakeMCEuropeanGJRGARCHEngine;
  withSamples(samples: Size): MakeMCEuropeanGJRGARCHEngine;
  withAbsoluteTolerance(tolerance: Real): MakeMCEuropeanGJRGARCHEngine;
  withMaxSamples(samples: Size): MakeMCEuropeanGJRGARCHEngine;
  withSeed(seed: BigNatural): MakeMCEuropeanGJRGARCHEngine;
  withAntitheticVariate(b?: boolean): MakeMCEuropeanGJRGARCHEngine;
  f(): MCEuropeanGJRGARCHEngine;
  RNG: MonteCarloModel.rng_traits;
  S: any;
  private _process;
  private _antithetic;
  private _steps;
  private _stepsPerYear;
  private _samples;
  private _maxSamples;
  private _tolerance;
  private _seed;
}
export declare class EuropeanGJRGARCHPathPricer extends PathPricer {
  constructor(type: Option.Type, strike: Real, discount: DiscountFactor);
  f(multiPath: MultiPath): Real;
  private _payoff;
  private _discount;
}

export declare class MCEuropeanHestonEngine extends MCVanillaEngine {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  mceheInit(
      process: HestonProcess, timeSteps: Size, timeStepsPerYear: Size,
      antitheticVariate: boolean, requiredSamples: Size,
      requiredTolerance: Real, maxSamples: Size,
      seed: BigNatural): MCEuropeanHestonEngine;
  pathPricer(): PathPricer<MultiPath>;
  RNG: MonteCarloModel.rng_traits;
  S: any;
}
export declare class MakeMCEuropeanHestonEngine implements
    NullaryFunction<PricingEngine> {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  mmceheInit(process: HestonProcess): MakeMCEuropeanHestonEngine;
  withSteps(steps: Size): MakeMCEuropeanHestonEngine;
  withStepsPerYear(steps: Size): MakeMCEuropeanHestonEngine;
  withSamples(samples: Size): MakeMCEuropeanHestonEngine;
  withAbsoluteTolerance(tolerance: Real): MakeMCEuropeanHestonEngine;
  withMaxSamples(samples: Size): MakeMCEuropeanHestonEngine;
  withSeed(seed: BigNatural): MakeMCEuropeanHestonEngine;
  withAntitheticVariate(b?: boolean): MakeMCEuropeanHestonEngine;
  f(): PricingEngine;
  RNG: MonteCarloModel.rng_traits;
  S: any;
  private _process;
  private _antithetic;
  private _steps;
  private _stepsPerYear;
  private _samples;
  private _maxSamples;
  private _tolerance;
  private _seed;
}
export declare class EuropeanHestonPathPricer extends PathPricer<MultiPath> {
  constructor(type: Option.Type, strike: Real, discount: DiscountFactor);
  f(multiPath: MultiPath): Real;
  private _payoff;
  private _discount;
}

export declare class MCHestonHullWhiteEngine extends MCVanillaEngine {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  mchhweInit(
      process: HybridHestonHullWhiteProcess, timeSteps: Size,
      timeStepsPerYear: Size, antitheticVariate: boolean,
      controlVariate: boolean, requiredSamples: Size, requiredTolerance: Real,
      maxSamples: Size, seed: BigNatural): MCHestonHullWhiteEngine;
}
export declare class MakeMCHestonHullWhiteEngine {
  constructor(RNG?: MonteCarloModel.rng_traits, S?: any);
  mmchhweInit(process: HybridHestonHullWhiteProcess):
      MakeMCHestonHullWhiteEngine;
  withSteps(steps: Size): MakeMCHestonHullWhiteEngine;
  withStepsPerYear(steps: Size): MakeMCHestonHullWhiteEngine;
  withSamples(samples: Size): MakeMCHestonHullWhiteEngine;
  withAbsoluteTolerance(tolerance: Real): MakeMCHestonHullWhiteEngine;
  withMaxSamples(samples: Size): MakeMCHestonHullWhiteEngine;
  withSeed(seed: BigNatural): MakeMCHestonHullWhiteEngine;
  withAntitheticVariate(b?: boolean): MakeMCHestonHullWhiteEngine;
  withControlVariate(b?: boolean): MakeMCHestonHullWhiteEngine;
  f(): PricingEngine;
  RNG: MonteCarloModel.rng_traits;
  S: any;
  private _process;
  private _steps;
  private _stepsPerYear;
  private _samples;
  private _maxSamples;
  private _antithetic;
  private _controlVariate;
  private _tolerance;
  private _seed;
}

export declare class MCVanillaEngine extends VanillaOptionEngineMcSimulation {
  mcveInit(
      process: StochasticProcess, timeSteps: Size, timeStepsPerYear: Size,
      brownianBridge: boolean, antitheticVariate: boolean,
      controlVariate: boolean, requiredSamples: Size, requiredTolerance: Real,
      maxSamples: Size, seed: BigNatural): MCVanillaEngine;
  calculate(): void;
  timeGrid(): TimeGrid;
  pathGenerator(): PathGenerator;
  controlVariateValue(): Real;
  _process: StochasticProcess;
  _timeSteps: Size;
  _timeStepsPerYear: Size;
  _requiredSamples: Size;
  _maxSamples: Size;
  _requiredTolerance: Real;
  _brownianBridge: boolean;
  _seed: BigNatural;
}

export declare class ASX {
  static isASXdate(date: Date, mainCycle?: boolean): boolean;
  static isASXcode(code: string, mainCycle?: boolean): boolean;
  static code(date: Date): string;
  static date(asxCode: string, refDate?: Date): Date;
  static nextDate1(date?: Date, mainCycle?: boolean): Date;
  static nextDate2(ASXcode: string, mainCycle?: boolean, referenceDate?: Date):
      Date;
  static nextCode1(d?: Date, mainCycle?: boolean): string;
  static nextCode2(asxCode: string, mainCycle?: boolean, referenceDate?: Date):
      string;
}
export declare namespace ASX {
  enum Month {
    F = 1,
    G = 2,
    H = 3,
    J = 4,
    K = 5,
    M = 6,
    N = 7,
    Q = 8,
    U = 9,
    V = 10,
    X = 11,
    Z = 12
  }
}

export declare enum BusinessDayConvention {
  Following = 0,
  ModifiedFollowing = 1,
  Preceding = 2,
  ModifiedPreceding = 3,
  Unadjusted = 4,
  HalfMonthModifiedFollowing = 5,
  Nearest = 6
}

export declare class Calendar {
  constructor();
  empty(): boolean;
  name(): string;
  isBusinessDay(d: Date): boolean;
  isHoliday(d: Date): boolean;
  isWeekend(w: Weekday): boolean;
  isEndOfMonth(d: Date): boolean;
  endOfMonth(d: Date): Date;
  addHoliday(d: Date): void;
  removeHoliday(d: Date): void;
  adjust(d: Date, c?: BusinessDayConvention): Date;
  advance1(
      d: Date, n: Integer, unit: TimeUnit, c?: BusinessDayConvention,
      endOfMonth?: boolean): Date;
  advance2(d: Date, p: Period, c?: BusinessDayConvention, endOfMonth?: boolean):
      Date;
  businessDaysBetween(
      from: Date, to: Date, includeFirst?: boolean, includeLast?: boolean): Day;
  static holidayList(
      calendar: Calendar, from: Date, to: Date,
      includeWeekEnds?: boolean): Date[];
  readonly isDisposed: boolean;
  dispose(): void;
  protected _impl: Calendar.Impl;
  private _isDisposed;
}
export declare namespace Calendar {
  function equal(c1: Calendar, c2: Calendar): boolean;
  class Impl {
    constructor(...args: any[]);
    name(): string;
    isBusinessDay(d: Date): boolean;
    isWeekend(w: Weekday): boolean;
    readonly isDisposed: boolean;
    dispose(): void;
    addedHolidays: Set<Natural>;
    removedHolidays: Set<Natural>;
    private _isDisposed;
  }
  class WesternImpl extends Impl {
    static easterMonday(y: Year): Day;
    isWeekend(w: Weekday): boolean;
  }
  class OrthodoxImpl extends Impl {
    static easterMonday(y: Year): Day;
    isWeekend(w: Weekday): boolean;
  }
}

export declare enum Month {
  January = 1,
  February = 2,
  March = 3,
  April = 4,
  May = 5,
  June = 6,
  July = 7,
  August = 8,
  September = 9,
  October = 10,
  November = 11,
  December = 12,
  Jan = 1,
  Feb = 2,
  Mar = 3,
  Apr = 4,
  Jun = 6,
  Jul = 7,
  Aug = 8,
  Sep = 9,
  Oct = 10,
  Nov = 11,
  Dec = 12
}
export declare type Day = number;
export declare type Year = number;
export declare type Hour = number;
export declare type Minute = number;
export declare type Second = number;
export declare type Millisecond = number;
export declare type Microsecond = number;
export declare const OneDay: number;
export declare namespace DateExt {
  function UTC(date?: string|number): Date;
  function max(d1: Date, d2: Date): Date;
  function min(d1: Date, d2: Date): Date;
  function weekday(d: Date): number;
  function dayOfMonth(d: Date): number;
  function dayOfYear(d: Date): Day;
  function day(d: Date): Day;
  function month(d: Date): Month;
  function year(d: Date): Year;
  function serialNumber(d: Date): number;
  function hours(d: Date): Hour;
  function minutes(d: Date): Minute;
  function seconds(d: Date): Second;
  function milliseconds(d: Date): Millisecond;
  function fractionOfDay(d: Date): number;
  function fractionOfSecond(d: Date): number;
  function dateTime(d: Date): number;
  function add(d: Date, n: Day): Date;
  function sub(d: Date, n: Day): Date;
  function adda(d: Date, n: Day): Date;
  function suba(d: Date, n: Day): Date;
  function equal(d1: Date, d2: Date): boolean;
  function isLeap(y: Year): boolean;
  function endOfMonth(d: Date): Date;
  function isEndOfMonth(d: Date): boolean;
  function nextWeekday(d: Date, dayOfWeek: number): Date;
  function nthWeekday(nth: number, dayOfWeek: number, m: Month, y: Year): Date;
  function localDateTime(): Date;
  function universalDateTime(): Date;
  function ticksPerSecond(): number;
  function minimumSerialNumber(): number;
  function maximumSerialNumber(): number;
  function checkSerialNumber(serialNumber: number): void;
  function minDate(): Date;
  function maxDate(): Date;
  function todaysDate(): Date;
  function advance(date: Date, n: Integer, unites: TimeUnit): Date;
  function monthLength(m: Month, leapYear: boolean): Size;
  function monthOffset(m: Month, leapYear: boolean): Size;
  function yearOffset(y: Year): Size;
  function fromSerial(serial: number): Date;
  function fromDate(d: Date): Date;
  function fromString(s: string): Date;
  function daysBetween(d1: Date, d2: Date): Day;
  function time(): Time;
  function addPeriod(d: Date, p: Period): Date;
  function subPeriod(d: Date, p: Period): Date;
}

export declare namespace DateGeneration {
  enum Rule {
    Backward = 0,
    Forward = 1,
    Zero = 2,
    ThirdWednesday = 3,
    Twentieth = 4,
    TwentiethIMM = 5,
    OldCDS = 6,
    CDS = 7,
    CDS2015 = 8
  }
}

export declare class DayCounter {
  empty(): boolean;
  name(): string;
  dayCount(d1: Date, d2: Date): number;
  yearFraction(d1: Date, d2: Date, refPeriodStart?: Date, refPeriodEnd?: Date):
      Time;
  readonly isDisposed: boolean;
  dispose(): void;
  private _isDisposed;
  protected _impl: DayCounter.Impl;
}
export declare namespace DayCounter {
  class Impl {
    constructor(...args: any[]);
    name(): string;
    dayCount(d1: Date, d2: Date): number;
    yearFraction(d1: Date, d2: Date, refPeriodStart: Date, refPeriodEnd: Date):
        Time;
    readonly isDisposed: boolean;
    dispose(): void;
    private _isDisposed;
  }
  function equal(d1: DayCounter, d2: DayCounter): boolean;
}

export declare class ECB {
  static knownDateSet: Set<number>;
  static knownDates(): Set<Date>;
  static addDate(d: Date): void;
  static removeDate(d: Date): void;
  static date1(m: Month, y: Year): Date;
  static date2(ecbCode: string, refDate: Date): Date;
  static code(ecbDate: Date): string;
  static nextDate1(date?: Date): Date;
  static nextDate2(ecbCode: string, referenceDate?: Date): Date;
  static nextDates1(date?: Date): Date[];
  static nextDates2(ecbCode: string, referenceDate?: Date): Date[];
  static isECBdate(d: Date): boolean;
  static isECBcode(ecbCode: string): boolean;
  static nextCode1(d?: Date): string;
  static nextCode2(ecbCode: string): string;
}
export declare namespace ECB {
  const knownDatesArray: Integer[];
}

export declare enum Frequency {
  NoFrequency = -1,
  Once = 0,
  Annual = 1,
  Semiannual = 2,
  EveryFourthMonth = 3,
  Quarterly = 4,
  Bimonthly = 6,
  Monthly = 12,
  EveryFourthWeek = 13,
  Biweekly = 26,
  Weekly = 52,
  Daily = 365,
  OtherFrequency = 999
}

export declare class IMM {
  static isIMMdate(date: Date, mainCycle?: boolean): boolean;
  static isIMMcode(code: string, mainCycle?: boolean): boolean;
  static code(date: Date): string;
  static date(immCode: string, refDate?: Date): Date;
  static nextDate1(date?: Date, mainCycle?: boolean): Date;
  static nextDate2(IMMcode: string, mainCycle?: boolean, referenceDate?: Date):
      Date;
  static nextCode1(d?: Date, mainCycle?: boolean): string;
  static nextCode2(immCode: string, mainCycle?: boolean, referenceDate?: Date):
      string;
}
export declare namespace IMM {
  enum Month {
    F = 1,
    G = 2,
    H = 3,
    J = 4,
    K = 5,
    M = 6,
    N = 7,
    Q = 8,
    U = 9,
    V = 10,
    X = 11,
    Z = 12
  }
}

export declare class Period {
  constructor();
  init1(n: Integer, units: TimeUnit): Period;
  init2(frequency: Frequency): Period;
  length(): Integer;
  units(): TimeUnit;
  frequency(): Frequency;
  normalize(): void;
  toString(): string;
  adda(p: Period): void;
  suba(p: Period): void;
  add(p: Period): Period;
  sub(p: Period): Period;
  diva(n: Integer): Period;
  div(n: Integer): Period;
  private _length;
  private _units;
}
export declare namespace Period {
  function daysMinMax(p: Period): [Integer, Integer];
  function years(p: Period): Real;
  function months(p: Period): Real;
  function weeks(p: Period): Real;
  function days(p: Period): Real;
  function lessThan(p1: Period, p2: Period): boolean;
  function greaterThan(p1: Period, p2: Period): boolean;
  function equal(p1: Period, p2: Period): boolean;
  function notEqual(p1: Period, p2: Period): boolean;
  function lessOrEqual(p1: Period, p2: Period): boolean;
  function greaterOrEqual(p1: Period, p2: Period): boolean;
  function mulScalar(p: Period, n: Integer): Period;
}

export declare class Schedule {
  init1(
      dates: Date[], calendar?: Calendar, convention?: BusinessDayConvention,
      terminationDateConvention?: BusinessDayConvention, tenor?: Period,
      rule?: DateGeneration.Rule, endOfMonth?: boolean,
      isRegular?: boolean[]): Schedule;
  init2(
      effectiveDate: Date, terminationDate: Date, tenor: Period, cal: Calendar,
      convention: BusinessDayConvention,
      terminationDateConvention: BusinessDayConvention,
      rule: DateGeneration.Rule, endOfMonth: boolean, first?: Date,
      nextToLast?: Date): Schedule;
  size(): Size;
  date(i: Size): Date;
  previousDate(refDate: Date): Date;
  nextDate(refDate: Date): Date;
  dates(): Date[];
  hasIsRegular(): boolean;
  isRegular1(i: Size): boolean;
  isRegular2(): boolean[];
  empty(): boolean;
  calendar(): Calendar;
  startDate(): Date;
  endDate(): Date;
  hasTenor(): boolean;
  tenor(): Period;
  businessDayConvention(): BusinessDayConvention;
  hasTerminationDateBusinessDayConvention(): boolean;
  terminationDateBusinessDayConvention(): BusinessDayConvention;
  hasRule(): boolean;
  rule(): DateGeneration.Rule;
  hasEndOfMonth(): boolean;
  endOfMonth(): boolean;
  until(truncationDate: Date): Schedule;
  lower_bound(refDate: Date): Date;
  private _tenor;
  private _calendar;
  private _convention;
  private _terminationDateConvention;
  private _rule;
  private _endOfMonth;
  private _firstDate;
  private _nextToLastDate;
  private _dates;
  private _isRegular;
}
export declare class MakeSchedule implements NullaryFunction<Schedule> {
  constructor();
  from(effectiveDate: Date): MakeSchedule;
  to(terminationDate: Date): MakeSchedule;
  withTenor(tenor: Period): MakeSchedule;
  withFrequency(frequency: Frequency): MakeSchedule;
  withCalendar(calendar: Calendar): MakeSchedule;
  withConvention(convention: BusinessDayConvention): MakeSchedule;
  withTerminationDateConvention(terminationDateConvention:
                                    BusinessDayConvention): MakeSchedule;
  withRule(rule: DateGeneration.Rule): MakeSchedule;
  forwards(): MakeSchedule;
  backwards(): MakeSchedule;
  endOfMonth(flag?: boolean): MakeSchedule;
  withFirstDate(d: Date): MakeSchedule;
  withNextToLastDate(d: Date): MakeSchedule;
  f(): Schedule;
  private _calendar;
  private _effectiveDate;
  private _terminationDate;
  private _tenor;
  private _convention;
  private _terminationDateConvention;
  private _rule;
  private _endOfMonth;
  private _firstDate;
  private _nextToLastDate;
}

export declare enum TimeUnit {
  Days = 0,
  Weeks = 1,
  Months = 2,
  Years = 3,
  Hours = 4,
  Minutes = 5,
  Seconds = 6,
  Milliseconds = 7
}

export declare enum Weekday {
  Sunday = 1,
  Monday = 2,
  Tuesday = 3,
  Wednesday = 4,
  Thursday = 5,
  Friday = 6,
  Saturday = 7,
  Sun = 1,
  Mon = 2,
  Tue = 3,
  Wed = 4,
  Thu = 5,
  Fri = 6,
  Sat = 7
}

export declare class Argentina extends Calendar {
  constructor(market?: Argentina.Market);
  static impl: Argentina.MervalImpl;
}
export declare namespace Argentina {
  enum Market { Merval = 0 }
  class MervalImpl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class Australia extends Calendar {
  constructor();
  static impl: Australia.Impl;
}
export declare namespace Australia {
  class Impl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class BespokeCalendar extends Calendar {
  constructor(name?: string);
  addWeekend(wd: Weekday): void;
  private _bespokeImpl;
}
export declare namespace BespokeCalendar {
  class Impl extends Calendar.Impl {
    constructor(name?: string);
    name(): string;
    isWeekend(w: Weekday): boolean;
    isBusinessDay(d: Date): boolean;
    addWeekend(wd: Weekday): void;
    private _weekend;
    private _name;
  }
}

export declare class Botswana extends Calendar {
  constructor();
  static impl: Botswana.Impl;
}
export declare namespace Botswana {
  class Impl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class Brazil extends Calendar {
  constructor(market?: Brazil.Market);
  static settlementImpl: Brazil.SettlementImpl;
  static exchangeImpl: Brazil.ExchangeImpl;
}
export declare namespace Brazil {
  enum Market { Settlement = 0, Exchange = 1 }
  class SettlementImpl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
  class ExchangeImpl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class Canada extends Calendar {
  constructor(market?: Canada.Market);
  static settlementImpl: Canada.SettlementImpl;
  static tsxImpl: Canada.TsxImpl;
}
export declare namespace Canada {
  enum Market { Settlement = 0, TSX = 1 }
  class SettlementImpl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
  class TsxImpl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class CzechRepublic extends Calendar {
  constructor(market?: CzechRepublic.Market);
  static impl: CzechRepublic.PseImpl;
}
export declare namespace CzechRepublic {
  enum Market { PSE = 0 }
  class PseImpl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class China extends Calendar {
  constructor(market?: China.Market);
  static sseImpl: China.SseImpl;
  static hkexImpl: China.HkexImpl;
  static tsecImpl: China.TsecImpl;
  static IBImpl: China.IbImpl;
}
export declare namespace China {
  enum Market { SSE = 0, HKEx = 1, TSEC = 2, IB = 3 }
  class SseImpl extends Calendar.Impl {
    name(): string;
    isWeekend(w: Weekday): boolean;
    isBusinessDay(date: Date): boolean;
  }
  class HkexImpl extends Calendar.WesternImpl {
    name(): string;
    isWeekend(w: Weekday): boolean;
    isBusinessDay(date: Date): boolean;
  }
  class TsecImpl extends Calendar.Impl {
    name(): string;
    isWeekend(w: Weekday): boolean;
    isBusinessDay(date: Date): boolean;
  }
  class IbImpl extends Calendar.Impl {
    name(): string;
    isWeekend(w: Weekday): boolean;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class Denmark extends Calendar {
  constructor();
  static impl: Denmark.Impl;
}
export declare namespace Denmark {
  class Impl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class Finland extends Calendar {
  constructor();
  static impl: Finland.Impl;
}
export declare namespace Finland {
  class Impl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class Germany extends Calendar {
  constructor(market?: Germany.Market);
  static settlementImpl: Germany.SettlementImpl;
  static frankfurtStockExchangeImpl: Germany.FrankfurtStockExchangeImpl;
  static xetraImpl: Germany.XetraImpl;
  static eurexImpl: Germany.EurexImpl;
  static euwaxImpl: Germany.EuwaxImpl;
}
export declare namespace Germany {
  enum Market {
    Settlement = 0,
    FrankfurtStockExchange = 1,
    Xetra = 2,
    Eurex = 3,
    Euwax = 4
  }
  class SettlementImpl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
  class FrankfurtStockExchangeImpl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
  class XetraImpl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
  class EurexImpl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
  class EuwaxImpl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class Hungary extends Calendar {
  constructor();
  static impl: Hungary.Impl;
}
export declare namespace Hungary {
  class Impl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class Iceland extends Calendar {
  constructor(market?: Iceland.Market);
  static impl: Iceland.Impl;
}
export declare namespace Iceland {
  enum Market { ICEX = 0 }
  class Impl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class India extends Calendar {
  constructor(market?: India.Market);
  static impl: India.NseImpl;
}
export declare namespace India {
  enum Market { NSE = 0 }
  class NseImpl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class Indonesia extends Calendar {
  constructor(market?: Indonesia.Market);
  static impl: Indonesia.BejImpl;
}
export declare namespace Indonesia {
  enum Market { BEJ = 0, JSX = 1, IDX = 2 }
  class BejImpl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class Israel extends Calendar {
  constructor(market?: Israel.Market);
  static settlementImpl: Israel.TelAvivImpl;
  static telAvivImpl: Israel.TelAvivImpl;
}
export declare namespace Israel {
  enum Market { Settlement = 0, TASE = 1 }
  class TelAvivImpl extends Calendar.Impl {
    name(): string;
    isWeekend(w: Weekday): boolean;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class Italy extends Calendar {
  constructor(market?: Italy.Market);
  static settlementImpl: Italy.SettlementImpl;
  static exchangeImpl: Italy.ExchangeImpl;
}
export declare namespace Italy {
  enum Market { Settlement = 0, Exchange = 1 }
  class SettlementImpl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
  class ExchangeImpl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class JointCalendar extends Calendar {
  constructor(
      c1: Calendar, c2: Calendar, c3?: Calendar, c4?: Calendar,
      r?: JointCalendar.JointCalendarRule);
}
export declare namespace JointCalendar {
  enum JointCalendarRule { JoinHolidays = 0, JoinBusinessDays = 1 }
  class Impl extends Calendar.Impl {
    constructor(
        c1: Calendar, c2: Calendar, c3: Calendar, c4: Calendar,
        r: JointCalendarRule);
    name(): string;
    isWeekend(w: Weekday): boolean;
    isBusinessDay(date: Date): boolean;
    private _rule;
    private _calendars;
  }
}

export declare class Japan extends Calendar {
  constructor();
  static impl: Japan.Impl;
}
export declare namespace Japan {
  class Impl extends Calendar.Impl {
    name(): string;
    isWeekend(w: Weekday): boolean;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class NewZealand extends Calendar {
  constructor();
  static impl: NewZealand.Impl;
}
export declare namespace NewZealand {
  class Impl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class Mexico extends Calendar {
  constructor(market?: Mexico.Market);
  static impl: Mexico.BmvImpl;
}
export declare namespace Mexico {
  enum Market { BMV = 0 }
  class BmvImpl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class Norway extends Calendar {
  constructor();
  static impl: Norway.Impl;
}
export declare namespace Norway {
  class Impl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class NullCalendar extends Calendar {
  constructor();
}
export declare namespace NullCalendar {
  class Impl extends Calendar.Impl {
    name(): string;
    isWeekend(w: Weekday): boolean;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class Romania extends Calendar {
  constructor();
  static impl: Romania.Impl;
}
export declare namespace Romania {
  class Impl extends Calendar.OrthodoxImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class Poland extends Calendar {
  constructor();
  static impl: Poland.Impl;
}
export declare namespace Poland {
  class Impl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class SaudiArabia extends Calendar {
  constructor(market?: SaudiArabia.Market);
  static tadawulImpl: SaudiArabia.TadawulImpl;
}
export declare namespace SaudiArabia {
  enum Market { Tadawul = 0 }
  class TadawulImpl extends Calendar.Impl {
    name(): string;
    isWeekend(w: Weekday): boolean;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class Russia extends Calendar {
  constructor(market?: Russia.Market);
  static settlementImpl: Russia.SettlementImpl;
  static exchangeImpl: Russia.ExchangeImpl;
}
export declare namespace Russia {
  enum Market { Settlement = 0, MOEX = 1 }
  class SettlementImpl extends Calendar.OrthodoxImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
  class ExchangeImpl extends Calendar.OrthodoxImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class Singapore extends Calendar {
  constructor(market?: Singapore.Market);
  static impl: Singapore.SgxImpl;
}
export declare namespace Singapore {
  enum Market { SGX = 0 }
  class SgxImpl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class Slovakia extends Calendar {
  constructor(market?: Slovakia.Market);
  static impl: Slovakia.BsseImpl;
}
export declare namespace Slovakia {
  enum Market { BSSE = 0 }
  class BsseImpl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class SouthAfrica extends Calendar {
  constructor();
  static impl: SouthAfrica.Impl;
}
export declare namespace SouthAfrica {
  class Impl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class SouthKorea extends Calendar {
  constructor(market?: SouthKorea.Market);
  static settlementImpl: SouthKorea.SettlementImpl;
  static krxImpl: SouthKorea.KrxImpl;
}
export declare namespace SouthKorea {
  enum Market { Settlement = 0, KRX = 1 }
  class SettlementImpl extends Calendar.Impl {
    name(): string;
    isWeekend(w: Weekday): boolean;
    isBusinessDay(date: Date): boolean;
  }
  class KrxImpl extends SettlementImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class Sweden extends Calendar {
  constructor();
  static impl: Sweden.Impl;
}
export declare namespace Sweden {
  class Impl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class Switzerland extends Calendar {
  constructor();
  static impl: Switzerland.Impl;
}
export declare namespace Switzerland {
  class Impl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class TARGET extends Calendar {
  constructor();
  static impl: TARGET.Impl;
}
export declare namespace TARGET {
  class Impl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class Thailand extends Calendar {
  constructor();
  static impl: Thailand.SetImpl;
}
export declare namespace Thailand {
  class SetImpl extends Calendar.WesternImpl {
    name(): string;
    isWeekend(w: Weekday): boolean;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class Turkey extends Calendar {
  constructor();
  static impl: Turkey.Impl;
}
export declare namespace Turkey {
  class Impl extends Calendar.Impl {
    name(): string;
    isWeekend(w: Weekday): boolean;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class Ukraine extends Calendar {
  constructor(market?: Ukraine.Market);
  static impl: Ukraine.UseImpl;
}
export declare namespace Ukraine {
  enum Market { USE = 0 }
  class UseImpl extends Calendar.OrthodoxImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class UnitedKingdom extends Calendar {
  constructor(market?: UnitedKingdom.Market);
  static settlementImpl: UnitedKingdom.SettlementImpl;
  static exchangeImpl: UnitedKingdom.ExchangeImpl;
  static metalsImpl: UnitedKingdom.MetalsImpl;
}
export declare namespace UnitedKingdom {
  enum Market { Settlement = 0, Exchange = 1, Metals = 2 }
  class SettlementImpl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
  class ExchangeImpl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
  class MetalsImpl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class UnitedStates extends Calendar {
  constructor(market?: UnitedStates.Market);
  static settlementImpl: UnitedStates.SettlementImpl;
  static liborImpactImpl: UnitedStates.LiborImpactImpl;
  static nyseImpl: UnitedStates.NyseImpl;
  static governmentImpl: UnitedStates.GovernmentBondImpl;
  static nercImpl: UnitedStates.NercImpl;
  static federalreserveImpl: UnitedStates.FederalReserveImpl;
}
export declare namespace UnitedStates {
  enum Market {
    Settlement = 0,
    NYSE = 1,
    GovernmentBond = 2,
    NERC = 3,
    LiborImpact = 4,
    FederalReserve = 5
  }
  class SettlementImpl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
  class LiborImpactImpl extends SettlementImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
  class NyseImpl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
  class GovernmentBondImpl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
  class NercImpl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
  class FederalReserveImpl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class WeekendsOnly extends Calendar {
  constructor();
  static impl: WeekendsOnly.Impl;
}
export declare namespace WeekendsOnly {
  class Impl extends Calendar.WesternImpl {
    name(): string;
    isBusinessDay(date: Date): boolean;
  }
}

export declare class Actual360 extends DayCounter {
  constructor(includeLastDay?: boolean);
}
export declare namespace Actual360 {
  class Impl extends DayCounter.Impl {
    constructor(includeLastDay: boolean);
    name(): string;
    dayCount(d1: Date, d2: Date): number;
    yearFraction(d1: Date, d2: Date, refPeriodStart: Date, refPeriodEnd: Date):
        Time;
    private _includeLastDay;
  }
}

export declare class Actual365Fixed extends DayCounter {
  constructor();
}
export declare namespace Actual365Fixed {
  enum Convention { Standard = 0, Canadian = 1, NoLeap = 2 }
  class Impl extends DayCounter.Impl {
    name(): string;
    yearFraction(d1: Date, d2: Date, refPeriodStart: Date, refPeriodEnd: Date):
        Time;
  }
}

export declare class Actual365NoLeap extends DayCounter {
  constructor();
}
export declare namespace Actual365NoLeap {
  class Impl extends DayCounter.Impl {
    name(): string;
    dayCount(d1: Date, d2: Date): number;
    yearFraction(d1: Date, d2: Date, refPeriodStart: Date, refPeriodEnd: Date):
        Time;
  }
}

export declare class Business252 extends DayCounter {
  constructor(c?: Calendar);
}
export declare namespace Business252 {
  class Impl extends DayCounter.Impl {
    constructor(c: Calendar);
    name(): string;
    dayCount(d1: Date, d2: Date): number;
    yearFraction(d1: Date, d2: Date, refPeriodStart: Date, refPeriodEnd: Date):
        Time;
    private _calendar;
  }
}

export declare class ActualActual extends DayCounter {
  constructor(c?: ActualActual.Convention, schedule?: Schedule);
  static implementation(c: ActualActual.Convention, schedule: Schedule):
      ActualActual.ISMA_Impl|ActualActual.ISDA_Impl|ActualActual.AFB_Impl;
}
export declare namespace ActualActual {
  enum Convention {
    ISMA = 0,
    Bond = 1,
    ISDA = 2,
    Historical = 3,
    Actual365 = 4,
    AFB = 5,
    Euro = 6
  }
  class ISMA_Impl extends DayCounter.Impl {
    constructor(schedule: Schedule);
    name(): string;
    yearFraction(d1: Date, d2: Date, d3: Date, d4: Date): Time;
    private _schedule;
  }
  class ISDA_Impl extends DayCounter.Impl {
    name(): string;
    yearFraction(d1: Date, d2: Date, refPeriodStart: Date, refPeriodEnd: Date):
        Time;
  }
  class AFB_Impl extends DayCounter.Impl {
    name(): string;
    yearFraction(d1: Date, d2: Date, refPeriodStart: Date, refPeriodEnd: Date):
        Time;
  }
}

export declare class OneDayCounter extends DayCounter {
  constructor();
}
export declare namespace OneDayCounter {
  class Impl extends DayCounter.Impl {
    name(): string;
    dayCount(d1: Date, d2: Date): number;
    yearFraction(d1: Date, d2: Date, refPeriodStart: Date, refPeriodEnd: Date):
        Time;
  }
}

export declare class SimpleDayCounter extends DayCounter {
  constructor();
}
export declare namespace SimpleDayCounter {
  class Impl extends DayCounter.Impl {
    name(): string;
    dayCount(d1: Date, d2: Date): number;
    yearFraction(d1: Date, d2: Date, refPeriodStart: Date, refPeriodEnd: Date):
        Time;
  }
}

export declare class Thirty360 extends DayCounter {
  constructor(c?: Thirty360.Convention);
  static implementation(c: Thirty360.Convention): DayCounter.Impl;
}
export declare namespace Thirty360 {
  enum Convention {
    USA = 0,
    BondBasis = 1,
    European = 2,
    EurobondBasis = 3,
    Italian = 4
  }
  class US_Impl extends DayCounter.Impl {
    name(): string;
    dayCount(d1: Date, d2: Date): number;
    yearFraction(d1: Date, d2: Date, refPeriodStart: Date, refPeriodEnd: Date):
        Time;
  }
  class EU_Impl extends DayCounter.Impl {
    name(): string;
    dayCount(d1: Date, d2: Date): number;
    yearFraction(d1: Date, d2: Date, refPeriodStart: Date, refPeriodEnd: Date):
        Time;
  }
  class IT_Impl extends DayCounter.Impl {
    name(): string;
    dayCount(d1: Date, d2: Date): number;
    yearFraction(d1: Date, d2: Date, refPeriodStart: Date, refPeriodEnd: Date):
        Time;
  }
}

export declare class BMAIndex extends InterestRateIndex {
  constructor(h?: Handle<YieldTermStructure>);
  name(): string;
  isValidFixingDate(date: Date): boolean;
  forwardingTermStructure(): Handle<YieldTermStructure>;
  maturityDate(valueDate: Date): Date;
  fixingSchedule(start: Date, end: Date): Schedule;
  forecastFixing(fixingDate: Date): Rate;
  protected _termStructure: Handle<YieldTermStructure>;
}

export declare class IborIndex extends InterestRateIndex {
  constructor(
      familyName: string, tenor: Period, settlementDays: Natural,
      currency: Currency, fixingCalendar: Calendar,
      convention: BusinessDayConvention, endOfMonth: boolean,
      dayCounter: DayCounter, h?: Handle<YieldTermStructure>);
  maturityDate(valueDate: Date): Date;
  forecastFixing1(fixingDate: Date): Rate;
  businessDayConvention(): BusinessDayConvention;
  endOfMonth(): boolean;
  forwardingTermStructure(): Handle<YieldTermStructure>;
  clone(h: Handle<YieldTermStructure>): IborIndex;
  forecastFixing2(d1: Date, d2: Date, t: Time): Rate;
  protected _convention: BusinessDayConvention;
  protected _termStructure: Handle<YieldTermStructure>;
  protected _endOfMonth: boolean;
}
export declare class OvernightIndex extends IborIndex {
  constructor(
      familyName: string, settlementDays: Natural, currency: Currency,
      fixingCalendar: Calendar, dayCounter: DayCounter,
      h: Handle<YieldTermStructure>);
  clone(h: Handle<YieldTermStructure>): OvernightIndex;
}

export declare namespace IndexManager {
  function hasHistory(name: string): boolean;
  function getHistory(name: string): TimeSeries<Real>;
  function setHistory(name: string, history: TimeSeries<Real>): void;
  function notifier(name: string): Observable;
  function histories(): string[];
  function clearHistory(name: string): void;
  function clearHistories(): void;
}

export declare class InflationIndex extends IndexObserver {
  constructor(
      familyName: string, region: Region, revised: boolean,
      interpolated: boolean, frequency: Frequency, availabilitiyLag: Period,
      currency: Currency);
  name(): string;
  fixingCalendar(): Calendar;
  isValidFixingDate(d: Date): boolean;
  fixing(fixingDate: Date, forecastTodaysFixing?: boolean): Rate;
  addFixing(fixingDate: Date, fixing: Rate, forceOverwrite?: boolean): void;
  update(): void;
  familyName(): string;
  region(): Region;
  revised(): boolean;
  interpolated(): boolean;
  frequency(): Frequency;
  availabilityLag(): Period;
  currency(): Currency;
  protected _referenceDate: Date;
  protected _familyName: string;
  protected _region: Region;
  protected _revised: boolean;
  protected _interpolated: boolean;
  protected _frequency: Frequency;
  protected _availabilityLag: Period;
  protected _currency: Currency;
  private _name;
}
export declare class ZeroInflationIndex extends InflationIndex {
  constructor(
      familyName: string, region: Region, revised: boolean,
      interpolated: boolean, frequency: Frequency, availabilityLag: Period,
      currency: Currency, zeroInflation?: Handle<ZeroInflationTermStructure>);
  fixing(aFixingDate: Date, forecastTodaysFixing?: boolean): Rate;
  zeroInflationTermStructure(): Handle<ZeroInflationTermStructure>;
  clone(h: Handle<ZeroInflationTermStructure>): ZeroInflationIndex;
  private needsForecast;
  private forecastFixing;
  private _zeroInflation;
}
export declare class YoYInflationIndex extends InflationIndex {
  constructor(
      familyName: string, region: Region, revised: boolean,
      interpolated: boolean, ratio: boolean, frequency: Frequency,
      availabilityLag: Period, currency: Currency,
      yoyInflation?: Handle<YoYInflationTermStructure>);
  fixing(fixingDate: Date, forecastTodaysFixing?: boolean): Rate;
  ratio(): boolean;
  yoyInflationTermStructure(): Handle<YoYInflationTermStructure>;
  clone(h: Handle<YoYInflationTermStructure>): YoYInflationIndex;
  private forecastFixing;
  private _ratio;
  private _yoyInflation;
}

export declare class InterestRateIndex extends IndexObserver {
  init(
      familyName: string, tenor: Period, fixingDays: Natural,
      currency: Currency, fixingCalendar: Calendar,
      dayCounter: DayCounter): InterestRateIndex;
  name(): string;
  fixingCalendar(): Calendar;
  isValidFixingDate(d: Date): boolean;
  fixing(fixingDate: Date, forecastTodaysFixing?: boolean): Rate;
  update(): void;
  familyName(): string;
  tenor(): Period;
  fixingDays(): Natural;
  fixingDate(valueDate: Date): Date;
  currency(): Currency;
  dayCounter(): DayCounter;
  valueDate(fixingDate: Date): Date;
  maturityDate(valueDate: Date): Date;
  forecastFixing1(fixingDate: Date): Rate;
  pastFixing(fixingDate: Date): Rate;
  protected _familyName: string;
  protected _tenor: Period;
  protected _fixingDays: Natural;
  protected _currency: Currency;
  protected _dayCounter: DayCounter;
  protected _name: string;
  private _fixingCalendar;
}

export declare class Region {
  name(): string;
  code(): string;
  protected _date: Region.Data;
}
export declare class CustomRegion extends Region {
  constructor(name: string, code: string);
}
export declare class ChinaRegion extends Region {
  constructor();
}
export declare class AustraliaRegion extends Region {
  constructor();
}
export declare class EURegion extends Region {
  constructor();
}
export declare class FranceRegion extends Region {
  constructor();
}
export declare class UKRegion extends Region {
  constructor();
}
export declare class USRegion extends Region {
  constructor();
}
export declare class ZARegion extends Region {
  constructor();
}
export declare namespace Region {
  class Data {
    constructor(name: string, code: string);
    name: string;
    code: string;
  }
}

export declare class SwapIndex extends InterestRateIndex {
  siInit(
      familyName: string, tenor: Period, settlementDays: Natural,
      currency: Currency, fixingCalendar: Calendar, fixedLegTenor: Period,
      fixedLegConvention: BusinessDayConvention, fixedLegDayCounter: DayCounter,
      iborIndex: IborIndex,
      discountingTermStructure?: Handle<YieldTermStructure>): SwapIndex;
  maturityDate(valueDate: Date): Date;
  fixedLegConvention(): BusinessDayConvention;
  forwardingTermStructure(): Handle<YieldTermStructure>;
  discountingTermStructure(): Handle<YieldTermStructure>;
  exogenousDiscount(): boolean;
  fixedLegTenor(): Period;
  iborIndex(): IborIndex;
  underlyingSwap(fixingDate: Date): Swap;
  clone1(forwarding: Handle<YieldTermStructure>): SwapIndex;
  clone2(
      forwarding: Handle<YieldTermStructure>,
      discounting: Handle<YieldTermStructure>): SwapIndex;
  clone3(tenor: Period): SwapIndex;
  forecastFixing(fixingDate: Date): Rate;
  protected _tenor: Period;
  protected _iborIndex: IborIndex;
  protected _fixedLegTenor: Period;
  protected _fixedLegConvention: BusinessDayConvention;
  protected _exogenousDiscount: boolean;
  protected _discount: Handle<YieldTermStructure>;
  protected _lastSwap: Swap;
  protected _lastFixingDate: Date;
}
export declare class OvernightIndexedSwapIndex extends SwapIndex {
  oisInit(
      familyName: string, tenor: Period, settlementDays: Natural,
      currency: Currency, overnightIndex: OvernightIndex,
      telescopicValueDates?: boolean): OvernightIndexedSwapIndex;
  overnightIndex(): OvernightIndex;
  underlyingSwap(fixingDate: Date): Swap;
  protected _overnightIndex: OvernightIndex;
  protected _telescopicValueDates: boolean;
  protected _lastFixingDate: Date;
}

export declare class Aonia extends OvernightIndex {
  constructor(h?: Handle<YieldTermStructure>);
}

export declare class AUDLibor extends Libor {
  constructor(tenor: Period, h?: Handle<YieldTermStructure>);
}

export declare class Bbsw extends IborIndex {
  constructor(tenor: Period, h?: Handle<YieldTermStructure>);
}
export declare class Bbsw1M extends Bbsw {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Bbsw2M extends Bbsw {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Bbsw3M extends Bbsw {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Bbsw4M extends Bbsw {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Bbsw5M extends Bbsw {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Bbsw6M extends Bbsw {
  constructor(h?: Handle<YieldTermStructure>);
}

export declare class Bibor extends IborIndex {
  constructor(tenor: Period, h?: Handle<YieldTermStructure>);
}
export declare class BiborSW extends Bibor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Bibor1M extends Bibor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Bibor2M extends Bibor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Bibor3M extends Bibor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Bibor6M extends Bibor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Bibor9M extends Bibor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Bibor1Y extends Bibor {
  constructor(h?: Handle<YieldTermStructure>);
}

export declare class Bkbm extends IborIndex {
  constructor(tenor: Period, h?: Handle<YieldTermStructure>);
}
export declare class Bkbm1M extends Bkbm {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Bkbm2M extends Bkbm {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Bkbm3M extends Bkbm {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Bkbm4M extends Bkbm {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Bkbm5M extends Bkbm {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Bkbm6M extends Bkbm {
  constructor(h?: Handle<YieldTermStructure>);
}

export declare class CADLibor extends Libor {
  constructor(tenor: Period, h?: Handle<YieldTermStructure>);
}
export declare class CADLiborON extends DailyTenorLibor {
  constructor(h?: Handle<YieldTermStructure>);
}

export declare class Cdor extends IborIndex {
  constructor(tenor: Period, h?: Handle<YieldTermStructure>);
}

export declare class DKKLibor extends Libor {
  constructor(tenor: Period, h?: Handle<YieldTermStructure>);
}

export declare class CHFLibor extends Libor {
  constructor(tenor: Period, h?: Handle<YieldTermStructure>);
}
export declare class DailyTenorCHFLibor extends DailyTenorLibor {
  constructor(settlementDays: Natural, h?: Handle<YieldTermStructure>);
}

export declare class Euribor extends IborIndex {
  constructor(tenor: Period, h?: Handle<YieldTermStructure>);
}
export declare class Euribor365 extends IborIndex {
  constructor(tenor: Period, h?: Handle<YieldTermStructure>);
}
export declare class EuriborSW extends Euribor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor2W extends Euribor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor3W extends Euribor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor1M extends Euribor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor2M extends Euribor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor3M extends Euribor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor4M extends Euribor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor5M extends Euribor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor6M extends Euribor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor7M extends Euribor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor8M extends Euribor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor9M extends Euribor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor10M extends Euribor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor11M extends Euribor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor1Y extends Euribor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor365_SW extends Euribor365 {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor365_2W extends Euribor365 {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor365_3W extends Euribor365 {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor365_1M extends Euribor365 {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor365_2M extends Euribor365 {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor365_3M extends Euribor365 {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor365_4M extends Euribor365 {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor365_5M extends Euribor365 {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor365_6M extends Euribor365 {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor365_7M extends Euribor365 {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor365_8M extends Euribor365 {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor365_9M extends Euribor365 {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor365_10M extends Euribor365 {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor365_11M extends Euribor365 {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class Euribor365_1Y extends Euribor365 {
  constructor(h?: Handle<YieldTermStructure>);
}

export declare class Eonia extends OvernightIndex {
  constructor(h?: Handle<YieldTermStructure>);
}

export declare class EURLibor extends IborIndex {
  constructor(tenor: Period, h?: Handle<YieldTermStructure>);
  valueDate(fixingDate: Date): Date;
  maturityDate(valueDate: Date): Date;
  private _target;
}
export declare class DailyTenorEURLibor extends IborIndex {
  constructor(settlementDays: Natural, h?: Handle<YieldTermStructure>);
}
export declare class EURLiborON extends DailyTenorEURLibor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class EURLiborSW extends EURLibor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class EURLibor2W extends EURLibor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class EURLibor1M extends EURLibor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class EURLibor2M extends EURLibor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class EURLibor3M extends EURLibor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class EURLibor4M extends EURLibor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class EURLibor5M extends EURLibor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class EURLibor6M extends EURLibor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class EURLibor7M extends EURLibor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class EURLibor8M extends EURLibor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class EURLibor9M extends EURLibor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class EURLibor10M extends EURLibor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class EURLibor11M extends EURLibor {
  constructor(h?: Handle<YieldTermStructure>);
}
export declare class EURLibor1Y extends EURLibor {
  constructor(h?: Handle<YieldTermStructure>);
}

export declare class FedFunds extends OvernightIndex {
  constructor(h?: Handle<YieldTermStructure>);
}

export declare class GBPLibor extends Libor {
  constructor(tenor: Period, h?: Handle<YieldTermStructure>);
}
export declare class DailyTenorGBPLibor extends DailyTenorLibor {
  constructor(settlementDays: Natural, h?: Handle<YieldTermStructure>);
}
export declare class GBPLiborON extends DailyTenorGBPLibor {
  constructor(h?: Handle<YieldTermStructure>);
}

export declare class Jibar extends IborIndex {
  constructor(tenor: Period, h?: Handle<YieldTermStructure>);
}

export declare class JPYLibor extends Libor {
  constructor(tenor: Period, h?: Handle<YieldTermStructure>);
}
export declare class DailyTenorJPYLibor extends DailyTenorLibor {
  constructor(settlementDays: Natural, h?: Handle<YieldTermStructure>);
}

export declare class Libor extends IborIndex {
  constructor(
      familyName: string, tenor: Period, settlementDays: Natural,
      currency: Currency, financialCenterCalendar: Calendar,
      dayCounter: DayCounter, h?: Handle<YieldTermStructure>);
  valueDate(fixingDate: Date): Date;
  maturityDate(valueDate: Date): Date;
  clone(h: Handle<YieldTermStructure>): IborIndex;
  jointCalendar(): Calendar;
  private _financialCenterCalendar;
  private _jointCalendar;
}
export declare class DailyTenorLibor extends IborIndex {
  constructor(
      familyName: string, settlementDays: Natural, currency: Currency,
      financialCenterCalendar: Calendar, dayCounter: DayCounter,
      h?: Handle<YieldTermStructure>);
}

export declare class Mosprime extends IborIndex {
  constructor(tenor: Period, h?: Handle<YieldTermStructure>);
}

export declare class NZDLibor extends Libor {
  constructor(tenor: Period, h?: Handle<YieldTermStructure>);
}

export declare class Nzocr extends OvernightIndex {
  constructor(h?: Handle<YieldTermStructure>);
}

export declare class Pribor extends IborIndex {
  constructor(tenor: Period, h?: Handle<YieldTermStructure>);
}

export declare class Robor extends IborIndex {
  constructor(tenor: Period, h?: Handle<YieldTermStructure>);
}

export declare class SEKLibor extends Libor {
  constructor(tenor: Period, h?: Handle<YieldTermStructure>);
}

export declare class Shibor extends IborIndex {
  constructor(tenor: Period, h?: Handle<YieldTermStructure>);
  clone(h: Handle<YieldTermStructure>): IborIndex;
}

export declare class Sonia extends OvernightIndex {
  constructor(h?: Handle<YieldTermStructure>);
}

export declare class THBFIX extends IborIndex {
  constructor(tenor: Period, h?: Handle<YieldTermStructure>);
}

export declare class Tibor extends IborIndex {
  constructor(tenor: Period, h?: Handle<YieldTermStructure>);
}

export declare class TRLibor extends IborIndex {
  constructor(tenor: Period, h?: Handle<YieldTermStructure>);
}

export declare class USDLibor extends Libor {
  constructor(tenor: Period, h?: Handle<YieldTermStructure>);
}
export declare class DailyTenorUSDLibor extends DailyTenorLibor {
  constructor(settlementDays: Natural, h?: Handle<YieldTermStructure>);
}
export declare class USDLiborON extends DailyTenorUSDLibor {
  constructor(h?: Handle<YieldTermStructure>);
}

export declare class Wibor extends IborIndex {
  constructor(tenor: Period, h?: Handle<YieldTermStructure>);
}

export declare class Zibor extends IborIndex {
  constructor(tenor: Period, h?: Handle<YieldTermStructure>);
}

export declare class ChfLiborSwapIsdaFix extends SwapIndex {
  chfInit1(tenor: Period, h?: Handle<YieldTermStructure>): ChfLiborSwapIsdaFix;
  chfInit2(
      tenor: Period, forwarding: Handle<YieldTermStructure>,
      discounting: Handle<YieldTermStructure>): ChfLiborSwapIsdaFix;
}

export declare class EuriborSwapIsdaFixA extends SwapIndex {
  esInit1(tenor: Period, h?: Handle<YieldTermStructure>): EuriborSwapIsdaFixA;
  esInit2(
      tenor: Period, forwarding: Handle<YieldTermStructure>,
      discounting: Handle<YieldTermStructure>): EuriborSwapIsdaFixA;
}
export declare class EuriborSwapIsdaFixB extends SwapIndex {
  esInit1(tenor: Period, h?: Handle<YieldTermStructure>): EuriborSwapIsdaFixB;
  esInit2(
      tenor: Period, forwarding: Handle<YieldTermStructure>,
      discounting: Handle<YieldTermStructure>): EuriborSwapIsdaFixB;
}
export declare class EuriborSwapIfrFix extends SwapIndex {
  esInit1(tenor: Period, h?: Handle<YieldTermStructure>): EuriborSwapIfrFix;
  esInit2(
      tenor: Period, forwarding: Handle<YieldTermStructure>,
      discounting: Handle<YieldTermStructure>): EuriborSwapIfrFix;
}

export declare class EurLiborSwapIsdaFixA extends SwapIndex {
  esInit1(tenor: Period, h?: Handle<YieldTermStructure>): EurLiborSwapIsdaFixA;
  esInit2(
      tenor: Period, forwarding: Handle<YieldTermStructure>,
      discounting: Handle<YieldTermStructure>): EurLiborSwapIsdaFixA;
}
export declare class EurLiborSwapIsdaFixB extends SwapIndex {
  esInit1(tenor: Period, h?: Handle<YieldTermStructure>): EurLiborSwapIsdaFixB;
  esInit2(
      tenor: Period, forwarding: Handle<YieldTermStructure>,
      discounting: Handle<YieldTermStructure>): EurLiborSwapIsdaFixB;
}
export declare class EurLiborSwapIfrFix extends SwapIndex {
  esInit1(tenor: Period, h?: Handle<YieldTermStructure>): EurLiborSwapIfrFix;
  esInit2(
      tenor: Period, forwarding: Handle<YieldTermStructure>,
      discounting: Handle<YieldTermStructure>): EurLiborSwapIfrFix;
}

export declare class GbpLiborSwapIsdaFix extends SwapIndex {
  gsInit1(tenor: Period, h?: Handle<YieldTermStructure>): GbpLiborSwapIsdaFix;
  gsInit2(
      tenor: Period, forwarding: Handle<YieldTermStructure>,
      discounting: Handle<YieldTermStructure>): GbpLiborSwapIsdaFix;
}

export declare class JpyLiborSwapIsdaFixAm extends SwapIndex {
  jsInit1(tenor: Period, h?: Handle<YieldTermStructure>): JpyLiborSwapIsdaFixAm;
  jsInit2(
      tenor: Period, forwarding: Handle<YieldTermStructure>,
      discounting: Handle<YieldTermStructure>): JpyLiborSwapIsdaFixAm;
}
export declare class JpyLiborSwapIsdaFixPm extends SwapIndex {
  jsInit1(tenor: Period, h?: Handle<YieldTermStructure>): JpyLiborSwapIsdaFixPm;
  jsInit2(
      tenor: Period, forwarding: Handle<YieldTermStructure>,
      discounting: Handle<YieldTermStructure>): JpyLiborSwapIsdaFixPm;
}

export declare class UsdLiborSwapIsdaFixAm extends SwapIndex {
  usInit1(tenor: Period, h?: Handle<YieldTermStructure>): UsdLiborSwapIsdaFixAm;
  usInit2(
      tenor: Period, forwarding: Handle<YieldTermStructure>,
      discounting: Handle<YieldTermStructure>): UsdLiborSwapIsdaFixAm;
}
export declare class UsdLiborSwapIsdaFixPm extends SwapIndex {
  usInit1(tenor: Period, h?: Handle<YieldTermStructure>): UsdLiborSwapIsdaFixAm;
  usInit2(
      tenor: Period, forwarding: Handle<YieldTermStructure>,
      discounting: Handle<YieldTermStructure>): UsdLiborSwapIsdaFixAm;
}

export declare class AUCPI extends ZeroInflationIndex {
  constructor(
      frequency: Frequency, revised: boolean, interpolated: boolean,
      ts?: Handle<ZeroInflationTermStructure>);
}
export declare class YYAUCPI extends YoYInflationIndex {
  constructor(
      frequency: Frequency, revised: boolean, interpolated: boolean,
      ts?: Handle<YoYInflationTermStructure>);
}
export declare class YYAUCPIr extends YoYInflationIndex {
  constructor(
      frequency: Frequency, revised: boolean, interpolated: boolean,
      ts?: Handle<YoYInflationTermStructure>);
}

export declare class EUHICP extends ZeroInflationIndex {
  constructor(interpolated: boolean, ts?: Handle<ZeroInflationTermStructure>);
}
export declare class EUHICPXT extends ZeroInflationIndex {
  constructor(interpolated: boolean, ts?: Handle<ZeroInflationTermStructure>);
}
export declare class YYEUHICP extends YoYInflationIndex {
  constructor(interpolated: boolean, ts?: Handle<YoYInflationTermStructure>);
}
export declare class YYEUHICPXT extends YoYInflationIndex {
  constructor(interpolated: boolean, ts?: Handle<YoYInflationTermStructure>);
}
export declare class YYEUHICPr extends YoYInflationIndex {
  constructor(interpolated: boolean, ts?: Handle<YoYInflationTermStructure>);
}

export declare class FRHICP extends ZeroInflationIndex {
  constructor(interpolated: boolean, ts?: Handle<ZeroInflationTermStructure>);
}
export declare class YYFRHICP extends YoYInflationIndex {
  constructor(interpolated: boolean, ts?: Handle<YoYInflationTermStructure>);
}
export declare class YYFRHICPr extends YoYInflationIndex {
  constructor(interpolated: boolean, ts?: Handle<YoYInflationTermStructure>);
}

export declare class UKRPI extends ZeroInflationIndex {
  constructor(interpolated: boolean, ts?: Handle<ZeroInflationTermStructure>);
}
export declare class YYUKRPI extends YoYInflationIndex {
  constructor(interpolated: boolean, ts?: Handle<YoYInflationTermStructure>);
}
export declare class YYUKRPIr extends YoYInflationIndex {
  constructor(interpolated: boolean, ts?: Handle<YoYInflationTermStructure>);
}

export declare class ZACPI extends ZeroInflationIndex {
  constructor(interpolated: boolean, ts?: Handle<ZeroInflationTermStructure>);
}
export declare class YYZACPI extends YoYInflationIndex {
  constructor(interpolated: boolean, ts?: Handle<YoYInflationTermStructure>);
}
export declare class YYZACPIr extends YoYInflationIndex {
  constructor(interpolated: boolean, ts?: Handle<YoYInflationTermStructure>);
}

export declare class USCPI extends ZeroInflationIndex {
  constructor(interpolated: boolean, ts?: Handle<ZeroInflationTermStructure>);
}
export declare class YYUSCPI extends YoYInflationIndex {
  constructor(interpolated: boolean, ts?: Handle<YoYInflationTermStructure>);
}
export declare class YYUSCPIr extends YoYInflationIndex {
  constructor(interpolated: boolean, ts?: Handle<YoYInflationTermStructure>);
}

export declare class BinomialTree<T extends TreeImpl> extends Tree<T> {
  btInit(process: StochasticProcess1D, end: Time, steps: Size): BinomialTree<T>;
  size(i: Size): Size;
  descendant(i: Size, index: Size, branch: Size): Size;
  protected _x0: Real;
  protected _driftPerStep: Real;
  protected _dt: Time;
}
export declare namespace BinomialTree {
  enum Branches { branches = 2 }
}
export declare class EqualProbabilitiesBinomialTree<T extends TreeImpl> extends
    BinomialTree<T> {
  underlying(i: Size, index: Size): Real;
  probability(i: Size, index: Size, branch: Size): Real;
  protected _up: Real;
}
export declare class EqualJumpsBinomialTree<T extends TreeImpl> extends
    BinomialTree<T> {
  underlying(i: Size, index: Size): Real;
  probability(i: Size, index: Size, branch: Size): Real;
  protected _dx: Real;
  protected _pu: Real;
  protected _pd: Real;
}
export declare class JarrowRudd extends
    EqualProbabilitiesBinomialTree<JarrowRudd> {
  treeInit(process: StochasticProcess1D, end: Time, steps: Size, strike: Real):
      JarrowRudd;
}
export declare class CoxRossRubinstein extends
    EqualJumpsBinomialTree<CoxRossRubinstein> {
  treeInit(process: StochasticProcess1D, end: Time, steps: Size, strike: Real):
      CoxRossRubinstein;
}
export declare class AdditiveEQPBinomialTree extends
    EqualProbabilitiesBinomialTree<AdditiveEQPBinomialTree> {
  treeInit(process: StochasticProcess1D, end: Time, steps: Size, strike: Real):
      AdditiveEQPBinomialTree;
}
export declare class Trigeorgis extends EqualJumpsBinomialTree<Trigeorgis> {
  treeInit(process: StochasticProcess1D, end: Time, steps: Size, strike: Real):
      Trigeorgis;
}
export declare class Tian extends BinomialTree<Tian> {
  treeInit(process: StochasticProcess1D, end: Time, steps: Size, strike: Real):
      Tian;
  underlying(i: Size, index: Size): Real;
  probability(i: Size, index: Size, branch: Size): Real;
  protected _up: Real;
  protected _down: Real;
  protected _pu: Real;
  protected _pd: Real;
}
export declare class LeisenReimer extends BinomialTree<LeisenReimer> {
  treeInit(process: StochasticProcess1D, end: Time, steps: Size, strike: Real):
      LeisenReimer;
  underlying(i: Size, index: Size): Real;
  probability(i: Size, index: Size, branch: Size): Real;
  protected _up: Real;
  protected _down: Real;
  protected _pu: Real;
  protected _pd: Real;
}
export declare class Joshi4 extends BinomialTree<Joshi4> {
  treeInit(process: StochasticProcess1D, end: Time, steps: Size, strike: Real):
      Joshi4;
  underlying(i: Size, index: Size): Real;
  probability(i: Size, index: Size, branch: Size): Real;
  protected computeUpProb(k: Real, dj: Real): Real;
  protected _up: Real;
  protected _down: Real;
  protected _pu: Real;
  protected _pd: Real;
}

export declare class BlackScholesLattice<T extends TreeLatticeImpl> extends
    TreeLattice1D<BlackScholesLattice<T>> {
  constructor(tree: T, riskFreeRate: Rate, end: Time, steps: Size);
  riskFreeRate(): Rate;
  dt(): Time;
  size(i: Size): Size;
  discount(i: Size, index: Size): DiscountFactor;
  stepback1(i: Size, values: Real[], newValues: Real[]): void;
  underlying(i: Size, index: Size): Real;
  descendant(i: Size, index: Size, branch: Size): Size;
  probability(i: Size, index: Size, branch: Size): Real;
  protected _tree: T;
  protected _riskFreeRate: Rate;
  protected _dt: Time;
  protected _discount: DiscountFactor;
  protected _pd: Real;
  protected _pu: Real;
}

export interface TreeLatticeImpl extends ICuriouslyRecurringTemplate {
  treeInit?(process: StochasticProcess1D, end: Time, steps: Size, strike: Real):
      TreeLatticeImpl;
  discount?(i: Size, index: Size): DiscountFactor;
  descendant(i: Size, index: Size, branch: Size): Size;
  probability(i: Size, index: Size, branch: Size): Real;
  stepback?(i: Size, values: Real[], newValues: Real[]): void;
  underlying?(i: Size, index: Size): Real;
  size?(i: Size): Size;
}
export interface ITreeLattice {
  statePrices(i: Size): Real[];
  stepback(i: Size, values: Real[], newValues: Real[]): void;
}
export declare class TreeLattice<Impl extends TreeLatticeImpl> extends
    LatticeCuriouslyRecurringTemplate<Impl> implements ITreeLattice {
  init(timeGrid: TimeGrid, n: Size): TreeLattice<Impl>;
  statePrices(i: Size): Real[];
  presentValue(asset: DiscretizedAsset): Real;
  initialize(asset: DiscretizedAsset, t: Time): void;
  rollback(asset: DiscretizedAsset, to: Time): void;
  partialRollback(asset: DiscretizedAsset, to: Time): void;
  stepback(i: Size, values: Real[], newValues: Real[]): void;
  protected computeStatePrices(until: Size): void;
  protected _statePrices: Real[][];
  private _n;
  private _statePricesLimit;
}

export declare class TreeLattice1D<Impl extends TreeLatticeImpl> extends
    TreeLattice<Impl> {
  init1D(timeGrid: TimeGrid, n: Size): TreeLattice1D<Impl>;
  grid(t: Time): Real[];
  underlying(i: Size, index: Size): Real;
}

export declare class TreeLattice2D<Impl extends TreeLatticeImpl> extends
    TreeLattice<Impl> {
  init2D(tree1: TrinomialTree, tree2: TrinomialTree, correlation: Real):
      TreeLattice2D<Impl>;
  size(i: Size): Size;
  descendant(i: Size, index: Size, branch: Size): Real;
  probability(i: Size, index: Size, branch: Size): Real;
  grid(t: Time): Real[];
  protected _tree1: TrinomialTree;
  protected _tree2: TrinomialTree;
  private _m;
  private _rho;
}

export interface TreeImpl extends ICuriouslyRecurringTemplate {}
export declare class Tree<T extends TreeImpl> extends
    CuriouslyRecurringTemplate<T> {
  init(columns: Size): Tree<T>;
  columns(): Size;
  private _columns;
}

export declare class TrinomialTree extends Tree<TrinomialTree> {
  constructor(
      process: StochasticProcess1D, timeGrid: TimeGrid, isPositive?: boolean);
  dx(i: Size): Real;
  timeGrid(): TimeGrid;
  size(i: Size): Size;
  underlying(i: Size, index: Size): Real;
  descendant(i: Size, index: Size, branch: Size): Real;
  probability(i: Size, index: Size, branch: Size): Real;
  protected _branchings: TrinomialTree.Branching[];
  protected _x0: Real;
  protected _dx: Real[];
  protected _timeGrid: TimeGrid;
}
export declare namespace TrinomialTree {
  enum Branches { branches = 3 }
  class Branching {
    constructor();
    descendant(index: Size, branch: Size): Real;
    probability(index: Size, branch: Size): Real;
    size(): Size;
    jMin(): Integer;
    jMax(): Integer;
    add(k: Integer, p1: Real, p2: Real, p3: Real): void;
    private _k;
    private _probs;
    private _kMin;
    private _jMin;
    private _kMax;
    private _jMax;
  }
}

export declare class BrownianBridge {
  init1(steps: Size): BrownianBridge;
  init2(times: Time[]): BrownianBridge;
  init3(timeGrid: TimeGrid): BrownianBridge;
  size(): Size;
  times(): Time[];
  bridgeIndex(): Size[];
  leftIndex(): Size[];
  rightIndex(): Size[];
  leftWeight(): Real[];
  rightWeight(): Real[];
  stdDeviation(): Real[];
  transform(
      input: Real[], inputBegin: Size, inputEnd: Size, output: Real[],
      outputBegin: Size): void;
  private initialize;
  private _size;
  private _t;
  private _sqrtdt;
  private _bridgeIndex;
  private _leftIndex;
  private _rightIndex;
  private _leftWeight;
  private _rightWeight;
  private _stdDev;
}

export declare type StateType = Real | Real[];
export declare type EarlyExerciseTraits =
    EarlyExerciseTraitsPath | EarlyExerciseTraitsMultiPath;
export declare class EarlyExerciseTraitsPath {
  static pathLength(path: Path): number;
}
export declare class EarlyExerciseTraitsMultiPath {
  static pathLength(path: MultiPath): number;
}
export declare class EarlyExercisePathPricer<PathType = Path | MultiPath>
    implements BinaryFunction<PathType, Size, Real> {
  f(path: PathType, t: Size): Real;
  state(path: PathType, t: Size): StateType;
  basisSystem(): Array<UnaryFunction<StateType, Real>>;
}

export declare class ExerciseStrategy {
  exerciseTimes(): Time[];
  relevantTimes(): Time[];
  reset(): void;
  exercise(currentState: CurveState): boolean;
  nextStep(currentState: CurveState): void;
  clone(): ExerciseStrategy;
}

export declare function genericLongstaffSchwartzRegression(
    simulationData: NodeData[][], basisCoefficients: Real[][]): Real;

export declare class LongstaffSchwartzPathPricer<PathType = Path | MultiPath>
    extends PathPricer<PathType> implements UnaryFunction<PathType, Real> {
  constructor(
      times: TimeGrid, pathPricer: EarlyExercisePathPricer<PathType>,
      termStructure: YieldTermStructure);
  f(path: PathType): Real;
  calibrate(): void;
  exerciseProbability(): Real;
  protected post_processing(
      i: Size, state: StateType[], price: Real[], exercise: Real[]): void;
  protected _calibrationPhase: boolean;
  protected _pathPricer: EarlyExercisePathPricer<PathType>;
  protected _exerciseProbability: IncrementalStatistics;
  protected _coeff: Real[][];
  protected _dF: DiscountFactor[];
  protected _paths: PathType[];
  protected _v: Array<UnaryFunction<StateType, Real>>;
  protected _len: Size;
}

export declare class LsmBasisSystem {
  static pathBasisSystem(order: Size, polyType: LsmBasisSystem.PolynomType):
      Array<UnaryFunction<Real, Real>>;
  static multiPathBasisSystem(
      dim: Size, order: Size,
      polyType: LsmBasisSystem.PolynomType): Array<UnaryFunction<Real[], Real>>;
}
export declare namespace LsmBasisSystem {
  enum PolynomType {
    Monomial = 0,
    Laguerre = 1,
    Hermite = 2,
    Hyperbolic = 3,
    Legendre = 4,
    Chebyshev = 5,
    Chebyshev2nd = 6
  }
}

export declare enum MC {SingleVariate = 0, MultiVariate = 1}
export declare namespace SingleVariate {
  type rng_traits = PseudoRandom;
  type path_type = Path;
  type path_pricer_type = PathPricer<path_type>;
  type rsg_type = PseudoRandom.rsg_type;
  type path_generator_type = PathGenerator;
  const allowsErrorEstimate: boolean;
}
export declare namespace MultiVariate {
  type rng_traits = PseudoRandom;
  type path_type = MultiPath;
  type path_pricer_type = PathPricer<path_type>;
  type rsg_type = PseudoRandom.rsg_type;
  type path_generator_type = MultiPathGenerator;
  const allowsErrorEstimate: boolean;
}

export declare class MultiPath {
  init1(nAsset: Size, timeGrid: TimeGrid): MultiPath;
  init2(multiPath: Path[]): MultiPath;
  assetNumber(): Size;
  pathSize(): Size;
  at(j: Size): Path;
  private _multiPath;
}

export declare class MonteCarloModel {
  constructor(
      MC: MonteCarloModel.mc_traits, RNG: MonteCarloModel.rng_traits, S?: any);
  mcmInit(
      pathGenerator: MonteCarloModel.path_generator_type,
      pathPricer: MonteCarloModel.path_pricer_type,
      sampleAccumulator: MonteCarloModel.stats_type, antitheticVariate: boolean,
      cvPathPricer?: MonteCarloModel.path_pricer_type,
      cvOptionValue?: MonteCarloModel.result_type,
      cvPathGenerator?: MonteCarloModel.path_generator_type): MonteCarloModel;
  addSamples(samples: Size): void;
  sampleAccumulator(): MonteCarloModel.stats_type;
  MC: MonteCarloModel.mc_traits;
  RNG: MonteCarloModel.rng_traits;
  S: any;
  private _pathGenerator;
  private _pathPricer;
  private _sampleAccumulator;
  private _isAntitheticVariate;
  private _cvPathPricer;
  private _cvOptionValue;
  private _isControlVariate;
  private _cvPathGenerator;
}
export declare namespace MonteCarloModel {
  type mc_traits = MC;
  type rng_traits = RNGTraits;
  type path_generator_type =
      SingleVariate.path_generator_type|MultiVariate.path_generator_type;
  type path_pricer_type =
      SingleVariate.path_pricer_type|MultiVariate.path_pricer_type;
  type sample_type = Sample<Path>|Sample<MultiPath>;
  type result_type = Real;
  type stats_type = Statistics;
}

export declare class MultiPathGenerator {
  init2(
      process: StochasticProcess, times: TimeGrid, generator: USG<Real[]>,
      brownianBridge?: boolean): MultiPathGenerator;
  next(): MultiPathGenerator.sample_type;
  antithetic(): MultiPathGenerator.sample_type;
  private next_;
  private _brownianBridge;
  private _process;
  private _generator;
  private _next;
}
export declare namespace MultiPathGenerator {
  type sample_type = Sample<MultiPath>;
}

export declare class NodeData {
  exerciseValue: Real;
  cumulatedCashFlows: Real;
  values: Real[];
  controlValue: Real;
  isValid: boolean;
}

export declare class ParametricExercise {
  numberOfVariables(): Size[];
  numberOfParameters(): Size[];
  exercise(exerciseNumber: Size, parameters: Real[], variables: Real[]):
      boolean;
  guess(exerciseNumber: Size, parameters: Real[]): void;
}
export declare function genericEarlyExerciseOptimization(
    simulationData: NodeData[][], exercise: ParametricExercise,
    parameters: Real[][], endCriteria: EndCriteria,
    method: OptimizationMethod): Real;
export declare class ValueEstimate extends CostFunction {
  constructor(
      simulationData: NodeData[], exercise: ParametricExercise,
      exerciseIndex: Size);
  value(parameters: Real[]): Real;
  values(a: Real[]): Real[];
  private _simulationData;
  private _exercise;
  private _exerciseIndex;
  private _parameters;
}

export declare class Path {
  constructor(timeGrid: TimeGrid, values?: Real[]);
  empty(): boolean;
  length(): Size;
  at(i: Size): Real;
  set(i: Size, v: Real): void;
  value(i: Size): Real;
  values(): Real[];
  time(i: Size): Time;
  front: Real;
  back: Real;
  timeGrid(): TimeGrid;
  private _timeGrid;
  private _values;
}

export declare class PathGenerator {
  init1(
      process: StochasticProcess, length: Time, timeSteps: Size,
      generator: USG<Real[]>, brownianBridge: boolean): PathGenerator;
  init2(
      process: StochasticProcess, timeGrid: TimeGrid, generator: USG<Real[]>,
      brownianBridge: boolean): PathGenerator;
  next(): PathGenerator.sample_type;
  antithetic(): PathGenerator.sample_type;
  size(): Size;
  timeGrid(): TimeGrid;
  private next_;
  private _brownianBridge;
  private _generator;
  private _dimension;
  private _timeGrid;
  private _process;
  private _next;
  private _temp;
  private _bb;
}
export declare namespace PathGenerator {
  type sample_type = Sample<Path>;
}

export declare class PathPricer<PathType = Path | MultiPath, ValueType = Real>
    implements UnaryFunction<PathType, ValueType> {
  f(p: PathType): ValueType;
}

export declare class Sample<T> {
  constructor(value: T, weight: Real);
  value: T;
  weight: Real;
}

export declare class BoundaryCondition<Operator> {
  applyBeforeApplying(L: Operator): void;
  applyAfterApplying1(u: Real[]): void;
  applyBeforeSolving(L: Operator, rhs: Real[]): void;
  applyAfterSolving(u: Real[]): void;
  setTime(t: Time): void;
}
export declare namespace BoundaryCondition {
  enum Side { None = 0, Upper = 1, Lower = 2 }
}
export declare class NeumannBC extends BoundaryCondition<TridiagonalOperator> {
  constructor(value: Real, side: BoundaryCondition.Side);
  applyBeforeApplying(L: TridiagonalOperator): void;
  applyAfterApplying1(u: Real[]): void;
  applyBeforeSolving(L: TridiagonalOperator, rhs: Real[]): void;
  applyAfterSolving(u: Real[]): void;
  setTime(t: Time): void;
  private _value;
  private _side;
}
export declare class DirichletBC extends
    BoundaryCondition<TridiagonalOperator> {
  constructor(value: Real, side: BoundaryCondition.Side);
  applyBeforeApplying(L: TridiagonalOperator): void;
  applyAfterApplying1(u: Real[]): void;
  applyBeforeSolving(L: TridiagonalOperator, rhs: Real[]): void;
  applyAfterSolving(u: Real[]): void;
  setTime(t: Time): void;
  private _value;
  private _side;
}

export declare class AmericanCondition extends CurveDependentStepCondition {
  acInit1(type: Option.Type, strike: Real): AmericanCondition;
  acInit2(intrinsicValues: Real[]): AmericanCondition;
  applyToValue(current: Real, intrinsic: Real): Real;
}

export declare type BSMTermOperator = PdeOperator<PdeBSM>;

export declare class BSMOperator extends TridiagonalOperator {
  bsmInit1(size: Size, dx: Real, r: Rate, q: Rate, sigma: Volatility):
      BSMOperator;
  bsmInit2(
      grid: Real[], process: GeneralizedBlackScholesProcess,
      residualTime: Time): BSMOperator;
}

export declare class CrankNicolson extends MixedScheme {
  eInit(
      L: TridiagonalOperator,
      bcs: OperatorTraits.bc_set<TridiagonalOperator>): CrankNicolson;
}

export declare class DMinus extends TridiagonalOperator {
  constructor(gridPoints: Size, h: Real);
}

export declare class DPlusDMinus extends TridiagonalOperator {
  constructor(gridPoints: Size, h: Real);
}

export declare class DPlus extends TridiagonalOperator {
  constructor(gridPoints: Size, h: Real);
}

export declare class ExplicitEuler extends MixedScheme {
  constructor(
      L: TridiagonalOperator, bcs: OperatorTraits.bc_set<TridiagonalOperator>);
}

export declare class DZero extends TridiagonalOperator {
  constructor(gridPoints: Size, h: Real);
}

export declare type StandardStepCondition = StepCondition;
export declare type StandardCurveDependentStepCondition =
    CurveDependentStepCondition;

export declare class FiniteDifferenceModel {
  constructor(evolver: Evolver, stoppingTimes?: Time[]);
  evolver(): Evolver;
  rollback(
      a: Real[], from: Time, to: Time, steps: Size,
      condition?: OperatorTraits.condition_type): void;
  private rollbackImpl;
  private _evolver;
  private _stoppingTimes;
}

export declare class GenericTimeSetter<PdeClass extends pde> extends
    TridiagonalOperator.TimeSetter {
  constructor(type: PdeType, grid: Real[], process: pde.argument_type);
  setTime(t: Time, L: TridiagonalOperator): void;
  private _grid;
  private _pde;
}

export declare class ImplicitEuler extends MixedScheme {
  constructor(
      L: TridiagonalOperator, bcs: OperatorTraits.bc_set<TridiagonalOperator>);
}

export declare class MixedScheme {
  init(
      L: TridiagonalOperator, theta: Real,
      bcs: OperatorTraits.bc_set<TridiagonalOperator>): MixedScheme;
  step(a: Real[], t: Time): void;
  setStep(dt: Time): void;
  protected _L: TridiagonalOperator;
  protected _I: TridiagonalOperator;
  protected _explicitPart: TridiagonalOperator;
  protected _implicitPart: TridiagonalOperator;
  protected _dt: Time;
  protected _theta: Real;
  protected _bcs: OperatorTraits.bc_set<TridiagonalOperator>;
}

export declare type OneFactorOperator = PdeOperator<PdeShortRate>;

export declare class OperatorFactory {
  static getOperator1(
      process: GeneralizedBlackScholesProcess, grid: Real[], residualTime: Time,
      timeDependent: boolean): TridiagonalOperator;
}

export declare namespace OperatorTraits {
  type array_type = Real[];
  type bc_type<Operator> = BoundaryCondition<Operator>;
  type bc_set<Operator> = Array<BoundaryCondition<Operator>>;
  type condition_type = StepCondition;
}

export declare class StepConditionSet {}
export declare class BoundaryConditionSet {}
export declare class ParallelEvolverTraits {}
export declare class ParallelEvolver {}

export declare enum PdeType {PdeBSM = 0}
export interface pde {
  diffusion(t: Time, x: Real): Real;
  drift(t: Time, x: Real): Real;
  discount(t: Time, x: Real): Real;
  generateOperator(t: Time, tg: TransformedGrid, L: TridiagonalOperator): void;
}
export declare namespace pde {
  function create_pde(type: PdeType, process: argument_type): pde;
  function create_grid(type: PdeType, grid: Real[]): grid_type;
  type grid_type = TransformedGrid;
  type argument_type = GeneralizedBlackScholesProcess;
}

export declare class PdeBSM extends PdeSecondOrderParabolic {
  constructor(process: PdeBSM.argument_type);
  diffusion(t: Time, x: Real): Real;
  drift(t: Time, x: Real): Real;
  discount(t: Time, x: Real): Real;
  private _process;
}
export declare namespace PdeBSM {
  type grid_type = LogGrid;
  type argument_type = GeneralizedBlackScholesProcess;
}

export declare class PdeConstantCoeff extends PdeSecondOrderParabolic {
  constructor(type: PdeType, process: pde.argument_type, t: Time, x: Real);
  diffusion(t: Time, x: Real): Real;
  drift(t: Time, x: Real): Real;
  discount(t: Time, x: Real): Real;
  private _diffusion;
  private _drift;
  private _discount;
}

export declare class PdeOperator<PdeClass extends pde> extends
    TridiagonalOperator {
  constructor(
      type: PdeType, grid: Real[], process: pde.argument_type,
      residualTime?: Time);
}

export declare class PdeShortRate extends PdeSecondOrderParabolic {
  constructor(d: PdeShortRate.argument_type);
  diffusion(t: Time, x: Real): Real;
  drift(t: Time, x: Real): Real;
  discount(t: Time, x: Real): Real;
  private _dynamics;
}
export declare namespace PdeShortRate {
  type argument_type = OneFactorModel.ShortRateDynamics;
  type grid_type = TransformedGrid;
}

export declare class PdeSecondOrderParabolic implements pde {
  diffusion(t: Time, x: Real): Real;
  drift(t: Time, x: Real): Real;
  discount(t: Time, x: Real): Real;
  generateOperator(t: Time, tg: TransformedGrid, L: TridiagonalOperator): void;
}

export declare class ShoutCondition extends CurveDependentStepCondition {
  scInit1(type: Option.Type, strike: Real, resTime: Time, rate: Rate):
      ShoutCondition;
  scInit2(intrinsicValues: Real[], resTime: Time, rate: Rate): ShoutCondition;
  applyTo(a: Real[], t: Time): void;
  applyToValue(current: Real, intrinsic: Real): Real;
  private _resTime;
  private _rate;
  private _disc;
}

export declare class StepCondition {
  applyTo(a: Real[], t: Time): void;
}
export declare class CurveDependentStepCondition extends StepCondition {
  init1(type: Option.Type, strike: Real): CurveDependentStepCondition;
  init2(p: Payoff): CurveDependentStepCondition;
  init3(a: Real[]): CurveDependentStepCondition;
  applyTo(a: Real[], t: Time): void;
  getValue(a: Real[], index: Size): Real;
  applyToValue(x: Real, y: Real): Real;
  protected _curveItem: CurveDependentStepCondition.CurveWrapper;
}
export declare namespace CurveDependentStepCondition {
  class CurveWrapper {
    getValue(a: Real[], i: Integer): Real;
  }
  class ArrayWrapper extends CurveWrapper {
    constructor(a: Real[]);
    getValue(a: Real[], i: Integer): Real;
    private _value;
  }
  class PayoffWrapper extends CurveWrapper {
    init1(type: Option.Type, strike: Real): PayoffWrapper;
    init2(p: Payoff): PayoffWrapper;
    getValue(a: Real[], i: Integer): Real;
    private _payoff;
  }
}
export declare class NullCondition extends StepCondition {
  applyTo(a: Real[], t: Time): void;
}

export declare class TRBDF2 {
  constructor(
      L: TridiagonalOperator, bcs: OperatorTraits.bc_set<TridiagonalOperator>);
  step(a: Real[], t: Time): void;
  setStep(dt: Time): void;
  private _alpha;
  private _L;
  private _I;
  private _explicitTrapezoidalPart;
  private _explicitBDF2PartFull;
  private _explicitBDF2PartMid;
  private _implicitPart;
  private _dt;
  private _bcs;
  private _aInit;
}

export declare class TridiagonalOperator {
  init1(size?: Size): TridiagonalOperator;
  init2(low: Real[], mid: Real[], high: Real[]): TridiagonalOperator;
  applyTo(v: Real[]): Real[];
  solveFor1(rhs: Real[]): Real[];
  solveFor2(rhs: Real[], result: Real[]): void;
  SOR(rhs: Real[], tol: Real): Real[];
  static identity(size: Size): TridiagonalOperator;
  size(): Size;
  isTimeDependent(): boolean;
  lowerDiagonal(): Real[];
  diagonal(): Real[];
  upperDiagonal(): Real[];
  setFirstRow(valB: Real, valC: Real): void;
  setMidRow(i: Size, valA: Real, valB: Real, valC: Real): void;
  setMidRows(valA: Real, valB: Real, valC: Real): void;
  setLastRow(valA: Real, valB: Real): void;
  setTime(t: Time): void;
  _n: Size;
  _diagonal: Real[];
  _lowerDiagonal: Real[];
  _upperDiagonal: Real[];
  _temp: Real[];
  _timeSetter: TridiagonalOperator.TimeSetter;
}
export declare namespace TridiagonalOperator {
  class TimeSetter {
    setTime(t: Time, L: TridiagonalOperator): void;
  }
  function add(
      D1: TridiagonalOperator, D2: TridiagonalOperator): TridiagonalOperator;
  function sub(
      D1: TridiagonalOperator, D2: TridiagonalOperator): TridiagonalOperator;
  function mulScalar(D: TridiagonalOperator, a: Real): TridiagonalOperator;
}

export declare class ZeroCondition extends StepCondition {
  applyTo(a: Real[], t: Time): void;
}

export declare class Concentrating1dMesher extends Fdm1dMesher {
  init1(
      start: Real, end: Real, size: Size, cPoints?: [Real, Real],
      requireCPoint?: boolean): Concentrating1dMesher;
  init2(
      start: Real, end: Real, size: Size, cPoints: Array<[Real, Real, boolean]>,
      tol?: Real): Concentrating1dMesher;
}

export declare class ExponentialJump1dMesher extends Fdm1dMesher {
  constructor(
      steps: Size, beta: Real, jumpIntensity: Real, eta: Real, eps?: Real);
  jumpSizeDensity1(x: Real): Real;
  jumpSizeDensity2(x: Real, t: Time): Real;
  jumpSizeDistribution1(x: Real): Real;
  jumpSizeDistribution2(x: Real, t: Time): Real;
  private _beta;
  private _jumpIntensity;
  private _eta;
}

export declare class Fdm1dMesher {
  init(size: Size): Fdm1dMesher;
  size(): Size;
  dplus(index: Size): Real;
  dminus(index: Size): Real;
  location(index: Size): Real;
  locations(): Real[];
  protected _locations: Real[];
  protected _dplus: Real[];
  protected _dminus: Real[];
}

export declare class FdmBlackScholesMesher extends Fdm1dMesher {
  constructor(
      size: Size, process: GeneralizedBlackScholesProcess, maturity: Time,
      strike: Real, xMinConstraint?: Real, xMaxConstraint?: Real, eps?: Real,
      scaleFactor?: Real, cPoint?: [Real, Real],
      dividendSchedule?: DividendSchedule);
  static processHelper(
      s0: Handle<Quote>, rTS: Handle<YieldTermStructure>,
      qTS: Handle<YieldTermStructure>,
      vol: Volatility): GeneralizedBlackScholesProcess;
}

export declare class FdmBlackScholesMultiStrikeMesher extends Fdm1dMesher {
  constructor(
      size: Size, process: GeneralizedBlackScholesProcess, maturity: Time,
      strikes: Real[], eps?: Real, scaleFactor?: Real, cPoint?: [Real, Real]);
}

export declare class FdmHestonVarianceMesher extends Fdm1dMesher {
  constructor(
      size: Size, process: HestonProcess, maturity: Time, tAvgSteps?: Size,
      epsilon?: Real);
  volaEstimate(): Real;
  private _volaEstimate;
}

export declare class FdmMesher {
  init(layout: FdmLinearOpLayout): FdmMesher;
  dplus(iter: FdmLinearOpIterator, direction: Size): Real;
  dminus(iter: FdmLinearOpIterator, direction: Size): Real;
  location(iter: FdmLinearOpIterator, direction: Size): Real;
  locations(direction: Size): Real[];
  layout(): FdmLinearOpLayout;
  protected _layout: FdmLinearOpLayout;
}

export declare class FdmMesherComposite extends FdmMesher {
  cInit1(layout: FdmLinearOpLayout, mesher: Fdm1dMesher[]): FdmMesherComposite;
  cInit2(mesher: Fdm1dMesher[]): FdmMesherComposite;
  cInit3(mesher: Fdm1dMesher): FdmMesherComposite;
  cInit4(m1: Fdm1dMesher, m2: Fdm1dMesher): FdmMesherComposite;
  cInit5(m1: Fdm1dMesher, m2: Fdm1dMesher, m3: Fdm1dMesher): FdmMesherComposite;
  cInit6(m1: Fdm1dMesher, m2: Fdm1dMesher, m3: Fdm1dMesher, m4: Fdm1dMesher):
      FdmMesherComposite;
  dplus(iter: FdmLinearOpIterator, direction: Size): Real;
  dminus(iter: FdmLinearOpIterator, direction: Size): Real;
  location(iter: FdmLinearOpIterator, direction: Size): Real;
  locations(direction: Size): Real[];
  getFdm1dMeshers(): Fdm1dMesher[];
  private _mesher;
}

export declare class FdmSimpleProcess1dMesher extends Fdm1dMesher {
  constructor(
      size: Size, process: StochasticProcess1D, maturity: Time,
      tAvgSteps?: Size, eps?: Real, mandatoryPoint?: Real);
}

export declare class Predefined1dMesher extends Fdm1dMesher {
  constructor(x: Real[]);
}

export declare class Uniform1dMesher extends Fdm1dMesher {
  constructor(start: Real, end: Real, size: Size);
}

export declare class UniformGridMesher extends FdmMesher {
  constructor(layout: FdmLinearOpLayout, boundaries: Array<[Real, Real]>);
  dplus(iter: FdmLinearOpIterator, direction: Size): Real;
  dminus(iter: FdmLinearOpIterator, direction: Size): Real;
  location(iter: FdmLinearOpIterator, direction: Size): Real;
  locations(d: Size): Real[];
  private _dx;
  private _locations;
}

export declare class Fdm2dBlackScholesOp extends FdmLinearOpComposite {
  constructor(
      mesher: FdmMesher, p1: GeneralizedBlackScholesProcess,
      p2: GeneralizedBlackScholesProcess, correlation: Real, maturity: Time,
      localVol?: boolean, illegalLocalVolOverwrite?: Real);
  size(): Size;
  setTime(t1: Time, t2: Time): void;
  apply(x: Real[]): Real[];
  apply_mixed(x: Real[]): Real[];
  apply_direction(direction: Size, x: Real[]): Real[];
  solve_splitting(direction: Size, x: Real[], s: Real): Real[];
  preconditioner(r: Real[], dt: Real): Real[];
  private _mesher;
  private _p1;
  private _p2;
  private _localVol1;
  private _localVol2;
  private _x;
  private _y;
  private _currentForwardRate;
  private _opX;
  private _opY;
  private _corrMapT;
  private _corrMapTemplate;
  private _illegalLocalVolOverwrite;
}

export declare class FdmBatesOp extends FdmLinearOpComposite {
  constructor(
      mesher: FdmMesher, batesProcess: BatesProcess,
      bcSet: FdmBoundaryConditionSet, integroIntegrationOrder: Size,
      quantoHelper?: FdmQuantoHelper);
  size(): Size;
  setTime(t1: Time, t2: Time): void;
  apply(r: Real[]): Real[];
  apply_mixed(r: Real[]): Real[];
  apply_direction(direction: Size, r: Real[]): Real[];
  solve_splitting(direction: Size, r: Real[], s: Real): Real[];
  preconditioner(r: Real[], s: Real): Real[];
  private integro;
  private _lambda;
  private _delta;
  private _nu;
  private _m;
  private _gaussHermiteIntegration;
  private _mesher;
  private _bcSet;
  private _hestonOp;
}

export declare class FdmBlackScholesOp extends FdmLinearOpComposite {
  constructor(
      mesher: FdmMesher, bsProcess: GeneralizedBlackScholesProcess,
      strike: Real, localVol?: boolean, illegalLocalVolOverwrite?: Real,
      direction?: Size);
  size(): Size;
  setTime(t1: Time, t2: Time): void;
  apply(u: Real[]): Real[];
  apply_mixed(r: Real[]): Real[];
  apply_direction(direction: Size, r: Real[]): Real[];
  solve_splitting(direction: Size, r: Real[], dt: Real): Real[];
  preconditioner(r: Real[], dt: Real): Real[];
  private _mesher;
  private _rTS;
  private _qTS;
  private _volTS;
  private _localVol;
  private _x;
  private _dxMap;
  private _dxxMap;
  private _mapT;
  private _strike;
  private _illegalLocalVolOverwrite;
  private _direction;
}

export declare class FdmG2Op extends FdmLinearOpComposite {
  constructor(mesher: FdmMesher, model: G2, direction1: Size, direction2: Size);
  size(): Size;
  setTime(t1: Time, t2: Time): void;
  apply(r: Real[]): Real[];
  apply_mixed(r: Real[]): Real[];
  apply_direction(direction: Size, r: Real[]): Real[];
  solve_splitting(direction: Size, r: Real[], a: Real): Real[];
  preconditioner(r: Real[], dt: Real): Real[];
  private _direction1;
  private _direction2;
  private _x;
  private _y;
  private _dxMap;
  private _dyMap;
  private _corrMap;
  private _mapX;
  private _mapY;
  private _model;
}

export declare class FdmHestonHullWhiteEquityPart {
  constructor(mesher: FdmMesher, hwModel: HullWhite, qTS: YieldTermStructure);
  setTime(t1: Time, t2: Time): void;
  getMap(): TripleBandLinearOp;
  protected _x: Real[];
  protected _varianceValues: Real[];
  protected _volatilityValues: Real[];
  protected _dxMap: FirstDerivativeOp;
  protected _dxxMap: TripleBandLinearOp;
  protected _mapT: TripleBandLinearOp;
  protected _hwModel: HullWhite;
  protected _mesher: FdmMesher;
  protected _qTS: YieldTermStructure;
}
export declare class FdmHestonHullWhiteOp extends FdmLinearOpComposite {
  constructor(
      mesher: FdmMesher, hestonProcess: HestonProcess,
      hwProcess: HullWhiteProcess, equityShortRateCorrelation: Real);
  size(): Size;
  setTime(t1: Time, t2: Time): void;
  apply(u: Real[]): Real[];
  apply_direction(direction: Size, r: Real[]): Real[];
  apply_mixed(r: Real[]): Real[];
  solve_splitting(direction: Size, r: Real[], a: Real): Real[];
  preconditioner(r: Real[], dt: Real): Real[];
  _v0: Real;
  private _kappa;
  private _theta;
  private _sigma;
  private _rho;
  private _hwModel;
  private _hestonCorrMap;
  private _equityIrCorrMap;
  private _dyMap;
  private _dxMap;
  private _hullWhiteOp;
}

export declare class FdmHestonEquityPart {
  constructor(
      mesher: FdmMesher, rTS: YieldTermStructure, qTS: YieldTermStructure,
      quantoHelper: FdmQuantoHelper, leverageFct?: LocalVolTermStructure);
  setTime(t1: Time, t2: Time): void;
  getMap(): TripleBandLinearOp;
  getL(): Real[];
  protected getLeverageFctSlice(t1: Time, t2: Time): Real[];
  protected _varianceValues: Real[];
  protected _volatilityValues: Real[];
  protected _L: Real[];
  protected _dxMap: FirstDerivativeOp;
  protected _dxxMap: TripleBandLinearOp;
  protected _mapT: TripleBandLinearOp;
  protected _mesher: FdmMesher;
  protected _rTS: YieldTermStructure;
  protected _qTS: YieldTermStructure;
  protected _quantoHelper: FdmQuantoHelper;
  protected _leverageFct: LocalVolTermStructure;
}
export declare class FdmHestonVariancePart {
  constructor(
      mesher: FdmMesher, rTS: YieldTermStructure, sigma: Real, kappa: Real,
      theta: Real);
  setTime(t1: Time, t2: Time): void;
  getMap(): TripleBandLinearOp;
  protected _dyMap: TripleBandLinearOp;
  protected _mapT: TripleBandLinearOp;
  protected _rTS: YieldTermStructure;
}
export declare class FdmHestonOp extends FdmLinearOpComposite {
  constructor(
      mesher: FdmMesher, hestonProcess: HestonProcess,
      quantoHelper?: FdmQuantoHelper, leverageFct?: LocalVolTermStructure);
  size(): Size;
  setTime(t1: Time, t2: Time): void;
  apply(u: Real[]): Real[];
  apply_direction(direction: Size, r: Real[]): Real[];
  solve_splitting(direction: Size, r: Real[], a: Real): Real[];
  preconditioner(r: Real[], dt: Real): Real[];
  private _correlationMap;
  private _dyMap;
  private _dxMap;
}

export declare class FdmHullWhiteOp extends FdmLinearOpComposite {
  constructor(mesher: FdmMesher, model: HullWhite, direction: Size);
  size(): Size;
  setTime(t1: Time, t2: Time): void;
  apply(r: Real[]): Real[];
  apply_mixed(r: Real[]): Real[];
  apply_direction(direction: Size, r: Real[]): Real[];
  solve_splitting(direction: Size, r: Real[], a: Real): Real[];
  preconditioner(r: Real[], dt: Real): Real[];
  private _direction;
  private _x;
  private _dzMap;
  private _mapT;
  private _model;
}

export declare class FdmLinearOp {
  apply(r: Real[]): Real[];
}

export declare class FdmLinearOpComposite extends FdmLinearOp {
  size(): Size;
  setTime(t1: Time, t2: Time): void;
  apply_mixed(r: Real[]): Real[];
  apply_direction(direction: Size, r: Real[]): Real[];
  solve_splitting(direction: Size, r: Real[], s: Real): Real[];
  preconditioner(r: Real[], s: Real): Real[];
  toMatrixDecomp(): SparseMatrix[];
  toMatrix(): SparseMatrix;
}

export declare class FdmLinearOpIterator {
  init1(index?: Size): FdmLinearOpIterator;
  init2(dim: Size[]): FdmLinearOpIterator;
  init3(dim: Size[], coordinates: Size[], index: Size): FdmLinearOpIterator;
  init4(from: FdmLinearOpIterator): FdmLinearOpIterator;
  plusplus(): void;
  notEqual(iterator: FdmLinearOpIterator): boolean;
  index(): Size;
  coordinates(): Size[];
  swap(iter: FdmLinearOpIterator): void;
  private _index;
  private _dim;
  private _coordinates;
}

export declare class FdmLinearOpLayout {
  constructor(dim: Size[]);
  begin(): FdmLinearOpIterator;
  end(): FdmLinearOpIterator;
  dim(): Size[];
  spacing(): Size[];
  size(): Size;
  index(coordinates: Size[]): Size;
  neighbourhood1(iterator: FdmLinearOpIterator, i: Size, offset: Integer): Size;
  neighbourhood2(
      iterator: FdmLinearOpIterator, i1: Size, offset1: Integer, i2: Size,
      offset2: Integer): Size;
  iter_neighbourhood(iterator: FdmLinearOpIterator, i: Size, offset: Integer):
      FdmLinearOpIterator;
  private _size;
  private _dim;
  private _spacing;
}

export declare class FdmOrnsteinUhlenbackOp extends FdmLinearOpComposite {
  constructor(
      mesher: FdmMesher, process: OrnsteinUhlenbeckProcess,
      rTS: YieldTermStructure, bcSet: FdmBoundaryConditionSet,
      direction?: Size);
  size(): Size;
  setTime(t1: Time, t2: Time): void;
  apply(r: Real[]): Real[];
  apply_mixed(r: Real[]): Real[];
  apply_direction(direction: Size, r: Real[]): Real[];
  solve_splitting(direction: Size, r: Real[], a: Real): Real[];
  preconditioner(r: Real[], dt: Real): Real[];
  private _mesher;
  private _process;
  private _rTS;
  _bcSet: FdmBoundaryConditionSet;
  private _direction;
  private _m;
  private _mapX;
}

export declare class FirstDerivativeOp extends TripleBandLinearOp {
  constructor(direction: Size, mesher: FdmMesher);
}

export declare class NinePointLinearOp extends FdmLinearOp {
  nplopInit1(d0: Size, d1: Size, mesher: FdmMesher): NinePointLinearOp;
  nplopInit2(m: NinePointLinearOp): NinePointLinearOp;
  apply(u: Real[]): Real[];
  mult(u: Real[]): NinePointLinearOp;
  swap(m: NinePointLinearOp): void;
  protected _d0: Size;
  protected _d1: Size;
  protected _i00: Size[];
  protected _i10: Size[];
  protected _i20: Size[];
  protected _i01: Size[];
  protected _i21: Size[];
  protected _i02: Size[];
  protected _i12: Size[];
  protected _i22: Size[];
  protected _a00: Real[];
  protected _a10: Real[];
  protected _a20: Real[];
  protected _a01: Real[];
  protected _a11: Real[];
  protected _a21: Real[];
  protected _a02: Real[];
  protected _a12: Real[];
  protected _a22: Real[];
  protected _mesher: FdmMesher;
}

export declare class NthOrderDerivativeOp extends FdmLinearOp {
  constructor(
      direction: Size, order: Size, nPoints: Integer, mesher: FdmMesher);
}

export declare class NumericalDifferentiation implements
    UnaryFunction<Real, Real> {
  init1(
      f: UnaryFunction<Real, Real>, orderOfDerivative: Size,
      x_offsets: Real[]): NumericalDifferentiation;
  init2(
      f: UnaryFunction<Real, Real>, orderOfDerivative: Size, stepSize: Real,
      steps: Size,
      scheme: NumericalDifferentiation.Scheme): NumericalDifferentiation;
  f(x: Real): Real;
  offsets(): Real[];
  weights(): Real[];
  private _offsets;
  private _w;
  private _f;
}
export declare namespace NumericalDifferentiation {
  enum Scheme { Central = 0, Backward = 1, Forward = 2 }
}

export interface Operator {
  size(): Size;
  setTime(t1: Time, t2: Time): void;
  apply(x: Real[]): Real[];
  apply_mixed(x: Real[]): Real[];
  apply_direction(direction: Size, x: Real[]): Real[];
  solve_splitting(direction: Size, x: Real[], s: Real): Real[];
  preconditioner(r: Real[], dt: Real): Real[];
}

export declare class SecondDerivativeOp extends TripleBandLinearOp {
  constructor(direction: Size, mesher: FdmMesher);
}

export declare class SecondOrderMixedDerivativeOp extends NinePointLinearOp {
  constructor(d0: Size, d1: Size, mesher: FdmMesher);
}

export declare class TripleBandLinearOp extends FdmLinearOp {
  tblopInit1(direction: Size, mesher: FdmMesher): TripleBandLinearOp;
  tblopInit2(m: TripleBandLinearOp): TripleBandLinearOp;
  apply(r: Real[]): Real[];
  solve_splitting(r: Real[], a: Real, b?: Real): Real[];
  mult(u: Real[]): TripleBandLinearOp;
  multR(u: Real[]): TripleBandLinearOp;
  add1(m: TripleBandLinearOp): TripleBandLinearOp;
  add2(u: Real[]): TripleBandLinearOp;
  axpyb(a: Real[], x: TripleBandLinearOp, y: TripleBandLinearOp, b: Real[]):
      void;
  swap(m: TripleBandLinearOp): void;
  toMatrix(): SparseMatrix;
  protected _direction: Size;
  protected _i0: Size[];
  protected _i2: Size[];
  protected _reverseIndex: Size[];
  protected _lower: Real[];
  protected _diag: Real[];
  protected _upper: Real[];
  protected _mesher: FdmMesher;
}

export declare class BoundaryConditionSchemeHelper {
  constructor(bcSet: OperatorTraits.bc_set<FdmLinearOp>);
  applyBeforeApplying(op: FdmLinearOp): void;
  applyAfterApplying1(a: Real[]): void;
  applyBeforeSolving(op: FdmLinearOp, a: Real[]): void;
  applyAfterSolving(a: Real[]): void;
  setTime(t: Time): void;
  private _bcSet;
}

export declare class CraigSneydScheme {
  constructor(
      theta: Real, mu: Real, map: FdmLinearOpComposite,
      bcSet?: OperatorTraits.bc_set<FdmLinearOp>);
  step(a: Real[], t: Time): void;
  setStep(dt: Time): void;
  protected _dt: Time;
  protected _theta: Real;
  protected _mu: Real;
  protected _map: FdmLinearOpComposite;
  protected _bcSet: BoundaryConditionSchemeHelper;
}

export declare class DouglasScheme {
  constructor(
      theta: Real, map: FdmLinearOpComposite,
      bcSet?: OperatorTraits.bc_set<FdmLinearOp>);
  step(a: Real[], t: Time): void;
  setStep(dt: Time): void;
  protected _dt: Time;
  protected _theta: Real;
  protected _map: FdmLinearOpComposite;
  protected _bcSet: BoundaryConditionSchemeHelper;
}

export declare class ExplicitEulerScheme {
  constructor(
      map: FdmLinearOpComposite, bcSet?: OperatorTraits.bc_set<FdmLinearOp>);
  step(a: Real[], t: Time): void;
  setStep(dt: Time): void;
  protected _dt: Time;
  protected _map: FdmLinearOpComposite;
  protected _bcSet: BoundaryConditionSchemeHelper;
}

export declare class HundsdorferScheme {
  constructor(
      theta: Real, mu: Real, map: FdmLinearOpComposite,
      bcSet?: OperatorTraits.bc_set<FdmLinearOp>);
  step(a: Real[], t: Time): void;
  setStep(dt: Time): void;
  protected _dt: Time;
  protected _theta: Real;
  protected _mu: Real;
  protected _map: FdmLinearOpComposite;
  protected _bcSet: BoundaryConditionSchemeHelper;
}

export declare class ImplicitEulerScheme {
  constructor(
      map: FdmLinearOpComposite, bcSet?: OperatorTraits.bc_set<FdmLinearOp>,
      relTol?: Real, solverType?: ImplicitEulerScheme.SolverType);
  step(a: Real[], t: Time): void;
  setStep(dt: Time): void;
  numberOfIterations(): Size;
  apply1(r: Real[]): Real[];
  protected _dt: Time;
  protected _iterations: Size;
  protected _relTol: Real;
  protected _map: FdmLinearOpComposite;
  protected _bcSet: BoundaryConditionSchemeHelper;
  protected _solverType: ImplicitEulerScheme.SolverType;
}
export declare namespace ImplicitEulerScheme {
  enum SolverType { BiCGstab = 0, GMRES = 1 }
}

export declare class MethodOfLinesScheme {
  constructor(
      eps: Real, relInitStepSize: Real, map: FdmLinearOpComposite,
      bcSet?: OperatorTraits.bc_set<FdmLinearOp>);
  step(a: Real[], t: Time): void;
  setStep(dt: Time): void;
  apply2(t: Time, u: Real[]): Real[];
  protected _dt: Time;
  protected _eps: Real;
  protected _relInitStepSize: Real;
  protected _map: FdmLinearOpComposite;
  protected _bcSet: BoundaryConditionSchemeHelper;
}

export declare class ModifiedCraigSneydScheme {
  constructor(
      theta: Real, mu: Real, map: FdmLinearOpComposite,
      bcSet?: OperatorTraits.bc_set<FdmLinearOp>);
  step(a: Real[], t: Time): void;
  setStep(dt: Time): void;
  protected _dt: Time;
  protected _theta: Real;
  protected _mu: Real;
  protected _map: FdmLinearOpComposite;
  protected _bcSet: BoundaryConditionSchemeHelper;
}

export interface Scheme {
  step(a: Real[], t: Time): void;
  setStep(dt: Time): void;
  numberOfIterations?(): Size;
  apply1?(r: Real[]): Real[];
  apply2?(t: Time, r: Real[]): Real[];
}
export declare type Evolver = Scheme;

export declare class TrBDF2Scheme {
  constructor(
      alpha: Real, map: FdmLinearOpComposite, trapezoidalScheme: Scheme,
      bcSet?: OperatorTraits.bc_set<FdmLinearOp>, relTol?: Real,
      solverType?: TrBDF2Scheme.SolverType);
  step(fn: Real[], t: Time): void;
  setStep(dt: Time): void;
  numberOfIterations(): Size;
  apply1(r: Real[]): Real[];
  protected _dt: Time;
  protected _beta: Real;
  protected _iterations: Size;
  protected _alpha: Real;
  protected _map: FdmLinearOpComposite;
  protected _trapezoidalScheme: Scheme;
  protected _bcSet: BoundaryConditionSchemeHelper;
  protected _relTol: Real;
  protected _solverType: TrBDF2Scheme.SolverType;
}
export declare namespace TrBDF2Scheme {
  enum SolverType { BiCGstab = 0, GMRES = 1 }
}

export declare class Fdm1DimSolver extends LazyObject {
  constructor(
      solverDesc: FdmSolverDesc, schemeDesc: FdmSchemeDesc,
      op: FdmLinearOpComposite);
  interpolateAt(x: Real): Real;
  thetaAt(x: Real): Real;
  derivativeX(x: Real): Real;
  derivativeXX(x: Real): Real;
  performCalculations(): void;
  private _solverDesc;
  private _schemeDesc;
  private _op;
  private _thetaCondition;
  private _conditions;
  private _x;
  private _initialValues;
  private _resultValues;
  private _interpolation;
}

export declare class Fdm2dBlackScholesSolver extends LazyObject {
  constructor(
      p1: Handle<GeneralizedBlackScholesProcess>,
      p2: Handle<GeneralizedBlackScholesProcess>, correlation: Real,
      solverDesc: FdmSolverDesc, schemeDesc?: FdmSchemeDesc, localVol?: boolean,
      illegalLocalVolOverwrite?: Real);
  valueAt(u: Real, v: Real): Real;
  thetaAt(u: Real, v: Real): Real;
  deltaXat(u: Real, v: Real): Real;
  deltaYat(u: Real, v: Real): Real;
  gammaXat(u: Real, v: Real): Real;
  gammaYat(u: Real, v: Real): Real;
  gammaXYat(u: Real, v: Real): Real;
  performCalculations(): void;
  private _p1;
  private _p2;
  private _correlation;
  private _solverDesc;
  private _schemeDesc;
  private _localVol;
  private _illegalLocalVolOverwrite;
  private _solver;
}

export declare class Fdm2DimSolver extends LazyObject {
  constructor(
      solverDesc: FdmSolverDesc, schemeDesc: FdmSchemeDesc,
      op: FdmLinearOpComposite);
  interpolateAt(x: Real, y: Real): Real;
  thetaAt(x: Real, y: Real): Real;
  derivativeX(x: Real, y: Real): Real;
  derivativeY(x: Real, y: Real): Real;
  derivativeXX(x: Real, y: Real): Real;
  derivativeYY(x: Real, y: Real): Real;
  derivativeXY(x: Real, y: Real): Real;
  performCalculations(): void;
  private _solverDesc;
  private _schemeDesc;
  private _op;
  private _thetaCondition;
  private _conditions;
  private _x;
  private _y;
  private _initialValues;
  private _resultValues;
  private _interpolation;
}

export declare class Fdm3DimSolver extends LazyObject {
  constructor(
      solverDesc: FdmSolverDesc, schemeDesc: FdmSchemeDesc,
      op: FdmLinearOpComposite);
  performCalculations(): void;
  interpolateAt(x: Real, y: Real, z: Rate): Real;
  thetaAt(x: Real, y: Real, z: Rate): Real;
  private _solverDesc;
  private _schemeDesc;
  private _op;
  private _thetaCondition;
  private _conditions;
  private _x;
  private _y;
  private _z;
  private _initialValues;
  private _resultValues;
  private _interpolation;
}

export declare class FdmSchemeDesc {
  constructor(type: FdmSchemeDesc.FdmSchemeType, theta: Real, mu: Real);
  type: FdmSchemeDesc.FdmSchemeType;
  theta: Real;
  mu: Real;
  static Douglas(): FdmSchemeDesc;
  static ImplicitEuler(): FdmSchemeDesc;
  static ExplicitEuler(): FdmSchemeDesc;
  static CraigSneyd(): FdmSchemeDesc;
  static ModifiedCraigSneyd(): FdmSchemeDesc;
  static Hundsdorfer(): FdmSchemeDesc;
  static ModifiedHundsdorfer(): FdmSchemeDesc;
  static MethodOfLines(eps?: Real, relInitStepSize?: Real): FdmSchemeDesc;
  static TrBDF2(): FdmSchemeDesc;
}
export declare namespace FdmSchemeDesc {
  enum FdmSchemeType {
    HundsdorferType = 0,
    DouglasType = 1,
    CraigSneydType = 2,
    ModifiedCraigSneydType = 3,
    ImplicitEulerType = 4,
    ExplicitEulerType = 5,
    MethodOfLinesType = 6,
    TrBDF2Type = 7
  }
}
export declare class FdmBackwardSolver {
  constructor(
      map: FdmLinearOpComposite, bcSet: FdmBoundaryConditionSet,
      condition: FdmStepConditionComposite, schemeDesc: FdmSchemeDesc);
  rollback(rhs: Real[], from: Time, to: Time, steps: Size, dampingSteps: Size):
      void;
  protected _map: FdmLinearOpComposite;
  protected _bcSet: FdmBoundaryConditionSet;
  protected _condition: FdmStepConditionComposite;
  protected _schemeDesc: FdmSchemeDesc;
}

export declare class FdmBatesSolver extends LazyObject {
  constructor(
      process: Handle<BatesProcess>, solverDesc: FdmSolverDesc,
      schemeDesc?: FdmSchemeDesc, integroIntegrationOrder?: Size,
      quantoHelper?: Handle<FdmQuantoHelper>);
  valueAt(s: Real, v: Real): Real;
  thetaAt(s: Real, v: Real): Real;
  deltaAt(s: Real, v: Real): Real;
  gammaAt(s: Real, v: Real): Real;
  performCalculations(): void;
  private _process;
  private _solverDesc;
  private _schemeDesc;
  private _integroIntegrationOrder;
  private _quantoHelper;
  private _solver;
}

export declare class FdmBlackScholesSolver extends LazyObject {
  constructor(
      process: Handle<GeneralizedBlackScholesProcess>, strike: Real,
      solverDesc: FdmSolverDesc, schemeDesc?: FdmSchemeDesc, localVol?: boolean,
      illegalLocalVolOverwrite?: Real);
  valueAt(s: Real): Real;
  thetaAt(s: Real): Real;
  deltaAt(s: Real): Real;
  gammaAt(s: Real): Real;
  performCalculations(): void;
  private _process;
  private _strike;
  private _solverDesc;
  private _schemeDesc;
  private _localVol;
  private _illegalLocalVolOverwrite;
  private _solver;
}

export declare class FdmG2Solver extends LazyObject {
  constructor(
      model: Handle<G2>, solverDesc: FdmSolverDesc, schemeDesc?: FdmSchemeDesc);
  valueAt(x: Real, y: Real): Real;
  performCalculations(): void;
  private _model;
  private _solverDesc;
  private _schemeDesc;
  private _solver;
}

export declare class FdmHestonHullWhiteSolver extends LazyObject {
  constructor(
      hestonProcess: Handle<HestonProcess>, hwProcess: Handle<HullWhiteProcess>,
      corrEquityShortRate: Rate, solverDesc: FdmSolverDesc,
      schemeDesc?: FdmSchemeDesc);
  valueAt(s: Real, v: Real, r: Rate): Real;
  thetaAt(s: Real, v: Real, r: Rate): Real;
  deltaAt(s: Real, v: Real, r: Rate, eps: Real): Real;
  gammaAt(s: Real, v: Real, r: Rate, eps: Real): Real;
  performCalculations(): void;
  private _hestonProcess;
  private _hwProcess;
  private _corrEquityShortRate;
  private _solverDesc;
  private _schemeDesc;
  private _solver;
}

export declare class FdmHestonSolver extends LazyObject {
  constructor(
      process: Handle<HestonProcess>, solverDesc: FdmSolverDesc,
      schemeDesc?: FdmSchemeDesc, quantoHelper?: Handle<FdmQuantoHelper>,
      leverageFct?: LocalVolTermStructure);
  valueAt(s: Real, v: Real): Real;
  thetaAt(s: Real, v: Real): Real;
  deltaAt(s: Real, v: Real): Real;
  gammaAt(s: Real, v: Real): Real;
  meanVarianceDeltaAt(s: Real, v: Real): Real;
  meanVarianceGammaAt(s: Real, v: Real): Real;
  performCalculations(): void;
  private _process;
  private _solverDesc;
  private _schemeDesc;
  private _quantoHelper;
  private _leverageFct;
  private _solver;
}

export declare class FdmHullWhiteSolver extends LazyObject {
  constructor(
      model: Handle<HullWhite>, solverDesc: FdmSolverDesc,
      schemeDesc?: FdmSchemeDesc);
  valueAt(r: Real): Real;
  performCalculations(): void;
  private _model;
  private _solverDesc;
  private _schemeDesc;
  private _solver;
}

export declare class FdmNdimSolver extends LazyObject {
  constructor(N: Size);
  fdmndsInit(
      solverDesc: FdmSolverDesc, schemeDesc: FdmSchemeDesc,
      op: FdmLinearOpComposite): FdmNdimSolver;
  interpolateAt(x: Real[]): Real;
  thetaAt(x: Real[]): Real;
  performCalculations(): void;
  static setValue(f: Real[][], x: Size[], value: Real): void;
  N: Size;
  private _solverDesc;
  private _schemeDesc;
  private _op;
  private _thetaCondition;
  private _conditions;
  private _x;
  private _initialValues;
  private _extrapolation;
  private _f;
  private _interp;
}

export declare class FdmSimple2dBSSolver extends LazyObject {
  constructor(
      process: Handle<GeneralizedBlackScholesProcess>, strike: Real,
      solverDesc: FdmSolverDesc, schemeDesc?: FdmSchemeDesc);
  valueAt(s: Real, a: Real): Real;
  thetaAt(s: Real, a: Real): Real;
  deltaAt(s: Real, a: Real, eps: Real): Real;
  gammaAt(s: Real, a: Real, eps: Real): Real;
  performCalculations(): void;
  private _process;
  private _strike;
  private _solverDesc;
  private _schemeDesc;
  private _solver;
}

export declare class FdmSolverDesc {
  constructor(
      mesher: FdmMesher, bcSet: FdmBoundaryConditionSet,
      condition: FdmStepConditionComposite, calculator: FdmInnerValueCalculator,
      maturity: Time, timeSteps: Size, dampingSteps: Size);
  mesher: FdmMesher;
  bcSet: FdmBoundaryConditionSet;
  condition: FdmStepConditionComposite;
  calculator: FdmInnerValueCalculator;
  maturity: Time;
  timeSteps: Size;
  dampingSteps: Size;
}

export declare class FdmAmericanStepCondition extends StepCondition {
  constructor(mesher: FdmMesher, calculator: FdmInnerValueCalculator);
  applyTo(a: Real[], t: Time): void;
  private _mesher;
  private _calculator;
}

export declare class FdmArithmeticAverageCondition extends StepCondition {
  constructor(
      averageTimes: Time[], z: Real, pastFixings: Size, mesher: FdmMesher,
      equityDirection: Size);
  applyTo(a: Real[], t: Time): void;
  private _x;
  private _a;
  private _averageTimes;
  private _pastFixings;
  private _mesher;
  private _equityDirection;
}

export declare class FdmBermudanStepCondition extends StepCondition {
  constructor(
      exerciseDates: Date[], referenceDate: Date, dayCounter: DayCounter,
      mesher: FdmMesher, calculator: FdmInnerValueCalculator);
  applyTo(a: Real[], t: Time): void;
  exerciseTimes(): Time[];
  private _exerciseTimes;
  private _mesher;
  private _calculator;
}

export declare class FdmSimpleStorageCondition extends StepCondition {
  constructor(
      exerciseTimes: Time[], mesher: FdmMesher,
      calculator: FdmInnerValueCalculator, changeRate: Real);
  applyTo(a: Real[], t: Time): void;
  private _exerciseTimes;
  private _mesher;
  private _calculator;
  private _changeRate;
  private _x;
  private _y;
}

export declare class FdmSimpleSwingCondition extends StepCondition {
  constructor(
      exerciseTimes: Time[], mesher: FdmMesher,
      calculator: FdmInnerValueCalculator, swingDirection: Size,
      minExercises?: Size);
  applyTo(a: Real[], t: Time): void;
  private _exerciseTimes;
  private _mesher;
  private _calculator;
  private _minExercises;
  private _swingDirection;
}

export declare class FdmSnapshotCondition extends StepCondition {
  constructor(t: Time);
  applyTo(a: Real[], t: Time): void;
  getTime(): Time;
  getValues(): Real[];
  private _t;
  private _values;
}

export declare class FdmStepConditionComposite extends StepCondition {
  constructor(stoppingTimes: Time[][], conditions: StepCondition[]);
  applyTo(a: Real[], t: Time): void;
  stoppingTimes(): Time[];
  conditions(): StepCondition[];
  static joinConditions(
      c1: FdmSnapshotCondition,
      c2: FdmStepConditionComposite): FdmStepConditionComposite;
  static vanillaComposite(
      cashFlow: DividendSchedule, exercise: Exercise, mesher: FdmMesher,
      calculator: FdmInnerValueCalculator, refDate: Date,
      dayCounter: DayCounter): FdmStepConditionComposite;
  private _stoppingTimes;
  private _conditions;
}
export declare namespace FdmStepConditionComposite {
  type Conditions = StepCondition[];
}

export declare class FdmAffineModelSwapInnerValue extends
    FdmInnerValueCalculator {}

export declare class FdmAffineModelTermStructure extends YieldTermStructure {}

export declare type FdmBoundaryConditionSet =
    OperatorTraits.bc_set<FdmLinearOp>;

export declare class FdmDirichletBoundary extends
    BoundaryCondition<FdmLinearOp> {
  constructor(
      mesher: FdmMesher, valueOnBoundary: Real, direction: Size,
      side: BoundaryCondition.Side);
  applyBeforeApplying(op: FdmLinearOp): void;
  applyBeforeSolving(op: FdmLinearOp, rhs: Real[]): void;
  applyAfterApplying1(x: Real[]): void;
  applyAfterSolving(rhs: Real[]): void;
  setTime(t: Time): void;
  applyAfterApplying2(x: Real, value: Real): Real;
  private _side;
  private _valueOnBoundary;
  private _indices;
  private _xExtreme;
}

export declare class FdmDividendHandler extends StepCondition {
  constructor(
      schedule: DividendSchedule, mesher: FdmMesher, referenceDate: Date,
      dayCounter: DayCounter, equityDirection: Size);
  applyTo(a: Real[], t: Time): void;
  dividendTimes(): Time[];
  dividendDates(): Date[];
  dividends(): Real[];
  private _x;
  private _dividendTimes;
  private _dividendDates;
  private _dividends;
  private _mesher;
  private _equityDirection;
}

export declare class FdmIndicesOnBoundary {
  constructor(
      layout: FdmLinearOpLayout, direction: Size, side: BoundaryCondition.Side);
  getIndices(): Size[];
  private _indices;
}

export declare class FdmInnerValueCalculator {
  innerValue(iter: FdmLinearOpIterator, t: Time): Real;
  avgInnerValue(iter: FdmLinearOpIterator, t: Time): Real;
}
export declare class FdmLogInnerValue extends FdmInnerValueCalculator {
  constructor(payoff: Payoff, mesher: FdmMesher, direction: Size);
  innerValue(iter: FdmLinearOpIterator, t: Time): Real;
  avgInnerValue(iter: FdmLinearOpIterator, t: Time): Real;
  private avgInnerValueCalc;
  private _payoff;
  private _mesher;
  private _direction;
  private _avgInnerValues;
}
export declare class FdmLogBasketInnerValue extends FdmInnerValueCalculator {
  constructor(payoff: BasketPayoff, mesher: FdmMesher);
  innerValue(iter: FdmLinearOpIterator, t: Time): Real;
  avgInnerValue(iter: FdmLinearOpIterator, t: Time): Real;
  private _payoff;
  private _mesher;
}
export declare class FdmZeroInnerValue extends FdmInnerValueCalculator {
  innerValue(iter: FdmLinearOpIterator, t: Time): Real;
  avgInnerValue(iter: FdmLinearOpIterator, t: Time): Real;
}

export declare class FdmMesherIntegral {
  constructor(
      mesher: FdmMesherComposite,
      integrator1d: BinaryFunction<Real[], Real[], Real>);
  integrate(f: Real[]): Real;
  private _meshers;
  private _integrator1d;
}

export declare class FdmQuantoHelper extends Observable {
  constructor(
      rTS: YieldTermStructure, fTS: YieldTermStructure,
      fxVolTS: BlackVolTermStructure, equityFxCorrelation: Real,
      exchRateATMlevel: Real);
  quantoAdjustment1(equityVol: Volatility, t1: Time, t2: Time): Rate;
  quantoAdjustment2(equityVol: Real[], t1: Time, t2: Time): Real[];
  _rTS: YieldTermStructure;
  _fTS: YieldTermStructure;
  _fxVolTS: BlackVolTermStructure;
  _equityFxCorrelation: Real;
  _exchRateATMlevel: Real;
}

export declare class FdmTimeDepDirichletBoundary extends
    BoundaryCondition<FdmLinearOp> {}

export declare class BootstrapError implements UnaryFunction<Rate, Real> {
  constructor(
      traits: Traits, curve: Curve, helper: BootstrapHelper, segment: Size);
  f(guess: Rate): Real;
  helper(): BootstrapHelper;
  traits: Traits;
  private _curve;
  private _helper;
  private _segment;
}

export declare namespace Pillar {
  enum Choice { MaturityDate = 0, LastRelevantDate = 1, CustomDate = 2 }
}
export declare class BootstrapHelper extends ObserverObservable {
  bshInit1(quote: Handle<Quote>): BootstrapHelper;
  bshInit2(quote: Real): BootstrapHelper;
  quote(): Handle<Quote>;
  impliedQuote(): Real;
  quoteError(): Real;
  setTermStructure(t: any): void;
  earliestDate(): Date;
  maturityDate(): Date;
  latestRelevantDate(): Date;
  pillarDate(): Date;
  latestDate(): Date;
  update(): void;
  accept(v: AcyclicVisitor): void;
  protected _quote: Handle<Quote>;
  protected _termStructure: Curve;
  protected _earliestDate: Date;
  protected _latestDate: Date;
  protected _maturityDate: Date;
  protected _latestRelevantDate: Date;
  protected _pillarDate: Date;
}
export declare class RelativeDateBootstrapHelper extends BootstrapHelper {
  rdbshInit1(quote: Handle<Quote>): void;
  rdbshInit2(quote: Real): void;
  update(): void;
  protected initializeDates(): void;
  protected _evaluationDate: Date;
}
export declare class BootstrapHelperSorter implements
    BinaryFunction<BootstrapHelper, BootstrapHelper, Real> {
  f(h1: BootstrapHelper, h2: BootstrapHelper): Real;
}

export interface YieldCurve extends YieldTermStructure {
  curveInit1(
      dates: Date[], dfs: DiscountFactor[], dayCounter: DayCounter,
      calendar?: Calendar, jumps?: Array<Handle<Quote>>,
      jumpDates?: Date[]): YieldCurve;
  curveInit2(
      dates: Date[], dfs: DiscountFactor[], dayCounter: DayCounter,
      calendar: Calendar): YieldCurve;
  curveInit3(dates: Date[], dfs: DiscountFactor[], dayCounter: DayCounter):
      YieldCurve;
  curveInit4(
      dayCounter: DayCounter, jumps?: Array<Handle<Quote>>,
      jumpDates?: Date[]): YieldCurve;
  curveInit5(
      referenceDate: Date, dayCounter: DayCounter, jumps?: Array<Handle<Quote>>,
      jumpDates?: Date[]): YieldCurve;
  curveInit6(
      settlementDays: Natural, calendar: Calendar, dayCounter: DayCounter,
      jumps?: Array<Handle<Quote>>, jumpDates?: Date[]): YieldCurve;
  _maxDate: Date;
  _data: Real[];
  _times: Time[];
  _interpolator: Interpolator;
  _interpolation: Interpolation;
  data(): Real[];
  times(): Time[];
  dates(): Date[];
  maxDate(): Date;
  nodes(): Array<[Date, Real]>;
  _dates?: Date[];
  _accuracy?: Real;
  _instruments?: BootstrapHelper[];
  _traits?: Traits;
  zeroYieldImpl?(t: Time): DiscountFactor;
}
export interface DefaultCurve extends DefaultProbabilityTermStructure {
  curveInit1(
      dates: Date[], dfs: DiscountFactor[], dayCounter: DayCounter,
      calendar?: Calendar, jumps?: Array<Handle<Quote>>, jumpDates?: Date[],
      interpolator?: Interpolator): DefaultCurve;
  curveInit2(
      dates: Date[], dfs: DiscountFactor[], dayCounter: DayCounter,
      calendar: Calendar, interpolator?: Interpolator): DefaultCurve;
  curveInit3(
      dates: Date[], dfs: DiscountFactor[], dayCounter: DayCounter,
      interpolator?: Interpolator): DefaultCurve;
  curveInit4(
      dayCounter: DayCounter, jumps?: Array<Handle<Quote>>, jumpDates?: Date[],
      interpolator?: Interpolator): DefaultCurve;
  curveInit5(
      referenceDate: Date, dayCounter: DayCounter, jumps?: Array<Handle<Quote>>,
      jumpDates?: Date[], interpolator?: Interpolator): DefaultCurve;
  curveInit6(
      settlementDays: Natural, calendar: Calendar, dayCounter: DayCounter,
      jumps?: Array<Handle<Quote>>, jumpDates?: Date[],
      interpolator?: Interpolator): DefaultCurve;
  curveInit7?
      (referenceDate: Date, dayCounter: DayCounter, model: OneFactorAffineModel,
       jumps?: Array<Handle<Quote>>, jumpDates?: Date[],
       interpolator?: Interpolator): DefaultCurve;
  _maxDate: Date;
  _data: Real[];
  _times: Time[];
  _interpolator: Interpolator;
  _interpolation: Interpolation;
  data(): Real[];
  times(): Time[];
  dates(): Date[];
  maxDate(): Date;
  nodes(): Array<[Date, Real]>;
  _dates?: Date[];
  _accuracy?: Real;
  _instruments?: BootstrapHelper[];
  _traits?: Traits;
  hazardRateImpl?(t: Time): Real;
}
export interface InflationCurve extends InflationTermStructure {
  curveInit1(
      referenceDate: Date, calendar: Calendar, dayCounter: DayCounter,
      lag: Period, frequency: Frequency, indexIsInterpolated: boolean,
      yTS: Handle<YieldTermStructure>, dates: Date[], rates: Rate[],
      interpolator?: Interpolator): InflationCurve;
  curveInit2(
      referenceDate: Date, calendar: Calendar, dayCounter: DayCounter,
      baseRate: Rate, lag: Period, frequency: Frequency,
      indexIsInterpolated: boolean, yTS: Handle<YieldTermStructure>,
      interpolator?: Interpolator): InflationCurve;
  _maxDate: Date;
  _data: Real[];
  _times: Time[];
  _interpolator: Interpolator;
  _interpolation: Interpolation;
  data(): Real[];
  times(): Time[];
  dates(): Date[];
  maxDate(): Date;
  nodes(): Array<[Date, Real]>;
  baseDate(): Date;
  _dates?: Date[];
  _accuracy?: Real;
  _instruments?: BootstrapHelper[];
  _traits?: Traits;
  yoyRateImpl?(t: Time): DiscountFactor;
  zeroRateImpl?(t: Time): DiscountFactor;
}
export interface VolatilityCurve extends VolatilityTermStructure {
  curveInit1?
      (settlementDays: Natural, cal: Calendar, bdc: BusinessDayConvention,
       dc: DayCounter, lag: Period, frequency: Frequency,
       indexIsInterpolated: boolean, d: Date[], v: Volatility[],
       minStrike: Rate, maxStrike: Rate, i?: Interpolator): VolatilityCurve;
  curveInit2?
      (settlementDays: Natural, cal: Calendar, bdc: BusinessDayConvention,
       dc: DayCounter, lag: Period, frequency: Frequency,
       indexIsInterpolated: boolean, minStrike: Rate, maxStrike: Rate,
       baseYoYVolatility: Volatility, i?: Interpolator): VolatilityCurve;
  _maxDate: Date;
  _data: Real[];
  _times: Time[];
  _interpolator: Interpolator;
  _interpolation: Interpolation;
  data(): Real[];
  times(): Time[];
  dates(): Date[];
  maxDate(): Date;
  nodes(): Array<[Date, Real]>;
  baseDate(): Date;
  _dates?: Date[];
  _accuracy?: Real;
  _instruments?: BootstrapHelper[];
  _traits?: Traits;
  volatilityImpl?(t: Time, r: Rate): DiscountFactor;
}

export declare class DefaultProbabilityTermStructure extends TermStructure {
  dptInit1(dc?: DayCounter, jumps?: Array<Handle<Quote>>, jumpDates?: Date[]):
      DefaultProbabilityTermStructure;
  dptInit2(
      referenceDate: Date, calendar?: Calendar, dc?: DayCounter,
      jumps?: Array<Handle<Quote>>,
      jumpDates?: Date[]): DefaultProbabilityTermStructure;
  dptInit3(
      settlementDays: Natural, calendar: Calendar, dc?: DayCounter,
      jumps?: Array<Handle<Quote>>,
      jumpDates?: Date[]): DefaultProbabilityTermStructure;
  survivalProbability1(d: Date, extrapolate?: boolean): Probability;
  survivalProbability2(t: Time, extrapolate?: boolean): Probability;
  defaultProbability1(d: Date, extrapolate?: boolean): Probability;
  defaultProbability2(t: Time, extrapolate?: boolean): Probability;
  defaultProbability3(d1: Date, d2: Date, extrapolate?: boolean): Probability;
  defaultProbability4(t1: Time, t2: Time, extrapolate?: boolean): Probability;
  defaultDensity1(d: Date, extrapolate?: boolean): Real;
  defaultDensity2(t: Time, extrapolate?: boolean): Real;
  hazardRate1(d: Date, extrapolate?: boolean): Rate;
  hazardRate2(t: Time, extrapolate?: boolean): Rate;
  jumpDates(): Date[];
  jumpTimes(): Time[];
  update(): void;
  survivalProbabilityImpl(t: Time): Probability;
  defaultDensityImpl(t: Time): Real;
  setJumps(): void;
  _jumps: Array<Handle<Quote>>;
  _jumpDates: Date[];
  _jumpTimes: Time[];
  _nJumps: Size;
  _latestReference: Date;
}

export declare class InflationTermStructure extends TermStructure {
  itsInit1(
      baseRate: Rate, observationLag: Period, frequency: Frequency,
      indexIsInterpolated: boolean, yTS: Handle<YieldTermStructure>,
      dayCounter?: DayCounter,
      seasonality?: Seasonality): InflationTermStructure;
  itsInit2(
      referenceDate: Date, baseRate: Rate, observationLag: Period,
      frequency: Frequency, indexIsInterpolated: boolean,
      yTS: Handle<YieldTermStructure>, calendar?: Calendar,
      dayCounter?: DayCounter,
      seasonality?: Seasonality): InflationTermStructure;
  itsInit3(
      settlementDays: Natural, calendar: Calendar, baseRate: Rate,
      observationLag: Period, frequency: Frequency,
      indexIsInterpolated: boolean, yTS: Handle<YieldTermStructure>,
      dayCounter?: DayCounter,
      seasonality?: Seasonality): InflationTermStructure;
  observationLag(): Period;
  frequency(): Frequency;
  indexIsInterpolated(): boolean;
  baseRate(): Rate;
  nominalTermStructure(): Handle<YieldTermStructure>;
  baseDate(): Date;
  setSeasonality(seasonality?: Seasonality): void;
  seasonality(): Seasonality;
  hasSeasonality(): boolean;
  setBaseRate(r: Rate): void;
  checkRange1(d: Date, extrapolate: boolean): void;
  checkRange2(t: Time, extrapolate: boolean): void;
  _seasonality: Seasonality;
  _observationLag: Period;
  _frequency: Frequency;
  _indexIsInterpolated: boolean;
  _baseRate: Rate;
  _nominalTermStructure: Handle<YieldTermStructure>;
}
export declare class ZeroInflationTermStructure extends InflationTermStructure {
  zitsInit1(
      dayCounter: DayCounter, baseZeroRate: Rate, lag: Period,
      frequency: Frequency, indexIsInterpolated: boolean,
      yTS: Handle<YieldTermStructure>,
      seasonality?: Seasonality): ZeroInflationTermStructure;
  zitsInit2(
      referenceDate: Date, calendar: Calendar, dayCounter: DayCounter,
      baseZeroRate: Rate, lag: Period, frequency: Frequency,
      indexIsInterpolated: boolean, yTS: Handle<YieldTermStructure>,
      seasonality?: Seasonality): ZeroInflationTermStructure;
  zitsInit3(
      settlementDays: Natural, calendar: Calendar, dayCounter: DayCounter,
      baseZeroRate: Rate, lag: Period, frequency: Frequency,
      indexIsInterpolated: boolean, yTS: Handle<YieldTermStructure>,
      seasonality?: Seasonality): ZeroInflationTermStructure;
  zeroRate1(
      d: Date, instObsLag?: Period, forceLinearInterpolation?: boolean,
      extrapolate?: boolean): Rate;
  zeroRate2(t: Time, extrapolate?: boolean): Rate;
  zeroRateImpl(t: Time): Rate;
}
export declare class YoYInflationTermStructure extends InflationTermStructure {
  yoyitsInit1(
      dayCounter: DayCounter, baseYoYRate: Rate, lag: Period,
      frequency: Frequency, indexIsInterpolated: boolean,
      yieldTS: Handle<YieldTermStructure>,
      seasonality: Seasonality): YoYInflationTermStructure;
  yoyitsInit2(
      referenceDate: Date, calendar: Calendar, dayCounter: DayCounter,
      baseZeroRate: Rate, lag: Period, frequency: Frequency,
      indexIsInterpolated: boolean, yTS: Handle<YieldTermStructure>,
      seasonality?: Seasonality): YoYInflationTermStructure;
  yoyitsInit3(
      settlementDays: Natural, calendar: Calendar, dayCounter: DayCounter,
      baseZeroRate: Rate, lag: Period, frequency: Frequency,
      indexIsInterpolated: boolean, yTS: Handle<YieldTermStructure>,
      seasonality?: Seasonality): YoYInflationTermStructure;
  yoyRate1(
      d: Date, instObsLag?: Period, forceLinearInterpolation?: boolean,
      extrapolate?: boolean): Rate;
  yoyRate2(t: Time, extrapolate?: boolean): Rate;
  yoyRateImpl(t: Time): Rate;
}
export declare function inflationPeriod(
    d: Date, frequency: Frequency): [Date, Date];
export declare function inflationYearFraction(
    f: Frequency, indexIsInterpolated: boolean, dayCounter: DayCounter,
    d1: Date, d2: Date): Time;

export declare class InterpolatedCurve {
  icInit1(times: Time[], data: Real[], i: Interpolator): InterpolatedCurve;
  icInit2(times: Time[], i: Interpolator): InterpolatedCurve;
  icInit3(n: Size, i: Interpolator): InterpolatedCurve;
  icInit4(i: Interpolator): InterpolatedCurve;
  icInit5(c: InterpolatedCurve): InterpolatedCurve;
  setupInterpolation(): void;
  _times: Time[];
  _data: Real[];
  _interpolation: Interpolation;
  _interpolator: Interpolator;
  _maxDate: Date;
}

export declare class IterativeBootstrap {
  constructor(traits: Traits, interplolator: Interpolator);
  setup(ts: any): void;
  calculate(): void;
  private initialize;
  _traits: Traits;
  _interpolator: Interpolator;
  private _ts;
  private _n;
  private _firstSolver;
  private _solver;
  private _initialized;
  private _validCurve;
  private _loopRequired;
  private _firstAliveHelper;
  private _alive;
  private _previousData;
  private _errors;
}

export declare class PenaltyFunction extends CostFunction {
  constructor(
      curve: Curve, initialIndex: Size, helper: BootstrapHelper[],
      rateHelpersStart: Size, rateHelpersEnd: Size);
  value(x: Real[]): Real;
  values(x: Real[]): Real[];
  private _curve;
  private _initialIndex;
  private _localisation;
  private _helper;
  private _rateHelpersStart;
  private _rateHelpersEnd;
}
export declare class LocalBootstrap {
  constructor(
      traits: Traits, interplolator: Interpolator, localisation?: Size,
      forcePositive?: boolean);
  setup(ts: any): void;
  calculate(): void;
  _traits: Traits;
  _interpolator: Interpolator;
  private _validCurve;
  private _ts;
  private _localisation;
  private _forcePositive;
}

export declare type Traits = Discount | ZeroYield | ForwardRate |
    ZeroInflationTraits | YoYInflationTraits | SurvivalProbability |
    HazardRate | DefaultDensity | YoYInflationVolatilityTraits;
export declare namespace Traits {
  function yieldcurve(t: Traits): YieldCurve;
  function inflationcurve(t: Traits): InflationCurve;
  function defaultcurve(t: Traits): DefaultCurve;
  function initialDate(t: Traits, c: Curve): Date;
  function initialValue(t: Traits, c: Curve): Real;
  function maxIterations(t: Traits): Size;
  function minValueAfter(
      t: Traits, i: Size, c: Curve, validData: boolean, s: Size): Real;
  function maxValueAfter(
      t: Traits, i: Size, c: Curve, validData: boolean, s: Size): Real;
  function guess(
      t: Traits, i: Size, c: Curve, validData: boolean, s: Size): Real;
  function updateGuess(t: Traits, data: Real[], discount: Real, i: Size): void;
}

export declare class VolatilityTermStructure extends TermStructure {
  vtsInit1(bdc: BusinessDayConvention, dc?: DayCounter):
      VolatilityTermStructure;
  vtsInit2(
      referenceDate: Date, cal: Calendar, bdc: BusinessDayConvention,
      dc?: DayCounter): VolatilityTermStructure;
  vtsInit3(
      settlementDays: Natural, cal: Calendar, bdc: BusinessDayConvention,
      dc?: DayCounter): VolatilityTermStructure;
  businessDayConvention(): BusinessDayConvention;
  optionDateFromTenor(p: Period): Date;
  minStrike(): Rate;
  maxStrike(): Rate;
  checkStrike(k: Rate, extrapolate: boolean): void;
  _bdc: BusinessDayConvention;
}

export declare class YieldTermStructure extends TermStructure {
  ytsInit1(dc?: DayCounter, jumps?: Array<Handle<Quote>>, jumpDates?: Date[]):
      YieldTermStructure;
  ytsInit2(
      referenceDate: Date, calendar?: Calendar, dc?: DayCounter,
      jumps?: Array<Handle<Quote>>, jumpDates?: Date[]): YieldTermStructure;
  ytsInit3(
      settlementDays: Natural, calendar: Calendar, dc?: DayCounter,
      jumps?: Array<Handle<Quote>>, jumpDates?: Date[]): YieldTermStructure;
  discount1(d: Date, extrapolate?: boolean): DiscountFactor;
  discount2(t: Time, extrapolate?: boolean): DiscountFactor;
  zeroRate1(
      d: Date, dayCounter: DayCounter, comp: Compounding, freq?: Frequency,
      extrapolate?: boolean): InterestRate;
  zeroRate2(
      t: Time, comp: Compounding, freq?: Frequency,
      extrapolate?: boolean): InterestRate;
  forwardRate1(
      d1: Date, d2: Date, dayCounter: DayCounter, comp: Compounding,
      freq?: Frequency, extrapolate?: boolean): InterestRate;
  forwardRate2(
      d: Date, p: Period, dayCounter: DayCounter, comp: Compounding,
      freq?: Frequency, extrapolate?: boolean): InterestRate;
  forwardRate3(
      t1: Time, t2: Time, comp: Compounding, freq?: Frequency,
      extrapolate?: boolean): InterestRate;
  jumpDates(): Date[];
  jumpTimes(): Time[];
  update(): void;
  discountImpl(t: Time): DiscountFactor;
  setJumps(): void;
  _jumps: Array<Handle<Quote>>;
  _jumpDates: Date[];
  _jumpTimes: Time[];
  _nJumps: Size;
  _latestReference: Date;
}

export declare class DefaultDensityStructure extends
    DefaultProbabilityTermStructure {}

export declare type DefaultProbabilityHelper = BootstrapHelper;
export declare type RelativeDateDefaultProbabilityHelper =
    RelativeDateBootstrapHelper;
export declare class CdsHelper extends RelativeDateBootstrapHelper {
  cdshInit1(
      quote: Handle<Quote>, tenor: Period, settlementDays: Integer,
      calendar: Calendar, frequency: Frequency,
      paymentConvention: BusinessDayConvention, rule: DateGeneration.Rule,
      dayCounter: DayCounter, recoveryRate: Real,
      discountCurve: Handle<YieldTermStructure>, settlesAccrual?: boolean,
      paysAtDefaultTime?: boolean, startDate?: Date,
      lastPeriodDayCounter?: DayCounter, rebatesAccrual?: boolean,
      model?: CreditDefaultSwap.PricingModel): CdsHelper;
  cdshInit2(
      quote: Rate, tenor: Period, settlementDays: Integer, calendar: Calendar,
      frequency: Frequency, paymentConvention: BusinessDayConvention,
      rule: DateGeneration.Rule, dayCounter: DayCounter, recoveryRate: Real,
      discountCurve: Handle<YieldTermStructure>, settlesAccrual?: boolean,
      paysAtDefaultTime?: boolean, startDate?: Date,
      lastPeriodDayCounter?: DayCounter, rebatesAccrual?: boolean,
      model?: CreditDefaultSwap.PricingModel): CdsHelper;
}
export declare class SpreadCdsHelper extends CdsHelper {
  scdshInit1(
      runningSpread: Handle<Quote>, tenor: Period, settlementDays: Integer,
      calendar: Calendar, frequency: Frequency,
      paymentConvention: BusinessDayConvention, rule: DateGeneration.Rule,
      dayCounter: DayCounter, recoveryRate: Real,
      discountCurve: Handle<YieldTermStructure>, settlesAccrual?: boolean,
      paysAtDefaultTime?: boolean, startDate?: Date,
      lastPeriodDayCounter?: DayCounter, rebatesAccrual?: boolean,
      model?: CreditDefaultSwap.PricingModel): SpreadCdsHelper;
  scdshInit2(
      runningSpread: Rate, tenor: Period, settlementDays: Integer,
      calendar: Calendar, frequency: Frequency,
      paymentConvention: BusinessDayConvention, rule: DateGeneration.Rule,
      dayCounter: DayCounter, recoveryRate: Real,
      discountCurve: Handle<YieldTermStructure>, settlesAccrual?: boolean,
      paysAtDefaultTime?: boolean, startDate?: Date,
      lastPeriodDayCounter?: DayCounter, rebatesAccrual?: boolean,
      model?: CreditDefaultSwap.PricingModel): SpreadCdsHelper;
}
export declare class UpfrontCdsHelper extends CdsHelper {
  ufcdshInit1(
      upfront: Handle<Quote>, runningSpread: Rate, tenor: Period,
      settlementDays: Integer, calendar: Calendar, frequency: Frequency,
      paymentConvention: BusinessDayConvention, rule: DateGeneration.Rule,
      dayCounter: DayCounter, recoveryRate: Real,
      discountCurve: Handle<YieldTermStructure>,
      upfrontSettlementDays?: Natural, settlesAccrual?: boolean,
      paysAtDefaultTime?: boolean, startDate?: Date,
      lastPeriodDayCounter?: DayCounter, rebatesAccrual?: boolean,
      model?: CreditDefaultSwap.PricingModel): UpfrontCdsHelper;
  ufcdshInit2(
      upfront: Rate, runningSpread: Rate, tenor: Period,
      settlementDays: Integer, calendar: Calendar, frequency: Frequency,
      paymentConvention: BusinessDayConvention, rule: DateGeneration.Rule,
      dayCounter: DayCounter, recoveryRate: Real,
      discountCurve: Handle<YieldTermStructure>,
      upfrontSettlementDays?: Natural, settlesAccrual?: boolean,
      paysAtDefaultTime?: boolean, startDate?: Date,
      lastPeriodDayCounter?: DayCounter, rebatesAccrual?: boolean,
      model?: CreditDefaultSwap.PricingModel): UpfrontCdsHelper;
}

export declare class FlatHazardRate extends HazardRateStructure {
  fhrInit1(referenceDate: Date, hazardRate: Handle<Quote>, dc: DayCounter):
      FlatHazardRate;
  fhrInit2(referenceDate: Date, hazardRate: Rate, dc: DayCounter):
      FlatHazardRate;
  fhrInit3(
      settlementDays: Natural, calendar: Calendar, hazardRate: Handle<Quote>,
      dc: DayCounter): FlatHazardRate;
  fhrInit4(
      settlementDays: Natural, calendar: Calendar, hazardRate: Rate,
      dc: DayCounter): FlatHazardRate;
  maxDate(): Date;
  hazardRateImpl(t: Time): Rate;
  survivalProbabilityImpl(t: Time): Probability;
  private _hazardRate;
}

export declare class HazardRateStructure extends
    DefaultProbabilityTermStructure {
  hazardRateImpl(t: Time): Real;
  survivalProbabilityImpl(t: Time): Probability;
  defaultDensityImpl(t: Time): Real;
}

export declare class InterpolatedDefaultDensityCurve extends
    DefaultDensityStructureInterpolatedCurve {
  constructor(interpolator?: Interpolator);
  curveInit1(
      dates: Date[], densities: Rate[], dayCounter: DayCounter, cal?: Calendar,
      jumps?: Array<Handle<Quote>>, jumpDates?: Date[],
      interpolator?: Interpolator): DefaultCurve;
  curveInit2(
      dates: Date[], densities: Rate[], dayCounter: DayCounter, cal?: Calendar,
      interpolator?: Interpolator): DefaultCurve;
  curveInit3(
      dates: Date[], densities: Rate[], dayCounter: DayCounter,
      interpolator?: Interpolator): DefaultCurve;
  curveInit4(
      dayCounter: DayCounter, jumps?: Array<Handle<Quote>>, jumpDates?: Date[],
      interpolator?: Interpolator): DefaultCurve;
  curveInit5(
      referenceDate: Date, dayCounter: DayCounter, jumps?: Array<Handle<Quote>>,
      jumpDates?: Date[], interpolator?: Interpolator): DefaultCurve;
  curveInit6(
      settlementDays: Natural, calendar: Calendar, dayCounter: DayCounter,
      jumps?: Array<Handle<Quote>>, jumpDates?: Date[],
      interpolator?: Interpolator): DefaultCurve;
  maxDate(): Date;
  times(): Time[];
  dates(): Date[];
  data(): Real[];
  defaultDensities(): Rate[];
  nodes(): Array<[Date, Real]>;
  defaultDensityImpl(t: Time): Real;
  survivalProbabilityImpl(t: Time): Probability;
  private initialize;
  _dates: Date[];
  _interpolator: Interpolator;
}

export declare class InterpolatedHazardRateCurve extends
    HazardRateStructureInterpolatedCurve implements DefaultCurve {
  constructor(interplolator?: Interpolator);
  curveInit1(
      dates: Date[], hazardRates: Rate[], dayCounter: DayCounter,
      cal?: Calendar, jumps?: Array<Handle<Quote>>, jumpDates?: Date[],
      interpolator?: Interpolator): DefaultCurve;
  curveInit2(
      dates: Date[], hazardRates: Rate[], dayCounter: DayCounter,
      cal?: Calendar, interpolator?: Interpolator): DefaultCurve;
  curveInit3(
      dates: Date[], hazardRates: Rate[], dayCounter: DayCounter,
      interpolator?: Interpolator): DefaultCurve;
  curveInit4(
      dayCounter: DayCounter, jumps?: Array<Handle<Quote>>, jumpDates?: Date[],
      interpolator?: Interpolator): DefaultCurve;
  curveInit5(
      referenceDate: Date, dayCounter: DayCounter, jumps?: Array<Handle<Quote>>,
      jumpDates?: Date[], interpolator?: Interpolator): DefaultCurve;
  curveInit6(
      settlementDays: Natural, calendar: Calendar, dayCounter: DayCounter,
      jumps?: Array<Handle<Quote>>, jumpDates?: Date[],
      interpolator?: Interpolator): DefaultCurve;
  maxDate(): Date;
  times(): Time[];
  dates(): Date[];
  data(): Real[];
  hazardRates(): Rate[];
  nodes(): Array<[Date, Real]>;
  hazardRateImpl(t: Time): Real;
  survivalProbabilityImpl(t: Time): Probability;
  private initialize;
  _dates: Date[];
  _interpolator: Interpolator;
}

export declare class InterpolatedSurvivalProbabilityCurve extends
    SurvivalProbabilityStructureInterpolatedCurve {
  constructor(interpolator?: Interpolator);
  curveInit1(
      dates: Date[], densities: Rate[], dayCounter: DayCounter, cal?: Calendar,
      jumps?: Array<Handle<Quote>>, jumpDates?: Date[],
      interpolator?: Interpolator): DefaultCurve;
  curveInit2(
      dates: Date[], densities: Rate[], dayCounter: DayCounter, cal?: Calendar,
      interpolator?: Interpolator): DefaultCurve;
  curveInit3(
      dates: Date[], densities: Rate[], dayCounter: DayCounter,
      interpolator?: Interpolator): DefaultCurve;
  curveInit4(
      dayCounter: DayCounter, jumps?: Array<Handle<Quote>>, jumpDates?: Date[],
      interpolator?: Interpolator): DefaultCurve;
  curveInit5(
      referenceDate: Date, dayCounter: DayCounter, jumps?: Array<Handle<Quote>>,
      jumpDates?: Date[], interpolator?: Interpolator): DefaultCurve;
  curveInit6(
      settlementDays: Natural, calendar: Calendar, dayCounter: DayCounter,
      jumps?: Array<Handle<Quote>>, jumpDates?: Date[],
      interpolator?: Interpolator): DefaultCurve;
  maxDate(): Date;
  times(): Time[];
  dates(): Date[];
  data(): Real[];
  survivalProbabilities(): Rate[];
  nodes(): Array<[Date, Real]>;
  defaultDensityImpl(t: Time): Real;
  survivalProbabilityImpl(t: Time): Probability;
  private initialize;
  _dates: Date[];
  _interpolator: Interpolator;
}

export declare class PiecewiseDefaultCurve extends
    DefaultTermStructureInterpolatedCurveLazyObject implements DefaultCurve {
  constructor(
      traits: Traits, interpolator: Interpolator,
      bootstrap?: IterativeBootstrap|LocalBootstrap);
  pwdcInit1(
      referenceDate: Date, instruments: BootstrapHelper[],
      dayCounter: DayCounter, jumps?: Array<Handle<Quote>>, jumpDates?: Date[],
      accuracy?: Real): PiecewiseDefaultCurve;
  pwdcInit2(
      referenceDate: Date, instruments: BootstrapHelper[],
      dayCounter: DayCounter, accuracy?: Real): PiecewiseDefaultCurve;
  pwdcInit3(
      referenceDate: Date, instruments: BootstrapHelper[],
      dayCounter: DayCounter): PiecewiseDefaultCurve;
  pwdcInit4(
      settlementDays: Natural, calendar: Calendar,
      instruments: BootstrapHelper[], dayCounter: DayCounter,
      jumps?: Array<Handle<Quote>>, jumpDates?: Date[],
      accuracy?: Real): PiecewiseDefaultCurve;
  pwdcInit5(
      settlementDays: Natural, calendar: Calendar,
      instruments: BootstrapHelper[], dayCounter: DayCounter,
      accuracy?: Real): PiecewiseDefaultCurve;
  pwdcInit6(
      settlementDays: Natural, calendar: Calendar,
      instruments: BootstrapHelper[],
      dayCounter: DayCounter): PiecewiseDefaultCurve;
  pwdcInit7(
      referenceDate: Date, instruments: BootstrapHelper[],
      dayCounter: DayCounter, accuracy: Real,
      model: OneFactorAffineModel): PiecewiseDefaultCurve;
  maxDate(): Date;
  times(): Time[];
  dates(): Date[];
  data(): Real[];
  nodes(): Array<[Date, Real]>;
  update(): void;
  performCalculations(): void;
  survivalProbabilityImpl(t: Time): Probability;
  defaultDensityImpl(t: Time): Real;
  hazardRateImpl(t: Time): Real;
  _base_curve: DefaultCurve;
  _traits: Traits;
  _interpolator: Interpolator;
  _bootstrap: IterativeBootstrap|LocalBootstrap;
  _instruments: BootstrapHelper[];
  _accuracy: Real;
}

export declare class SurvivalProbability {
  helper: BootstrapHelper;
  static initialDate(c: DefaultProbabilityTermStructure): Date;
  static initialValue(c: DefaultProbabilityTermStructure): Rate;
  static guess(i: Size, c: DefaultCurve, validData: boolean, s: Size): Rate;
  static minValueAfter(i: Size, c: DefaultCurve, validData: boolean, s: Size):
      Rate;
  static maxValueAfter(i: Size, c: DefaultCurve, validData: boolean, s: Size):
      Rate;
  static updateGuess(data: Rate[], p: Probability, i: Size): void;
  static maxIterations(): Size;
}
export declare namespace SurvivalProbability {
  class curve {
    type: InterpolatedSurvivalProbabilityCurve;
  }
}
export declare class HazardRate {
  helper: BootstrapHelper;
  static initialDate(c: DefaultCurve): Date;
  static initialValue(c: DefaultCurve): Real;
  static guess(i: Size, c: DefaultCurve, validData: boolean, s: Size): Real;
  static minValueAfter(i: Size, c: DefaultCurve, validData: boolean, s: Size):
      Real;
  static maxValueAfter(i: Size, c: DefaultCurve, validData: boolean, s: Size):
      Real;
  static updateGuess(data: Real[], rate: Real, i: Size): void;
  static maxIterations(): Size;
}
export declare namespace HazardRate {
  class curve {
    type: InterpolatedHazardRateCurve;
  }
}
export declare class DefaultDensity {
  helper: BootstrapHelper;
}
export declare namespace DefaultDensity {
  class curve {
    type: InterpolatedDefaultDensityCurve;
  }
}

export declare class SurvivalProbabilityStructure extends
    DefaultProbabilityTermStructure {
  defaultDensityImpl(t: Time): Real;
}

export declare class ZeroCouponInflationSwapHelper extends BootstrapHelper
    implements InflationBootstrapHelper {
  ibhInit(
      quote: Handle<Quote>, swapObsLag: Period, maturity: Date,
      calendar: Calendar, paymentConvention: BusinessDayConvention,
      dayCounter: DayCounter,
      zii: ZeroInflationIndex): ZeroCouponInflationSwapHelper;
  setTermStructure(z: ZeroInflationTermStructure): void;
  impliedQuote(): Real;
  protected _swapObsLag: Period;
  protected _maturity: Date;
  protected _calendar: Calendar;
  protected _paymentConvention: BusinessDayConvention;
  protected _dayCounter: DayCounter;
  protected _zii: ZeroInflationIndex;
  protected _zciis: ZeroCouponInflationSwap;
}
export declare class YearOnYearInflationSwapHelper extends BootstrapHelper
    implements InflationBootstrapHelper {
  ibhInit(
      quote: Handle<Quote>, swapObsLag: Period, maturity: Date,
      calendar: Calendar, paymentConvention: BusinessDayConvention,
      dayCounter: DayCounter,
      yii: YoYInflationIndex): YearOnYearInflationSwapHelper;
  setTermStructure(y: YoYInflationTermStructure): void;
  impliedQuote(): Real;
  protected _swapObsLag: Period;
  protected _maturity: Date;
  protected _calendar: Calendar;
  protected _paymentConvention: BusinessDayConvention;
  protected _dayCounter: DayCounter;
  protected _yii: YoYInflationIndex;
  protected _yyiis: YearOnYearInflationSwap;
}

export interface InflationBootstrapHelper {
  ibhInit(
      quote: Handle<Quote>, swapObsLag: Period, maturity: Date,
      calendar: Calendar, paymentConvention: BusinessDayConvention,
      dayCounter: DayCounter, yii: InflationIndex):
      ZeroCouponInflationSwapHelper|YearOnYearInflationSwapHelper;
}

export declare class ZeroInflation {
  static initialDate(t: InflationCurve): Date;
  static initialValue(t: InflationCurve): Rate;
  static guess(i: Size, c: InflationCurve, validData: boolean, s: Size): Rate;
  static minValueAfter(i: Size, c: InflationCurve, validData: boolean, s: Size):
      Rate;
  static maxValueAfter(i: Size, c: InflationCurve, validData: boolean, s: Size):
      Rate;
  static updateGuess(data: Rate[], level: Rate, i: Size): void;
  static maxIterations(): Size;
}
export declare class YoYInflation {
  static initialDate(t: InflationCurve): Date;
  static initialValue(t: InflationCurve): Rate;
  static guess(i: Size, c: InflationCurve, validData: boolean, s: Size): Rate;
  static minValueAfter(i: Size, c: InflationCurve, validData: boolean, s: Size):
      Rate;
  static maxValueAfter(i: Size, c: InflationCurve, validData: boolean, s: Size):
      Rate;
  static updateGuess(data: Rate[], level: Rate, i: Size): void;
  static maxIterations(): Size;
}

export declare class ZeroInflationTraits {
  static initialDate(t: ZeroInflationTermStructure): Date;
  static initialValue(t: ZeroInflationTermStructure): Rate;
  static guess(i: Size, c: InflationCurve, validData: boolean, s: Size): Rate;
  static minValueAfter(i: Size, c: InflationCurve, validData: boolean, s: Size):
      Rate;
  static maxValueAfter(i: Size, c: InflationCurve, validData: boolean, s: Size):
      Rate;
  static updateGuess(data: Rate[], level: Rate, i: Size): void;
  static maxIterations(): Size;
}
export declare class YoYInflationTraits {
  static initialDate(t: ZeroInflationTermStructure): Date;
  static initialValue(t: ZeroInflationTermStructure): Rate;
  static guess(i: Size, c: InflationCurve, validData: boolean, s: Size): Rate;
  static minValueAfter(i: Size, c: InflationCurve, validData: boolean, s: Size):
      Rate;
  static maxValueAfter(i: Size, c: InflationCurve, validData: boolean, s: Size):
      Rate;
  static updateGuess(data: Rate[], level: Rate, i: Size): void;
  static maxIterations(): Size;
}

export declare class InterpolatedYoYInflationCurve extends
    YoYInflationTermStructureInterpolatedCurve implements InflationCurve {
  constructor(interpolator?: Interpolator);
  curveInit1(
      referenceDate: Date, calendar: Calendar, dayCounter: DayCounter,
      lag: Period, frequency: Frequency, indexIsInterpolated: boolean,
      yTS: Handle<YieldTermStructure>, dates: Date[], rates: Rate[],
      interpolator?: Interpolator): InflationCurve;
  curveInit2(
      referenceDate: Date, calendar: Calendar, dayCounter: DayCounter,
      baseYoYRate: Rate, lag: Period, frequency: Frequency,
      indexIsInterpolated: boolean, yTS: Handle<YieldTermStructure>,
      interpolator?: Interpolator): InflationCurve;
  baseDate(): Date;
  maxDate(): Date;
  times(): Time[];
  dates(): Date[];
  rates(): Rate[];
  data(): Real[];
  nodes(): Array<[Date, Real]>;
  yoyRateImpl(t: Time): Rate;
  _dates: Date[];
}
export declare class YoYInflationCurve extends InterpolatedYoYInflationCurve {
  constructor();
}

export declare class InterpolatedZeroInflationCurve extends
    ZeroInflationTermStructureInterpolatedCurve implements InflationCurve {
  constructor(interpolator?: Interpolator);
  curveInit1(
      referenceDate: Date, calendar: Calendar, dayCounter: DayCounter,
      lag: Period, frequency: Frequency, indexIsInterpolated: boolean,
      yTS: Handle<YieldTermStructure>, dates: Date[], rates: Rate[],
      interpolator?: Interpolator): InflationCurve;
  curveInit2(
      referenceDate: Date, calendar: Calendar, dayCounter: DayCounter,
      baseZeroRate: Rate, lag: Period, frequency: Frequency,
      indexIsInterpolated: boolean, yTS: Handle<YieldTermStructure>,
      interpolator?: Interpolator): InflationCurve;
  baseDate(): Date;
  maxDate(): Date;
  times(): Time[];
  dates(): Date[];
  rates(): Rate[];
  data(): Real[];
  nodes(): Array<[Date, Real]>;
  zeroRateImpl(t: Time): Rate;
  _dates: Date[];
}
export declare class ZeroInflationCurve extends InterpolatedZeroInflationCurve {
  constructor();
}

export declare class PiecewiseYoYInflationCurve extends
    YoYInflationTermStructureInterpolatedCurveLazyObject implements
        InflationCurve {
  constructor(
      interpolator: Interpolator, traits?: Traits,
      bootstrap?: IterativeBootstrap|LocalBootstrap);
  pwyoyicInit(
      referenceDate: Date, calendar: Calendar, dayCounter: DayCounter,
      lag: Period, frequency: Frequency, indexIsInterpolated: boolean,
      baseYoYRate: Rate, nominalTS: Handle<YieldTermStructure>,
      instruments: BootstrapHelper[],
      accuracy?: Real): PiecewiseYoYInflationCurve;
  baseDate(): Date;
  maxDate(): Date;
  times(): Time[];
  dates(): Date[];
  data(): Real[];
  nodes(): Array<[Date, Real]>;
  update(): void;
  performCalculations(): void;
  _base_curve: InflationCurve;
  _traits: Traits;
  _interpolator: Interpolator;
  _bootstrap: IterativeBootstrap|LocalBootstrap;
  _instruments: BootstrapHelper[];
  _accuracy: Real;
}

export declare class Seasonality {
  correctZeroRate(d: Date, r: Rate, iTS: InflationTermStructure): Rate;
  correctYoYRate(d: Date, r: Rate, iTS: InflationTermStructure): Rate;
  isConsistent(iTS: InflationTermStructure): boolean;
}
export declare class MultiplicativePriceSeasonality extends Seasonality {
  constructor(
      seasonalityBaseDate: Date, frequency: Frequency,
      seasonalityFactors: Rate[]);
  seasonalityBaseDate(): Date;
  frequency(): Frequency;
  seasonalityFactors(): Rate[];
  seasonalityFactor(d: Date): Rate;
  correctZeroRate(d: Date, r: Rate, iTS: InflationTermStructure): Rate;
  correctYoYRate(d: Date, r: Rate, iTS: InflationTermStructure): Rate;
  isConsistent(iTS: InflationTermStructure): boolean;
  protected validate(): void;
  protected seasonalityCorrection(
      r: Rate, d: Date, dc: DayCounter, curveBaseDate: Date,
      isZeroRate: boolean): void;
}
export declare class KerkhofSeasonality extends MultiplicativePriceSeasonality {
}

export declare class PiecewiseZeroInflationCurve extends
    ZeroInflationTermStructureInterpolatedCurveLazyObject implements
        InflationCurve {
  constructor(
      interpolator: Interpolator, traits?: Traits,
      bootstrap?: IterativeBootstrap|LocalBootstrap);
  pwzicInit(
      referenceDate: Date, calendar: Calendar, dayCounter: DayCounter,
      lag: Period, frequency: Frequency, indexIsInterpolated: boolean,
      baseZeroRate: Rate, nominalTS: Handle<YieldTermStructure>,
      instruments: BootstrapHelper[],
      accuracy?: Real): PiecewiseZeroInflationCurve;
  baseDate(): Date;
  maxDate(): Date;
  times(): Time[];
  dates(): Date[];
  data(): Real[];
  nodes(): Array<[Date, Real]>;
  update(): void;
  performCalculations(): void;
  _base_curve: InflationCurve;
  _traits: Traits;
  _interpolator: Interpolator;
  _bootstrap: IterativeBootstrap|LocalBootstrap;
  _instruments: BootstrapHelper[];
  _accuracy: Real;
}

export declare class BondHelper extends BootstrapHelper {
  constructor(price: Handle<Quote>, bond: Bond, useCleanPrice?: boolean);
  impliedQuote(): Real;
  setTermStructure(t: YieldTermStructure): void;
  bond(): Bond;
  useCleanPrice(): boolean;
  accept(v: AcyclicVisitor): void;
  protected _bond: Bond;
  protected _termStructureHandle: RelinkableHandle<YieldTermStructure>;
  protected _useCleanPrice: boolean;
}
export declare class FixedRateBondHelper extends BondHelper {
  constructor(
      price: Handle<Quote>, settlementDays: Natural, faceAmount: Real,
      schedule: Schedule, coupons: Rate[], dayCounter: DayCounter,
      paymentConvention?: BusinessDayConvention, redemption?: Real,
      issueDate?: Date, paymentCalendar?: Calendar, exCouponPeriod?: Period,
      exCouponCalendar?: Calendar, exCouponConvention?: BusinessDayConvention,
      exCouponEndOfMonth?: boolean, useCleanPrice?: boolean);
  fixedRateBond(): FixedRateBond;
  accept(v: AcyclicVisitor): void;
  protected _fixedRateBond: FixedRateBond;
}
export declare class CPIBondHelper extends BondHelper {
  constructor(
      price: Handle<Quote>, settlementDays: Natural, faceAmount: Real,
      growthOnly: boolean, baseCPI: Real, observationLag: Period,
      cpiIndex: ZeroInflationIndex,
      observationInterpolation: CPI.InterpolationType, schedule: Schedule,
      fixedRate: Rate[], accrualDayCounter: DayCounter,
      paymentConvention: BusinessDayConvention, issueDate?: Date,
      paymentCalendar?: Calendar, exCouponPeriod?: Period,
      exCouponCalendar?: Calendar, exCouponConvention?: BusinessDayConvention,
      exCouponEndOfMonth?: boolean, useCleanPrice?: boolean);
  cpiBond(): CPIBond;
  accept(v: AcyclicVisitor): void;
  protected _cpiBond: CPIBond;
}

export declare class Discount {
  helper: BootstrapHelper;
  static initialDate(c: YieldCurve): Date;
  static initialValue(c: YieldCurve): Real;
  static guess(i: Size, c: YieldCurve, validData: boolean, s: Size): Real;
  static minValueAfter(i: Size, c: YieldCurve, validData: boolean, s: Size):
      Real;
  static maxValueAfter(i: Size, c: YieldCurve, validData: boolean, s: Size):
      Real;
  static updateGuess(data: Real[], discount: Real, i: Size): void;
  static maxIterations(): Size;
}
export declare namespace Discount {
  class curve {
    type: InterpolatedDiscountCurve;
  }
}
export declare class ZeroYield {
  helper: BootstrapHelper;
  static initialDate(c: YieldCurve): Date;
  static initialValue(c: YieldCurve): Real;
  static guess(i: Size, c: YieldCurve, validData: boolean, s: Size): Real;
  static minValueAfter(i: Size, c: YieldCurve, validData: boolean, s: Size):
      Real;
  static maxValueAfter(i: Size, c: YieldCurve, validData: boolean, s: Size):
      Real;
  static updateGuess(data: Real[], rate: Real, i: Size): void;
  static maxIterations(): Size;
}
export declare namespace ZeroYield {
  class curve {
    type: InterpolatedZeroCurve;
  }
}
export declare class ForwardRate {
  helper: BootstrapHelper;
  static initialDate(c: YieldCurve): Date;
  static initialValue(c: YieldCurve): Real;
  static guess(i: Size, c: YieldCurve, validData: boolean, s: Size): Real;
  static minValueAfter(i: Size, c: YieldCurve, validData: boolean, s: Size):
      Real;
  static maxValueAfter(i: Size, c: YieldCurve, validData: boolean, s: Size):
      Real;
  static updateGuess(data: Real[], forward: Real, i: Size): void;
  static maxIterations(): Size;
}
export declare namespace ForwardRate {
  class curve {
    type: InterpolatedForwardCurve;
  }
}

export declare class CompositeZeroYieldStructure extends ZeroYieldStructure {
  constructor(
      h1: Handle<YieldTermStructure>, h2: Handle<YieldTermStructure>,
      f: BinaryFunction<Real, Real, Real>, comp?: Compounding,
      freq?: Frequency);
  dayCounter(): DayCounter;
  calendar(): Calendar;
  settlementDays(): Natural;
  referenceDate(): Date;
  maxDate(): Date;
  maxTime(): Time;
  update(): void;
  zeroYieldImpl(t: Time): Rate;
  private _curve1;
  private _curve2;
  private _f;
  private _comp;
  private _freq;
}

export declare class DriftTermStructure extends ZeroYieldStructure {}

export declare class InterpolatedDiscountCurve extends
    YieldTermStructureInterpolatedCurve implements YieldCurve {
  constructor(interpolator?: Interpolator);
  curveInit1(
      dates: Date[], dfs: DiscountFactor[], dayCounter: DayCounter,
      calendar?: Calendar, jumps?: Array<Handle<Quote>>,
      jumpDates?: Date[]): YieldCurve;
  curveInit2(
      dates: Date[], dfs: DiscountFactor[], dayCounter: DayCounter,
      calendar: Calendar): YieldCurve;
  curveInit3(dates: Date[], dfs: DiscountFactor[], dayCounter: DayCounter):
      YieldCurve;
  curveInit4(
      dayCounter: DayCounter, jumps?: Array<Handle<Quote>>,
      jumpDates?: Date[]): YieldCurve;
  curveInit5(
      referenceDate: Date, dayCounter: DayCounter, jumps?: Array<Handle<Quote>>,
      jumpDates?: Date[]): YieldCurve;
  curveInit6(
      settlementDays: Natural, calendar: Calendar, dayCounter: DayCounter,
      jumps?: Array<Handle<Quote>>, jumpDates?: Date[]): YieldCurve;
  maxDate(): Date;
  times(): Time[];
  dates(): Date[];
  data(): Real[];
  discounts(): DiscountFactor[];
  nodes(): Array<[Date, Real]>;
  discountImpl(t: Time): DiscountFactor;
  private initialize;
  _dates: Date[];
}
export declare class DiscountCurve extends InterpolatedDiscountCurve {
  constructor();
}

export declare class FittedBondDiscountCurve extends
    YieldTermStructureLazyObject {
  fbdcInit1(
      settlementDays: Natural, calendar: Calendar, bondHelpers: BondHelper[],
      dayCounter: DayCounter,
      fittingMethod: FittedBondDiscountCurve.FittingMethod, accuracy?: Real,
      maxEvaluations?: Size, guess?: Real[], simplexLambda?: Real,
      maxStationaryStateIterations?: Size): FittedBondDiscountCurve;
  fbdcInit2(
      referenceDate: Date, bondHelpers: BondHelper[], dayCounter: DayCounter,
      fittingMethod: FittedBondDiscountCurve.FittingMethod, accuracy?: Real,
      maxEvaluations?: Size, guess?: Real[], simplexLambda?: Real,
      maxStationaryStateIterations?: Size): FittedBondDiscountCurve;
  numberOfBonds(): Size;
  maxDate(): Date;
  fitResults(): FittedBondDiscountCurve.FittingMethod;
  update(): void;
  private setup;
  performCalculations(): void;
  discountImpl(t: Time): DiscountFactor;
  _accuracy: Real;
  _maxEvaluations: Size;
  _simplexLambda: Real;
  _maxStationaryStateIterations: Size;
  _guessSolution: Real[];
  private _maxDate;
  _bondHelpers: BondHelper[];
  private _fittingMethod;
}
export declare namespace FittedBondDiscountCurve {
  class FittingMethod {
    fmInit(
        constrainAtZero?: boolean, weights?: Real[],
        optimizationMethod?: OptimizationMethod, l2?: Real[]): FittingMethod;
    size(): Size;
    solution(): Real[];
    numberOfIterations(): Integer;
    minimumCostValue(): Real;
    clone(): FittingMethod;
    constrainAtZero(): boolean;
    weights(): Real[];
    l2(): Real[];
    optimizationMethod(): OptimizationMethod;
    discount(x: Real[], t: Time): DiscountFactor;
    init(): void;
    discountFunction(x: Real[], t: Time): DiscountFactor;
    calculate(): void;
    protected _constrainAtZero: boolean;
    _curve: FittedBondDiscountCurve;
    _solution: Real[];
    protected _guessSolution: Real[];
    protected _costFunction: FittingMethod.FittingCost;
    _weights: Real[];
    _l2: Real[];
    private _calculateWeights;
    private _numberOfIterations;
    private _costValue;
    private _optimizationMethod;
  }
  namespace FittingMethod {
    class FittingCost extends CostFunction {
      constructor(fittingMethod: FittingMethod);
      value(x: Real[]): Real;
      values(x: Real[]): Real[];
      private _fittingMethod;
      _firstCashFlow: Size[];
    }
  }
}

export declare class FlatForward extends YieldTermStructureLazyObject {
  ffInit1(
      referenceDate: Date, forward: Handle<Quote>, dayCounter: DayCounter,
      compounding?: Compounding, frequency?: Frequency): FlatForward;
  ffInit2(
      referenceDate: Date, forward: Rate, dayCounter: DayCounter,
      compounding?: Compounding, frequency?: Frequency): FlatForward;
  ffInit3(
      settlementDays: Natural, calendar: Calendar, forward: Handle<Quote>,
      dayCounter: DayCounter, compounding?: Compounding,
      frequency?: Frequency): FlatForward;
  ffInit4(
      settlementDays: Natural, calendar: Calendar, forward: Rate,
      dayCounter: DayCounter, compounding?: Compounding,
      frequency?: Frequency): FlatForward;
  compounding(): Compounding;
  compoundingFrequency(): Frequency;
  maxDate(): Date;
  update(): void;
  performCalculations(): void;
  discountImpl(t: Time): DiscountFactor;
  private _forward;
  private _compounding;
  private _frequency;
  private _rate;
}

export declare class InterpolatedForwardCurve extends
    ForwardRateStructureInterpolatedCurve implements YieldCurve {
  constructor(interpolator?: Interpolator);
  curveInit1(
      dates: Date[], forwards: Rate[], dayCounter: DayCounter,
      calendar?: Calendar, jumps?: Array<Handle<Quote>>,
      jumpDates?: Date[]): YieldCurve;
  curveInit2(
      dates: Date[], forwards: DiscountFactor[], dayCounter: DayCounter,
      calendar: Calendar): YieldCurve;
  curveInit3(dates: Date[], forwards: DiscountFactor[], dayCounter: DayCounter):
      YieldCurve;
  curveInit4(
      dayCounter: DayCounter, jumps?: Array<Handle<Quote>>,
      jumpDates?: Date[]): YieldCurve;
  curveInit5(
      referenceDate: Date, dayCounter: DayCounter, jumps?: Array<Handle<Quote>>,
      jumpDates?: Date[]): YieldCurve;
  curveInit6(
      settlementDays: Natural, calendar: Calendar, dayCounter: DayCounter,
      jumps?: Array<Handle<Quote>>, jumpDates?: Date[]): YieldCurve;
  maxDate(): Date;
  times(): Time[];
  dates(): Date[];
  data(): Real[];
  forwards(): Rate[];
  nodes(): Array<[Date, Real]>;
  forwardImpl(t: Time): Rate;
  zeroYieldImpl(t: Time): Rate;
  private initialize;
  _dates: Date[];
}
export declare class ForwardCurve extends InterpolatedForwardCurve {
  constructor();
}

export declare class ForwardSpreadedTermStructure extends ForwardRateStructure {
  constructor(h: Handle<YieldTermStructure>, spread: Handle<Quote>);
  dayCounter(): DayCounter;
  maxDate(): Date;
  maxTime(): Time;
  referenceDate(): Date;
  calendar(): Calendar;
  settlementDays(): Natural;
  forwardImpl(t: Time): DiscountFactor;
  zeroYieldImpl(t: Time): DiscountFactor;
  update(): void;
  private _originalCurve;
  private _spread;
}

export declare class ForwardRateStructure extends YieldTermStructure {
  forwardImpl(t: Time): Rate;
  zeroYieldImpl(t: Time): Rate;
  discountImpl(t: Time): DiscountFactor;
}

export declare class ImpliedTermStructure extends YieldTermStructure {
  constructor(h: Handle<YieldTermStructure>, referenceDate: Date);
  dayCounter(): DayCounter;
  calendar(): Calendar;
  settlementDays(): Natural;
  maxDate(): Date;
  discountImpl(t: Time): DiscountFactor;
  private _originalCurve;
}

export declare class ExponentialSplinesFitting extends
    FittedBondDiscountCurve.FittingMethod {
  esfInit1(
      constrainAtZero?: boolean, weights?: Real[],
      optimizationMethod?: OptimizationMethod,
      l2?: Real[]): ExponentialSplinesFitting;
  esfInit2(constrainAtZero: boolean, weights: Real[], l2: Real[]):
      ExponentialSplinesFitting;
  clone(): FittedBondDiscountCurve.FittingMethod;
  size(): Size;
  discountFunction(x: Real[], t: Time): DiscountFactor;
}
export declare class NelsonSiegelFitting extends
    FittedBondDiscountCurve.FittingMethod {
  nsfInit1(
      weights?: Real[], optimizationMethod?: OptimizationMethod,
      l2?: Real[]): NelsonSiegelFitting;
  nsfInit2(weights: Real[], l2: Real[]): NelsonSiegelFitting;
  clone(): FittedBondDiscountCurve.FittingMethod;
  size(): Size;
  discountFunction(x: Real[], t: Time): DiscountFactor;
}
export declare class SvenssonFitting extends
    FittedBondDiscountCurve.FittingMethod {
  sfInit1(
      weights?: Real[], optimizationMethod?: OptimizationMethod,
      l2?: Real[]): SvenssonFitting;
  sfInit2(weights: Real[], l2: Real[]): SvenssonFitting;
  clone(): FittedBondDiscountCurve.FittingMethod;
  size(): Size;
  discountFunction(x: Real[], t: Time): DiscountFactor;
}
export declare class CubicBSplinesFitting extends
    FittedBondDiscountCurve.FittingMethod {
  cbsfInit1(
      knots: Time[], constrainAtZero?: boolean, weights?: Real[],
      optimizationMethod?: OptimizationMethod,
      l2?: Real[]): CubicBSplinesFitting;
  cbsfInit2(
      knots: Time[], constrainAtZero: boolean, weights: Real[],
      l2: Real[]): CubicBSplinesFitting;
  basisFunction(i: Integer, t: Time): Real;
  clone(): FittedBondDiscountCurve.FittingMethod;
  size(): Size;
  discountFunction(x: Real[], t: Time): DiscountFactor;
  private _splines;
  private _size;
  private _N;
}
export declare class SimplePolynomialFitting extends
    FittedBondDiscountCurve.FittingMethod {
  spfInit1(
      degree: Natural, constrainAtZero?: boolean, weights?: Real[],
      optimizationMethod?: OptimizationMethod,
      l2?: Real[]): SimplePolynomialFitting;
  spfInit2(
      degree: Natural, constrainAtZero: boolean, weights: Real[],
      l2: Real[]): SimplePolynomialFitting;
  clone(): FittedBondDiscountCurve.FittingMethod;
  size(): Size;
  discountFunction(x: Real[], t: Time): DiscountFactor;
  private _size;
}
export declare class SpreadFittingMethod extends
    FittedBondDiscountCurve.FittingMethod {
  constructor(
      method: FittedBondDiscountCurve.FittingMethod,
      discountCurve: Handle<YieldTermStructure>);
  clone(): FittedBondDiscountCurve.FittingMethod;
  init(): void;
  size(): Size;
  discountFunction(x: Real[], t: Time): DiscountFactor;
  private _method;
  private _rebase;
  private _discountingCurve;
}

export declare class OISRateHelper extends RelativeDateBootstrapHelper {
  constructor(
      settlementDays: Natural, tenor: Period, fixedRate: Handle<Quote>,
      overnightIndex: OvernightIndex, discount?: Handle<YieldTermStructure>,
      telescopicValueDates?: boolean, paymentLag?: Natural,
      paymentConvention?: BusinessDayConvention, paymentFrequency?: Frequency,
      paymentCalendar?: Calendar, forwardStart?: Period,
      overnightSpread?: Spread);
  impliedQuote(): Real;
  setTermStructure(t: YieldTermStructure): void;
  swap(): OvernightIndexedSwap;
  protected initializeDates(): void;
  accept(v: AcyclicVisitor): void;
  protected _settlementDays: Natural;
  protected _tenor: Period;
  protected _overnightIndex: OvernightIndex;
  protected _swap: OvernightIndexedSwap;
  protected _termStructureHandle: RelinkableHandle<YieldTermStructure>;
  protected _discountHandle: Handle<YieldTermStructure>;
  protected _telescopicValueDates: boolean;
  protected _discountRelinkableHandle: RelinkableHandle<YieldTermStructure>;
  protected _paymentLag: Natural;
  protected _paymentConvention: BusinessDayConvention;
  protected _paymentFrequency: Frequency;
  protected _paymentCalendar: Calendar;
  protected _forwardStart: Period;
  protected _overnightSpread: Spread;
}
export declare class DatedOISRateHelper extends BootstrapHelper {
  constructor(
      startDate: Date, endDate: Date, fixedRate: Handle<Quote>,
      overnightIndex: OvernightIndex, discount?: Handle<YieldTermStructure>,
      telescopicValueDates?: boolean);
  impliedQuote(): Real;
  setTermStructure(t: YieldTermStructure): void;
  accept(v: AcyclicVisitor): void;
  protected _swap: OvernightIndexedSwap;
  protected _termStructureHandle: RelinkableHandle<YieldTermStructure>;
  protected _discountHandle: Handle<YieldTermStructure>;
  protected _telescopicValueDates: boolean;
  protected _discountRelinkableHandle: RelinkableHandle<YieldTermStructure>;
}

export declare class PiecewiseYieldCurve extends
    YieldTermStructureInterpolatedCurveLazyObject implements YieldCurve {
  constructor(
      traits: Traits, interpolator: Interpolator,
      bootstrap?: IterativeBootstrap|LocalBootstrap);
  pwycInit1(
      referenceDate: Date, instruments: BootstrapHelper[],
      dayCounter: DayCounter, jumps?: Array<Handle<Quote>>, jumpDates?: Date[],
      accuracy?: Real): PiecewiseYieldCurve;
  pwycInit2(
      referenceDate: Date, instruments: BootstrapHelper[],
      dayCounter: DayCounter, accuracy?: Real): PiecewiseYieldCurve;
  pwycInit3(
      referenceDate: Date, instruments: BootstrapHelper[],
      dayCounter: DayCounter): PiecewiseYieldCurve;
  pwycInit4(
      settlementDays: Natural, calendar: Calendar,
      instruments: BootstrapHelper[], dayCounter: DayCounter,
      jumps?: Array<Handle<Quote>>, jumpDates?: Date[],
      accuracy?: Real): PiecewiseYieldCurve;
  pwycInit5(
      settlementDays: Natural, calendar: Calendar,
      instruments: BootstrapHelper[], dayCounter: DayCounter,
      accuracy?: Real): PiecewiseYieldCurve;
  pwycInit6(
      settlementDays: Natural, calendar: Calendar,
      instruments: BootstrapHelper[],
      dayCounter: DayCounter): PiecewiseYieldCurve;
  maxDate(): Date;
  times(): Time[];
  dates(): Date[];
  data(): Real[];
  nodes(): Array<[Date, Real]>;
  update(): void;
  performCalculations(): void;
  discountImpl(t: Time): DiscountFactor;
  zeroYieldImpl(t: Time): Rate;
  _base_curve: YieldCurve;
  _traits: Traits;
  _interpolator: Interpolator;
  _bootstrap: IterativeBootstrap|LocalBootstrap;
  _instruments: BootstrapHelper[];
  _accuracy: Real;
}

export declare class InterpolatedPiecewiseZeroSpreadedTermStructure extends
    ZeroYieldStructure {
  constructor(interpolator: Interpolator);
  ipzstsInit(
      h: Handle<YieldTermStructure>, spreads: Array<Handle<Quote>>,
      dates: Date[], comp?: Compounding, freq?: Frequency,
      dc?: DayCounter): InterpolatedPiecewiseZeroSpreadedTermStructure;
  dayCounter(): DayCounter;
  settlementDays(): Natural;
  calendar(): Calendar;
  referenceDate(): Date;
  maxDate(): Date;
  zeroYieldImpl(t: Time): Rate;
  update(): void;
  private updateInterpolation;
  private calcSpread;
  private _originalCurve;
  private _spreads;
  private _dates;
  private _times;
  private _spreadValues;
  private _comp;
  private _freq;
  _dc: DayCounter;
  private _factory;
  private _interpolator;
}
export declare class PiecewiseZeroSpreadedTermStructure extends
    InterpolatedPiecewiseZeroSpreadedTermStructure {
  constructor(
      h: Handle<YieldTermStructure>, spreads: Array<Handle<Quote>>,
      dates: Date[], comp?: Compounding, freq?: Frequency, dc?: DayCounter);
}

export declare class QuantoTermStructure extends ZeroYieldStructure {}

export declare type RateHelper = BootstrapHelper;
export declare type RelativeDateRateHelper = RelativeDateBootstrapHelper;
export declare class FuturesRateHelper extends BootstrapHelper {
  frhInit1(
      price: Handle<Quote>, iborStartDate: Date, lengthInMonths: Natural,
      calendar: Calendar, convention: BusinessDayConvention,
      endOfMonth: boolean, dayCounter: DayCounter, convAdj?: Handle<Quote>,
      type?: Futures.Type): FuturesRateHelper;
  frhInit2(
      price: Real, iborStartDate: Date, lengthInMonths: Natural,
      calendar: Calendar, convention: BusinessDayConvention,
      endOfMonth: boolean, dayCounter: DayCounter, convexityAdjustment?: Real,
      type?: Futures.Type): FuturesRateHelper;
  frhInit3(
      price: Handle<Quote>, iborStartDate: Date, iborEndDate: Date,
      dayCounter: DayCounter, convexityAdjustment?: Handle<Quote>,
      type?: Futures.Type): FuturesRateHelper;
  frhInit4(
      price: Real, iborStartDate: Date, iborEndDate: Date,
      dayCounter: DayCounter, convexityAdjustment?: Real,
      type?: Futures.Type): FuturesRateHelper;
  frhInit5(
      price: Handle<Quote>, iborStartDate: Date, iborIndex: IborIndex,
      convAdj?: Handle<Quote>, type?: Futures.Type): FuturesRateHelper;
  frhInit6(
      price: Real, iborStartDate: Date, iborIndex: IborIndex,
      convexityAdjustment?: Real, type?: Futures.Type): FuturesRateHelper;
  impliedQuote(): Real;
  convexityAdjustment(): Real;
  accept(v: AcyclicVisitor): void;
  private _yearFraction;
  private _convAdj;
}
export declare class DepositRateHelper extends RelativeDateBootstrapHelper {
  drhInit1(
      rate: Handle<Quote>, tenor: Period, fixingDays: Natural,
      calendar: Calendar, convention: BusinessDayConvention,
      endOfMonth: boolean, dayCounter: DayCounter): DepositRateHelper;
  drhInit2(
      rate: Rate, tenor: Period, fixingDays: Natural, calendar: Calendar,
      convention: BusinessDayConvention, endOfMonth: boolean,
      dayCounter: DayCounter): DepositRateHelper;
  drhInit3(rate: Handle<Quote>, i: IborIndex): DepositRateHelper;
  drhInit4(rate: Rate, i: IborIndex): DepositRateHelper;
  impliedQuote(): Real;
  setTermStructure(t: YieldCurve): void;
  protected initializeDates(): void;
  accept(v: AcyclicVisitor): void;
  private _fixingDate;
  private _iborIndex;
  private _termStructureHandle;
}
export declare class FraRateHelper extends RelativeDateBootstrapHelper {
  frahInit1(
      rate: Handle<Quote>, monthsToStart: Natural, monthsToEnd: Natural,
      fixingDays: Natural, calendar: Calendar,
      convention: BusinessDayConvention, endOfMonth: boolean,
      dayCounter: DayCounter, pillarChoice?: Pillar.Choice,
      customPillarDate?: Date): FraRateHelper;
  frahInit2(
      rate: Rate, monthsToStart: Natural, monthsToEnd: Natural,
      fixingDays: Natural, calendar: Calendar,
      convention: BusinessDayConvention, endOfMonth: boolean,
      dayCounter: DayCounter, pillarChoice?: Pillar.Choice,
      customPillarDate?: Date): FraRateHelper;
  frahInit3(
      rate: Handle<Quote>, monthsToStart: Natural, iborIndex: IborIndex,
      pillarChoice?: Pillar.Choice, customPillarDate?: Date): FraRateHelper;
  frahInit4(
      rate: Rate, monthsToStart: Natural, iborIndex: IborIndex,
      pillarChoice?: Pillar.Choice, customPillarDate?: Date): FraRateHelper;
  frahInit5(
      rate: Handle<Quote>, periodToStart: Period, lengthInMonths: Natural,
      fixingDays: Natural, calendar: Calendar,
      convention: BusinessDayConvention, endOfMonth: boolean,
      dayCounter: DayCounter, pillarChoice?: Pillar.Choice,
      customPillarDate?: Date): FraRateHelper;
  frahInit6(
      rate: Rate, periodToStart: Period, lengthInMonths: Natural,
      fixingDays: Natural, calendar: Calendar,
      convention: BusinessDayConvention, endOfMonth: boolean,
      dayCounter: DayCounter, pillarChoice?: Pillar.Choice,
      customPillarDate?: Date): FraRateHelper;
  frahInit7(
      rate: Handle<Quote>, periodToStart: Period, iborIndex: IborIndex,
      pillarChoice?: Pillar.Choice, customPillarDate?: Date): FraRateHelper;
  frahInit8(
      rate: Rate, periodToStart: Period, iborIndex: IborIndex,
      pillarChoice?: Pillar.Choice, customPillarDate?: Date): FraRateHelper;
  impliedQuote(): Real;
  setTermStructure(t: YieldCurve): void;
  protected initializeDates(): void;
  accept(v: AcyclicVisitor): void;
  private _fixingDate;
  private _periodToStart;
  private _pillarChoice;
  private _iborIndex;
  private _termStructureHandle;
}
export declare class SwapRateHelper extends RelativeDateBootstrapHelper {
  srhInit1(
      rate: Handle<Quote>, swapIndex: SwapIndex, spread?: Handle<Quote>,
      fwdStart?: Period, discountingCurve?: Handle<YieldTermStructure>,
      pillarChoice?: Pillar.Choice, customPillarDate?: Date): SwapRateHelper;
  srhInit2(
      rate: Handle<Quote>, tenor: Period, calendar: Calendar,
      fixedFrequency: Frequency, fixedConvention: BusinessDayConvention,
      fixedDayCount: DayCounter, iborIndex: IborIndex, spread?: Handle<Quote>,
      fwdStart?: Period, discountingCurve?: Handle<YieldTermStructure>,
      settlementDays?: Natural, pillarChoice?: Pillar.Choice,
      customPillarDate?: Date): SwapRateHelper;
  srhInit3(
      rate: Rate, swapIndex: SwapIndex, spread?: Handle<Quote>,
      fwdStart?: Period, discountingCurve?: Handle<YieldTermStructure>,
      pillarChoice?: Pillar.Choice, customPillarDate?: Date): SwapRateHelper;
  srhInit4(
      rate: Rate, tenor: Period, calendar: Calendar, fixedFrequency: Frequency,
      fixedConvention: BusinessDayConvention, fixedDayCount: DayCounter,
      iborIndex: IborIndex, spread?: Handle<Quote>, fwdStart?: Period,
      discountingCurve?: Handle<YieldTermStructure>, settlementDays?: Natural,
      pillarChoice?: Pillar.Choice, customPillarDate?: Date): SwapRateHelper;
  impliedQuote(): Real;
  setTermStructure(t: YieldCurve): void;
  spread(): Spread;
  swap(): VanillaSwap;
  forwardStart(): Period;
  accept(v: AcyclicVisitor): void;
  protected initializeDates(): void;
  protected _settlementDays: Natural;
  protected _tenor: Period;
  protected _pillarChoice: Pillar.Choice;
  protected _calendar: Calendar;
  protected _fixedConvention: BusinessDayConvention;
  protected _fixedFrequency: Frequency;
  protected _fixedDayCount: DayCounter;
  protected _iborIndex: IborIndex;
  protected _swap: VanillaSwap;
  protected _termStructureHandle: RelinkableHandle<YieldTermStructure>;
  protected _spread: Handle<Quote>;
  protected _fwdStart: Period;
  protected _discountHandle: Handle<YieldTermStructure>;
  protected _discountRelinkableHandle: RelinkableHandle<YieldTermStructure>;
}
export declare class BMASwapRateHelper extends RelativeDateBootstrapHelper {
  constructor(
      liborFraction: Handle<Quote>, tenor: Period, settlementDays: Natural,
      calendar: Calendar, bmaPeriod: Period,
      bmaConvention: BusinessDayConvention, bmaDayCount: DayCounter,
      bmaIndex: BMAIndex, iborIndex: IborIndex);
  setTermStructure(t: YieldCurve): void;
  impliedQuote(): Real;
  initializeDates(): void;
  protected _tenor: Period;
  protected _settlementDays: Natural;
  protected _calendar: Calendar;
  protected _bmaPeriod: Period;
  protected _bmaConvention: BusinessDayConvention;
  protected _bmaDayCount: DayCounter;
  protected _bmaIndex: BMAIndex;
  protected _iborIndex: IborIndex;
  protected _swap: BMASwap;
  protected _termStructureHandle: RelinkableHandle<YieldTermStructure>;
}
export declare class FxSwapRateHelper extends RelativeDateBootstrapHelper {
  constructor(
      fwdPoint: Handle<Quote>, spotFx: Handle<Quote>, tenor: Period,
      fixingDays: Natural, calendar: Calendar,
      convention: BusinessDayConvention, endOfMonth: boolean,
      isFxBaseCurrencyCollateralCurrency: boolean,
      coll: Handle<YieldTermStructure>);
  impliedQuote(): Real;
  setTermStructure(t: YieldCurve): void;
  accept(v: AcyclicVisitor): void;
  initializeDates(): void;
  private _spot;
  private _tenor;
  private _fixingDays;
  private _cal;
  private _conv;
  private _eom;
  private _isFxBaseCurrencyCollateralCurrency;
  private _termStructureHandle;
  private _collHandle;
  private _collRelinkableHandle;
}

export declare class InterpolatedZeroCurve extends
    ZeroYieldStructureInterpolatedCurve implements YieldCurve {
  constructor(interpolator?: Interpolator);
  curveInit1(
      dates: Date[], dfs: DiscountFactor[], dayCounter: DayCounter,
      calendar?: Calendar, jumps?: Array<Handle<Quote>>, jumpDates?: Date[],
      compounding?: Compounding, frequency?: Frequency): YieldCurve;
  curveInit2(
      dates: Date[], dfs: DiscountFactor[], dayCounter: DayCounter,
      calendar: Calendar, compounding?: Compounding,
      frequency?: Frequency): YieldCurve;
  curveInit3(
      dates: Date[], dfs: DiscountFactor[], dayCounter: DayCounter,
      compounding?: Compounding, frequency?: Frequency): YieldCurve;
  curveInit4(
      dayCounter: DayCounter, jumps?: Array<Handle<Quote>>,
      jumpDates?: Date[]): YieldCurve;
  curveInit5(
      referenceDate: Date, dayCounter: DayCounter, jumps?: Array<Handle<Quote>>,
      jumpDates?: Date[]): YieldCurve;
  curveInit6(
      settlementDays: Natural, calendar: Calendar, dayCounter: DayCounter,
      jumps?: Array<Handle<Quote>>, jumpDates?: Date[]): YieldCurve;
  maxDate(): Date;
  times(): Time[];
  dates(): Date[];
  data(): Real[];
  zeroRates(): Rate[];
  nodes(): Array<[Date, Real]>;
  zeroYieldImpl(t: Time): Rate;
  private initialize;
  _dates: Date[];
}
export declare class ZeroCurve extends InterpolatedZeroCurve {
  constructor();
}

export declare class ZeroSpreadedTermStructure extends ZeroYieldStructure {
  constructor(
      h: Handle<YieldTermStructure>, spread: Handle<Quote>, comp?: Compounding,
      freq?: Frequency, dc?: DayCounter);
  dayCounter(): DayCounter;
  calendar(): Calendar;
  settlementDays(): Natural;
  referenceDate(): Date;
  maxDate(): Date;
  maxTime(): Time;
  update(): void;
  zeroYieldImpl(t: Time): Rate;
  forwardImpl(t: Time): Rate;
  private _originalCurve;
  private _spread;
  private _comp;
  private _freq;
  _dc: DayCounter;
}

export declare class ZeroYieldStructure extends YieldTermStructure {
  zeroYieldImpl(t: Time): Rate;
  discountImpl(t: Time): DiscountFactor;
}

export declare class AbcdCalibration {
  constructor(
      t: Real[], blackVols: Real[], aGuess?: Real, bGuess?: Real, cGuess?: Real,
      dGuess?: Real, aIsFixed?: boolean, bIsFixed?: boolean, cIsFixed?: boolean,
      dIsFixed?: boolean, vegaWeighted?: boolean, endCriteria?: EndCriteria,
      optMethod?: OptimizationMethod);
  endCriteria(): EndCriteria.Type;
  a(): Real;
  b(): Real;
  c(): Real;
  d(): Real;
  _aIsFixed: boolean;
  _bIsFixed: boolean;
  _cIsFixed: boolean;
  _dIsFixed: boolean;
  _a: Real;
  _b: Real;
  _c: Real;
  _d: Real;
  _transformation: ParametersTransformation;
  private _abcdEndCriteria;
  private _endCriteria;
  private _optMethod;
}
export declare namespace AbcdCalibration {
  class AbcdError extends CostFunction {
    constructor(abcd: AbcdCalibration);
  }
  class AbcdParametersTransformation extends ParametersTransformation {
    constructor();
    direct(x: Real[]): Real[];
    inverse(x: Real[]): Real[];
    private _y;
  }
}

export declare class AbcdFunction extends AbcdMathFunction {
  constructor(a?: Real, b?: Real, c?: Real, d?: Real);
  maximumVolatility(): Real;
  shortTermVolatility(): Real;
  longTermVolatility(): Real;
  covariance1(t: Time, T: Time, S: Time): Real;
  covariance2(t1: Time, t2: Time, T: Time, S: Time): Real;
  volatility(tMin: Time, tMax: Time, T: Time): Real;
  variance(tMin: Time, tMax: Time, T: Time): Real;
  instantaneousVolatility(u: Time, T: Time): Real;
  instantaneousVariance(u: Time, T: Time): Real;
  instantaneousCovariance(u: Time, T: Time, S: Time): Real;
  primitive2(t: Time, T: Time, S: Time): Real;
}
export declare class AbcdSquared implements UnaryFunction<Time, Real> {
  constructor(a: Real, b: Real, c: Real, d: Real, T: Time, S: Time);
  f(t: Time): Real;
  private _abcd;
  private _T;
  private _S;
}

export declare class AtmAdjustedSmileSection extends SmileSection {}

export declare class AtmSmileSection extends SmileSection {
  constructor(source: SmileSection, atm?: Real);
}

export declare class FlatSmileSection extends SmileSection {
  fssInit1(
      d: Date, vol: Volatility, dc: DayCounter, referenceDate?: Date,
      atmLevel?: Real, type?: VolatilityType, shift?: Real): FlatSmileSection;
  fssInit2(
      exerciseTime: Time, vol: Volatility, dc: DayCounter, atmLevel?: Real,
      type?: VolatilityType, shift?: Real): FlatSmileSection;
  minStrike(): Real;
  maxStrike(): Real;
  atmLevel(): Real;
  protected volatilityImpl1(strike: Rate): Volatility;
  private _vol;
  private _atmLevel;
}

export declare class Gaussian1dSmileSection extends SmileSection {}

export declare class InterpolatedSmileSection extends SmileSectionLazyObject {
  constructor(i: Interpolator);
  issInit1(
      expiryTime: Time, strikes: Rate[], stdDevHandles: Array<Handle<Quote>>,
      atmLevel: Handle<Quote>, dc?: DayCounter, type?: VolatilityType,
      shift?: Real): InterpolatedSmileSection;
  issInit2(
      expiryTime: Time, strikes: Rate[], stdDevHandles: Real[], atmLevel: Real,
      dc?: DayCounter, type?: VolatilityType,
      shift?: Real): InterpolatedSmileSection;
  issInit3(
      d: Date, strikes: Rate[], stdDevHandles: Array<Handle<Quote>>,
      atmLevel: Handle<Quote>, dc?: DayCounter, referenceDate?: Date,
      type?: VolatilityType, shift?: Real): InterpolatedSmileSection;
  issInit4(
      d: Date, strikes: Rate[], stdDevHandles: Real[], atmLevel: Real,
      dc?: DayCounter, referenceDate?: Date, type?: VolatilityType,
      shift?: Real): InterpolatedSmileSection;
  i: Interpolator;
}

export declare class KahaleSmileSection extends SmileSection {
  constructor(
      source: SmileSection, atm?: Real, interpolate?: boolean,
      exponentialExtrapolation?: boolean, deleteArbitragePoints?: boolean,
      moneynessGrid?: Real[], gap?: Real, forcedLeftIndex?: Integer,
      forcedRightIndex?: Integer);
  minStrike(): Real;
  maxStrike(): Real;
  atmLevel(): Real;
  exerciseDate(): Date;
  exerciseTime(): Time;
  dayCounter(): DayCounter;
  referenceDate(): Date;
  volatilityType(): VolatilityType;
  shift(): Real;
  leftCoreStrike(): Real;
  rightCoreStrike(): Real;
  coreIndices(): [Size, Size];
  optionPrice(strike: Rate, type?: Option.Type, discount?: Real): Real;
  volatilityImpl(strike: Rate): Volatility;
  private index;
  private compute;
  private _source;
  private _moneynessGrid;
  private _k;
  private _c;
  private _f;
  private _gap;
  private _leftIndex;
  private _rightIndex;
  private _cFunctions;
  private _interpolate;
  private _exponentialExtrapolation;
  private _forcedLeftIndex;
  private _forcedRightIndex;
  private _ssutils;
}

export declare function unsafeSabrVolatility(
    strike: Rate, forward: Rate, expiryTime: Time, alpha: Real, beta: Real,
    nu: Real, rho: Real): Real;
export declare function unsafeShiftedSabrVolatility(
    strike: Rate, forward: Rate, expiryTime: Time, alpha: Real, beta: Real,
    nu: Real, rho: Real, shift: Real): Real;
export declare function sabrVolatility(
    strike: Rate, forward: Rate, expiryTime: Time, alpha: Real, beta: Real,
    nu: Real, rho: Real): Real;
export declare function shiftedSabrVolatility(
    strike: Rate, forward: Rate, expiryTime: Time, alpha: Real, beta: Real,
    nu: Real, rho: Real, shift: Real): Real;
export declare function validateSabrParameters(
    alpha: Real, beta: Real, nu: Real, rho: Real): void;

export declare class SabrInterpolatedSmileSection extends
    SmileSectionLazyObject {
  sissInit1(): SabrInterpolatedSmileSection;
  sissInit2(
      optionDate: Date, forward: Rate, strikes: Rate[],
      hasFloatingStrikes: boolean, atmVolatility: Volatility,
      vols: Volatility[], alpha: Real, beta: Real, nu: Real, rho: Real,
      isAlphaFixed?: boolean, isBetaFixed?: boolean, isNuFixed?: boolean,
      isRhoFixed?: boolean, vegaWeighted?: boolean, endCriteria?: EndCriteria,
      method?: OptimizationMethod, dc?: DayCounter,
      shift?: Real): SabrInterpolatedSmileSection;
}

export declare class SmileSection extends ObserverObservable {
  init1(
      d: Date, dc?: DayCounter, referenceDate?: Date, type?: VolatilityType,
      shift?: Rate): SmileSection;
  init2(
      exerciseTime: Time, dc?: DayCounter, type?: VolatilityType,
      shift?: Rate): SmileSection;
  update(): void;
  minStrike(): Real;
  maxStrike(): Real;
  variance(strike: Rate): Real;
  volatility1(strike: Rate): Volatility;
  atmLevel(): Real;
  exerciseDate(): Date;
  volatilityType(): VolatilityType;
  shift(): Rate;
  referenceDate(): Date;
  exerciseTime(): Time;
  dayCounter(): DayCounter;
  optionPrice(strike: Rate, type?: Option.Type, discount?: Real): Real;
  digitalOptionPrice(
      strike: Rate, type?: Option.Type, discount?: Real, gap?: Real): Real;
  vega(strike: Rate, discount?: Real): Real;
  density(strike: Rate, discount?: Real, gap?: Real): Real;
  volatility2(strike: Rate, volatilityType: VolatilityType, shift?: Real):
      Volatility;
  initializeExerciseTime(): void;
  varianceImpl(strike: Rate): Real;
  volatilityImpl(strike: Rate): Volatility;
  _isFloating: boolean;
  _referenceDate: Date;
  _exerciseDate: Date;
  _dc: DayCounter;
  _exerciseTime: Time;
  _volatilityType: VolatilityType;
  _shift: Rate;
}

export declare class SabrSmileSection extends SmileSection {
  sssInit1(
      timeToExpiry: Time, forward: Rate, sabrParameters: Real[],
      shift?: Real): SabrSmileSection;
  sssInit2(
      d: Date, forward: Rate, sabrParameters: Real[], dc?: DayCounter,
      shift?: Real): SabrSmileSection;
}

export declare class SmileSectionUtils {
  constructor(
      section: SmileSection, moneynessGrid?: Real[], atm?: Real,
      deleteArbitragePoints?: boolean);
  moneyGrid(): Real[];
  strikeGrid(): Real[];
  private _m;
  private _k;
}

export declare class SpreadedSmileSection extends SmileSection {}

export declare enum VolatilityType {ShiftedLognormal = 0, Normal = 1}

export declare class CapFloorTermVolatilityStructure extends
    VolatilityTermStructure {
  volatility1(optT: Period, strike: Rate, extrap?: boolean): Volatility;
  volatility2(d: Date, strike: Rate, extrap?: boolean): Volatility;
  volatility3(t: Time, strike: Rate, extrap?: boolean): Volatility;
  volatilityImpl(length: Time, strike: Rate): Volatility;
}

export declare class CapFloorTermVolCurve extends
    CapFloorTermVolatilityStructureLazyObject {
  cftvcInit1(
      settlementDays: Natural, calendar: Calendar, bdc: BusinessDayConvention,
      optionTenors: Period[], vols: Array<Handle<Quote>>,
      dc?: DayCounter): CapFloorTermVolCurve;
  cftvcInit2(
      settlementDate: Date, calendar: Calendar, bdc: BusinessDayConvention,
      optionTenors: Period[], vols: Array<Handle<Quote>>,
      dayCounter?: DayCounter): CapFloorTermVolCurve;
  cftvcInit3(
      settlementDate: Date, calendar: Calendar, bdc: BusinessDayConvention,
      optionTenors: Period[], vols: Volatility[],
      dayCounter?: DayCounter): CapFloorTermVolCurve;
  cftvcInit4(
      settlementDays: Natural, calendar: Calendar, bdc: BusinessDayConvention,
      optionTenors: Period[], vols: Volatility[],
      dayCounter?: DayCounter): CapFloorTermVolCurve;
  maxDate(): Date;
  minStrike(): Real;
  maxStrike(): Real;
  optionTenors(): Period[];
  optionDates(): Date[];
  optionTimes(): Time[];
  update(): void;
  performCalculations(): void;
  volatilityImpl(t: Time, r: Rate): Volatility;
  private checkInputs;
  private initializeOptionDatesAndTimes;
  private registerWithMarketData;
  private interpolate;
  private _nOptionTenors;
  private _optionTenors;
  private _optionDates;
  private _optionTimes;
  private _evaluationDate;
  private _volHandles;
  private _vols;
  private _interpolation;
}

export declare class CapFloorTermVolSurface extends
    CapFloorTermVolatilityStructureLazyObject {
  cftvsInit1(
      settlementDays: Natural, calendar: Calendar, bdc: BusinessDayConvention,
      optionTenors: Period[], strikes: Rate[],
      vols: Array<Array<Handle<Quote>>>,
      dc?: DayCounter): CapFloorTermVolSurface;
  cftvsInit2(
      settlementDate: Date, calendar: Calendar, bdc: BusinessDayConvention,
      optionTenors: Period[], strikes: Rate[],
      vols: Array<Array<Handle<Quote>>>,
      dc?: DayCounter): CapFloorTermVolSurface;
  cftvsInit3(
      settlementDate: Date, calendar: Calendar, bdc: BusinessDayConvention,
      optionTenors: Period[], strikes: Rate[], vols: Matrix,
      dc?: DayCounter): CapFloorTermVolSurface;
  cftvsInit4(
      settlementDays: Natural, calendar: Calendar, bdc: BusinessDayConvention,
      optionTenors: Period[], strikes: Rate[], vols: Matrix,
      dc?: DayCounter): CapFloorTermVolSurface;
  maxDate(): Date;
  minStrike(): Real;
  maxStrike(): Real;
  optionTenors(): Period[];
  optionDates(): Date[];
  optionTimes(): Time[];
  strikes(): Rate[];
  update(): void;
  performCalculations(): void;
  volatilityImpl(t: Time, strike: Rate): Volatility;
  private checkInputs;
  private initializeOptionDatesAndTimes;
  private registerWithMarketData;
  private interpolate;
  private _nOptionTenors;
  private _optionTenors;
  private _optionDates;
  private _optionTimes;
  private _evaluationDate;
  private _nStrikes;
  private _strikes;
  private _volHandles;
  private _vols;
  private _interpolation;
}

export declare class ConstantCapFloorTermVolatility extends
    CapFloorTermVolatilityStructure {}

export declare class AndreasenHugeLocalVolAdapter extends
    LocalVolTermStructure {
  constructor(localVol: AndreasenHugeVolatilityInterpl);
  maxDate(): Date;
  minStrike(): Real;
  maxStrike(): Real;
  calendar(): Calendar;
  dayCounter(): DayCounter;
  referenceDate(): Date;
  settlementDays(): Natural;
  localVolImpl(t: Time, strike: Real): Volatility;
  private _localVol;
}

export declare class AndreasenHugeVolatilityAdapter extends
    BlackVarianceTermStructure {
  constructor(volInterpl: AndreasenHugeVolatilityInterpl, eps?: Real);
  maxDate(): Date;
  minStrike(): Real;
  maxStrike(): Real;
  calendar(): Calendar;
  dayCounter(): DayCounter;
  referenceDate(): Date;
  settlementDays(): Natural;
  blackVarianceImpl(t: Time, strike: Real): Real;
  private _eps;
  private _volInterpl;
}

export declare class AndreasenHugeVolatilityInterpl extends LazyObject {
  constructor(
      calibrationSet: AndreasenHugeVolatilityInterpl.CalibrationSet,
      spot: Handle<Quote>, rTS: Handle<YieldTermStructure>,
      qTS: Handle<YieldTermStructure>,
      interpolationType?: AndreasenHugeVolatilityInterpl.InterpolationType,
      calibrationType?: AndreasenHugeVolatilityInterpl.CalibrationType,
      nGridPoints?: Size, minStrike?: Real, maxStrike?: Real,
      optimizationMethod?: OptimizationMethod, endCriteria?: EndCriteria);
  maxDate(): Date;
  minStrike(): Real;
  maxStrike(): Real;
  fwd(t: Time): Real;
  riskFreeRate(): Handle<YieldTermStructure>;
  calibrationError(): [Real, Real, Real];
  optionPrice(t: Time, strike: Real, optionType: Option.Type): Real;
  localVol(t: Time, strike: Real): Volatility;
  performCalculations(): void;
  private buildCostFunction;
  private getExerciseTimeIdx;
  private getCacheValue;
  private getPriceSlice;
  private getLocalVolSlice;
  private _calibrationSet;
  private _spot;
  private _rTS;
  private _qTS;
  private _interpolationType;
  private _calibrationType;
  private _nGridPoints;
  private _minStrike;
  private _maxStrike;
  private _optimizationMethod;
  private _endCriteria;
  private _strikes;
  private _expiries;
  private _expiryTimes;
  private _dT;
  private _calibrationMatrix;
  private _avgError;
  private _minError;
  private _maxError;
  private _mesher;
  private _gridPoints;
  private _gridInFwd;
  private _calibrationResults;
  private _localVolCache;
  private _priceCache;
}
export declare namespace AndreasenHugeVolatilityInterpl {
  enum InterpolationType { PiecewiseConstant = 0, Linear = 1, CubicSpline = 2 }
  enum CalibrationType { Call = 1, Put = -1, CallPut = 0 }
  type CalibrationSet = Array<[VanillaOption, Quote]>;
}

export declare class BlackConstantVol extends BlackVolatilityTermStructure {
  bcvInit1(
      referenceDate: Date, cal: Calendar, volatility: Volatility,
      dc: DayCounter): BlackConstantVol;
  bcvInit2(
      referenceDate: Date, cal: Calendar, volatility: Handle<Quote>,
      dc: DayCounter): BlackConstantVol;
  bcvInit3(
      settlementDays: Natural, cal: Calendar, volatility: Volatility,
      dc: DayCounter): BlackConstantVol;
  bcvInit4(
      settlementDays: Natural, cal: Calendar, volatility: Handle<Quote>,
      dc: DayCounter): BlackConstantVol;
  maxDate(): Date;
  minStrike(): Real;
  maxStrike(): Real;
  blackVolImpl(t: Time, strike: Real): Volatility;
  accept(v: AcyclicVisitor): void;
  private _volatility;
}

export declare class BlackVarianceCurve extends BlackVarianceTermStructure {
  constructor(
      referenceDate: Date, dates: Date[], blackVolCurve: Volatility[],
      dayCounter: DayCounter, forceMonotoneVariance?: boolean);
  dayCounter(): DayCounter;
  maxDate(): Date;
  minStrike(): Real;
  maxStrike(): Real;
  setInterpolation(i: Interpolator): void;
  blackVarianceImpl(t: Time, strike: Real): Real;
  accept(v: AcyclicVisitor): void;
  _dayCounter: DayCounter;
  private _maxDate;
  private _times;
  private _variances;
  private _varianceCurve;
}

export declare class BlackVarianceSurface extends BlackVarianceTermStructure {
  constructor(
      referenceDate: Date, cal: Calendar, dates: Date[], strikes: Real[],
      blackVolMatrix: Matrix, dayCounter: DayCounter,
      lowerExtrapolation?: BlackVarianceSurface.Extrapolation,
      upperExtrapolation?: BlackVarianceSurface.Extrapolation);
  dayCounter(): DayCounter;
  maxDate(): Date;
  minStrike(): Real;
  maxStrike(): Real;
  blackVarianceImpl(t: Time, strike: Real): Real;
  setInterpolation(i?: Interpolator2D): void;
  accept(v: AcyclicVisitor): void;
  _dayCounter: DayCounter;
  private _maxDate;
  private _strikes;
  private _times;
  private _variances;
  private _varianceSurface;
  private _lowerExtrapolation;
  private _upperExtrapolation;
}
export declare namespace BlackVarianceSurface {
  enum Extrapolation {
    ConstantExtrapolation = 0,
    InterpolatorDefaultExtrapolation = 1
  }
}

export declare class BlackVolTermStructure extends VolatilityTermStructure {
  constructor();
  bvtsInit1(bdc?: BusinessDayConvention, dc?: DayCounter):
      BlackVolTermStructure;
  bvtsInit2(
      referenceDate: Date, cal?: Calendar, bdc?: BusinessDayConvention,
      dc?: DayCounter): BlackVolTermStructure;
  bvtsInit3(
      settlementDays: Natural, cal: Calendar, bdc?: BusinessDayConvention,
      dc?: DayCounter): BlackVolTermStructure;
  blackVol1(d: Date, strike: Real, extrapolate?: boolean): Volatility;
  blackVol2(t: Time, strike: Real, extrapolate?: boolean): Volatility;
  blackVariance1(d: Date, strike: Real, extrapolate?: boolean): Volatility;
  blackVariance2(t: Time, strike: Real, extrapolate?: boolean): Volatility;
  blackForwardVol1(
      date1: Date, date2: Date, strike: Real,
      extrapolate?: boolean): Volatility;
  blackForwardVol2(
      time1: Time, time2: Time, strike: Real,
      extrapolate?: boolean): Volatility;
  blackForwardVariance1(
      date1: Date, date2: Date, strike: Real,
      extrapolate?: boolean): Volatility;
  blackForwardVariance2(
      time1: Time, time2: Time, strike: Real,
      extrapolate?: boolean): Volatility;
  accept(v: AcyclicVisitor): void;
  blackVarianceImpl(t: Time, strike: Real): Real;
  blackVolImpl(t: Time, strike: Real): Volatility;
}
export declare class BlackVolatilityTermStructure extends
    BlackVolTermStructure {
  blackVarianceImpl(t: Time, strike: Real): Real;
  accept(v: AcyclicVisitor): void;
}
export declare class BlackVarianceTermStructure extends BlackVolTermStructure {
  blackVolImpl(t: Time, strike: Real): Volatility;
  accept(v: AcyclicVisitor): void;
}

export declare class FixedLocalVolSurface extends LocalVolTermStructure {
  flvsInit1(
      referenceDate: Date, dates: Date[], strikes: Real[],
      localVolMatrix: Matrix, dayCounter: DayCounter,
      lowerExtrapolation?: FixedLocalVolSurface.Extrapolation,
      upperExtrapolation?: FixedLocalVolSurface.Extrapolation):
      FixedLocalVolSurface;
  flvsInit2(
      referenceDate: Date, times: Time[], strikes: Real[],
      localVolMatrix: Matrix, dayCounter: DayCounter,
      lowerExtrapolation?: FixedLocalVolSurface.Extrapolation,
      upperExtrapolation?: FixedLocalVolSurface.Extrapolation):
      FixedLocalVolSurface;
  flvsInit3(
      referenceDate: Date, times: Time[], strikes: Real[][],
      localVolMatrix: Matrix, dayCounter: DayCounter,
      lowerExtrapolation?: FixedLocalVolSurface.Extrapolation,
      upperExtrapolation?: FixedLocalVolSurface.Extrapolation):
      FixedLocalVolSurface;
  maxDate(): Date;
  maxTime(): Time;
  minStrike(): Real;
  maxStrike(): Real;
  setInterpolation(i?: Interpolator): void;
  localVolImpl(t: Time, strike: Real): Volatility;
  private checkSurface;
  protected _maxDate: Date;
  protected _times: Time[];
  protected _localVolMatrix: Matrix;
  protected _strikes: Real[][];
  protected _localVolInterpol: Interpolation[];
  protected _lowerExtrapolation: FixedLocalVolSurface.Extrapolation;
  protected _upperExtrapolation: FixedLocalVolSurface.Extrapolation;
}
export declare namespace FixedLocalVolSurface {
  enum Extrapolation {
    ConstantExtrapolation = 0,
    InterpolatorDefaultExtrapolation = 1
  }
}

export declare class GridModelLocalVolSurface {}

export declare class HestonBlackVolSurface extends BlackVolTermStructure {
  constructor(
      hestonModel: Handle<HestonModel>,
      cpxLogFormula?: AnalyticHestonEngine.ComplexLogFormula,
      integration?: AnalyticHestonEngine.Integration);
  dayCounter(): DayCounter;
  maxDate(): Date;
  minStrike(): Real;
  maxStrike(): Real;
  blackVarianceImpl(t: Time, strike: Real): Real;
  blackVolImpl(t: Time, strike: Real): Volatility;
  private _hestonModel;
  private _cpxLogFormula;
  private _integration;
}

export declare class ImpliedVolTermStructure extends
    BlackVarianceTermStructure {
  ivtInit(originalTS: Handle<BlackVolTermStructure>, referenceDate: Date):
      ImpliedVolTermStructure;
  dayCounter(): DayCounter;
  maxDate(): Date;
  minStrike(): Real;
  maxStrike(): Real;
  accept(v: AcyclicVisitor): void;
  blackVarianceImpl(t: Time, strike: Real): Real;
  private _originalTS;
}

export declare class LocalConstantVol extends LocalVolTermStructure {
  lcvInit1(referenceDate: Date, volatility: Volatility, dayCounter: DayCounter):
      LocalConstantVol;
  lcvInit2(
      referenceDate: Date, volatility: Handle<Quote>,
      dayCounter: DayCounter): LocalConstantVol;
  lcvInit3(
      settlementDays: Natural, calendar: Calendar, volatility: Volatility,
      dayCounter: DayCounter): LocalConstantVol;
  lcvInit4(
      settlementDays: Natural, calendar: Calendar, volatility: Handle<Quote>,
      dayCounter: DayCounter): LocalConstantVol;
  dayCounter(): DayCounter;
  maxDate(): Date;
  minStrike(): Real;
  maxStrike(): Real;
  localVolImpl(t: Time, strike: Real): Volatility;
  accept(v: AcyclicVisitor): void;
  private _volatility;
  _dayCounter: DayCounter;
}

export declare class LocalVolCurve extends LocalVolTermStructure {
  constructor(curve: Handle<BlackVarianceCurve>);
  referenceDate(): Date;
  calendar(): Calendar;
  dayCounter(): DayCounter;
  maxDate(): Date;
  minStrike(): Real;
  maxStrike(): Real;
  localVolImpl(t: Time, dummy: Real): Volatility;
  accept(v: AcyclicVisitor): void;
  private _blackVarianceCurve;
}

export declare class LocalVolSurface extends LocalVolTermStructure {
  lvsInit1(
      blackTS: Handle<BlackVolTermStructure>,
      riskFreeTS: Handle<YieldTermStructure>,
      dividendTS: Handle<YieldTermStructure>,
      underlying: Handle<Quote>): LocalVolSurface;
  lvsInit2(
      blackTS: Handle<BlackVolTermStructure>,
      riskFreeTS: Handle<YieldTermStructure>,
      dividendTS: Handle<YieldTermStructure>,
      underlying: Real): LocalVolSurface;
  referenceDate(): Date;
  dayCounter(): DayCounter;
  maxDate(): Date;
  minStrike(): Real;
  maxStrike(): Real;
  localVolImpl(t: Time, underlyingLevel: Real): Volatility;
  accept(v: AcyclicVisitor): void;
  private _blackTS;
  private _riskFreeTS;
  private _dividendTS;
  private _underlying;
}

export declare class LocalVolTermStructure extends VolatilityTermStructure {
  lvtsInit1(bdc?: BusinessDayConvention, dc?: DayCounter):
      LocalVolTermStructure;
  lvtsInit2(
      referenceDate: Date, cal?: Calendar, bdc?: BusinessDayConvention,
      dc?: DayCounter): LocalVolTermStructure;
  lvtsInit3(
      settlementDays: Natural, cal: Calendar, bdc?: BusinessDayConvention,
      dc?: DayCounter): LocalVolTermStructure;
  localVol1(d: Date, underlyingLevel: Real, extrapolate?: boolean): Volatility;
  localVol2(t: Time, underlyingLevel: Real, extrapolate?: boolean): Volatility;
  localVolImpl(t: Time, strike: Real): Volatility;
  accept(v: AcyclicVisitor): void;
}

export declare class NoExceptLocalVolSurface extends LocalVolSurface {
  nelvsInit1(
      blackTS: Handle<BlackVolTermStructure>,
      riskFreeTS: Handle<YieldTermStructure>,
      dividendTS: Handle<YieldTermStructure>, underlying: Handle<Quote>,
      illegalLocalVolOverwrite: Real): NoExceptLocalVolSurface;
  nelvsInit2(
      blackTS: Handle<BlackVolTermStructure>,
      riskFreeTS: Handle<YieldTermStructure>,
      dividendTS: Handle<YieldTermStructure>, underlying: Real,
      illegalLocalVolOverwrite: Real): NoExceptLocalVolSurface;
  localVolImpl(t: Time, s: Real): Volatility;
  private _illegalLocalVolOverwrite;
}

export declare class ConstantCPIVolatility extends CPIVolatilitySurface {
  ccpivInit(
      v: Volatility, settlementDays: Natural, cal: Calendar,
      bdc: BusinessDayConvention, dc: DayCounter, observationLag: Period,
      frequency: Frequency,
      indexIsInterpolated: boolean): ConstantCPIVolatility;
  maxDate(): Date;
  minStrike(): Real;
  maxStrike(): Real;
  protected volatilityImpl(length: Time, strike: Rate): Volatility;
  private _volatility;
}

export declare class CPIVolatilitySurface extends VolatilityTermStructure {
  cpivsInit(
      settlementDays: Natural, cal: Calendar, bdc: BusinessDayConvention,
      dc: DayCounter, observationLag: Period, frequency: Frequency,
      indexIsInterpolated: boolean): CPIVolatilitySurface;
  volatility1(
      maturityDate: Date, strike: Rate, obsLag?: Period,
      extrapolate?: boolean): Volatility;
  volatility2(
      optionTenor: Period, strike: Rate, obsLag?: Period,
      extrapolate?: boolean): Volatility;
  totalVariance1(
      maturityDate: Date, strike: Rate, obsLag?: Period,
      extrapolate?: boolean): Volatility;
  totalVariance2(
      tenor: Period, strike: Rate, obsLag?: Period,
      extrap?: boolean): Volatility;
  observationLag(): Period;
  frequency(): Frequency;
  indexIsInterpolated(): boolean;
  baseDate(): Date;
  timeFromBase(maturityDate: Date, obsLag?: Period): Time;
  baseLevel(): Volatility;
  minStrike(): Real;
  maxStrike(): Real;
  protected checkRange3(d: Date, strike: Rate, extrapolate: boolean): void;
  protected checkRange4(t: Time, strike: Rate, extrapolate: boolean): void;
  protected volatilityImpl(length: Time, strike: Rate): Volatility;
  protected _baseLevel: Volatility;
  protected _observationLag: Period;
  protected _frequency: Frequency;
  protected _indexIsInterpolated: boolean;
}

export declare class YoYOptionletVolatilitySurface extends
    VolatilityTermStructure {
  yoyovsInit(
      settlementDays: Natural, cal: Calendar, bdc: BusinessDayConvention,
      dc: DayCounter, observationLag: Period, frequency: Frequency,
      indexIsInterpolated: boolean): YoYOptionletVolatilitySurface;
  volatility1(
      maturityDate: Date, strike: Rate, obsLag?: Period,
      extrapolate?: boolean): Volatility;
  volatility2(
      optionTenor: Period, strike: Rate, obsLag?: Period,
      extrapolate?: boolean): Volatility;
  totalVariance1(
      maturityDate: Date, strike: Rate, obsLag?: Period,
      extrapolate?: boolean): Volatility;
  totalVariance2(
      tenor: Period, strike: Rate, obsLag?: Period,
      extrap?: boolean): Volatility;
  observationLag(): Period;
  frequency(): Frequency;
  indexIsInterpolated(): boolean;
  baseDate(): Date;
  timeFromBase(maturityDate: Date, obsLag?: Period): Time;
  minStrike(): Real;
  maxStrike(): Real;
  baseLevel(): Volatility;
  checkRange3(d: Date, strike: Rate, extrapolate: boolean): void;
  checkRange4(t: Time, strike: Rate, extrapolate: boolean): void;
  volatilityImpl(length: Time, strike: Rate): Volatility;
  setBaseLevel(v: Volatility): void;
  _baseLevel: Volatility;
  _observationLag: Period;
  _frequency: Frequency;
  _indexIsInterpolated: boolean;
}
export declare class ConstantYoYOptionletVolatility extends
    YoYOptionletVolatilitySurface {
  cyoyovInit(
      v: Volatility, settlementDays: Natural, cal: Calendar,
      bdc: BusinessDayConvention, dc: DayCounter, observationLag: Period,
      frequency: Frequency, indexIsInterpolated: boolean, minStrike?: Rate,
      maxStrike?: Rate): ConstantYoYOptionletVolatility;
  volatilityImpl(length: Time, strike: Rate): Volatility;
  _volatility: Volatility;
  _minStrike: Rate;
  _maxStrike: Rate;
}

export declare class CapletVarianceCurve extends OptionletVolatilityStructure {
  constructor(
      referenceDate: Date, dates: Date[], capletVolCurve: Volatility[],
      dayCounter: DayCounter, type?: VolatilityType, displacement?: Real);
  dayCounter(): DayCounter;
  maxDate(): Date;
  minStrike(): Real;
  maxStrike(): Real;
  volatilityType(): VolatilityType;
  displacement(): Real;
  smileSectionImpl(t: Time): SmileSection;
  volatilityImpl(t: Time, r: Rate): Volatility;
  private _blackCurve;
  private _type;
  private _displacement;
}

export declare class ConstantOptionletVolatility extends
    OptionletVolatilityStructure {
  covInit1(
      settlementDays: Natural, cal: Calendar, bdc: BusinessDayConvention,
      volatility: Handle<Quote>, dc: DayCounter, type?: VolatilityType,
      displacement?: Real): ConstantOptionletVolatility;
  covInit2(
      referenceDate: Date, cal: Calendar, bdc: BusinessDayConvention,
      volatility: Handle<Quote>, dc: DayCounter, type?: VolatilityType,
      displacement?: Real): ConstantOptionletVolatility;
  covInit3(
      settlementDays: Natural, cal: Calendar, bdc: BusinessDayConvention,
      volatility: Volatility, dc: DayCounter, type?: VolatilityType,
      displacement?: Real): ConstantOptionletVolatility;
  covInit4(
      referenceDate: Date, cal: Calendar, bdc: BusinessDayConvention,
      volatility: Volatility, dc: DayCounter, type?: VolatilityType,
      displacement?: Real): ConstantOptionletVolatility;
  maxDate(): Date;
  minStrike(): Real;
  maxStrike(): Real;
  volatilityType(): VolatilityType;
  displacement(): Real;
  smileSectionImpl1(d: Date): SmileSection;
  smileSectionImpl2(optionTime: Time): SmileSection;
  volatilityImpl2(optionTime: Time, strike: Rate): Volatility;
  private _volatility;
  private _type;
  private _displacement;
}

export declare class OptionletStripper extends StrippedOptionletBase {
  constructor(
      termVolSurface: CapFloorTermVolSurface, iborIndex: IborIndex,
      discount: Handle<YieldTermStructure>, type: VolatilityType,
      displacement: Real);
  optionletStrikes(i: Size): Rate[];
  optionletVolatilities(i: Size): Volatility[];
  optionletFixingTenors(): Period[];
  optionletFixingDates(): Date[];
  optionletFixingTimes(): Time[];
  optionletMaturities(): Size;
  optionletPaymentDates(): Date[];
  optionletAccrualPeriods(): Time[];
  atmOptionletRates(): Rate[];
  dayCounter(): DayCounter;
  calendar(): Calendar;
  settlementDays(): Natural;
  businessDayConvention(): BusinessDayConvention;
  termVolSurface(): CapFloorTermVolSurface;
  iborIndex(): IborIndex;
  displacement(): Real;
  volatilityType(): VolatilityType;
  protected _termVolSurface: CapFloorTermVolSurface;
  protected _iborIndex: IborIndex;
  protected _discount: Handle<YieldTermStructure>;
  protected _nStrikes: Size;
  protected _nOptionletTenors: Size;
  protected _optionletStrikes: Rate[][];
  protected _optionletVolatilities: Volatility[][];
  protected _optionletTimes: Time[];
  protected _optionletDates: Date[];
  protected _optionletTenors: Period[];
  protected _atmOptionletRate: Rate[];
  protected _optionletPaymentDates: Date[];
  protected _optionletAccrualPeriods: Time[];
  protected _capFloorLengths: Period[];
  protected _volatilityType: VolatilityType;
  protected _displacement: Real;
}

export declare class OptionletStripper1 extends OptionletStripper {
  constructor(
      termVolSurface: CapFloorTermVolSurface, index: IborIndex,
      switchStrike?: Rate, accuracy?: Real, maxIter?: Natural,
      discount?: Handle<YieldTermStructure>, type?: VolatilityType,
      displacement?: Real, dontThrow?: boolean);
  capletVols(): Matrix;
  capFloorPrices(): Matrix;
  capFloorVolatilities(): Matrix;
  optionletPrices(): Matrix;
  switchStrike(): Rate;
  performCalculations(): void;
  private _capFloorPrices;
  private _optionletPrices;
  private _capFloorVols;
  private _optionletStDevs;
  private _capletVols;
  private _floatingSwitchStrike;
  private _switchStrike;
  private _accuracy;
  private _maxIter;
  private _dontThrow;
}

export declare class OptionletStripper2 extends OptionletStripper {
  constructor(
      optionletStripper1: OptionletStripper1,
      atmCapFloorTermVolCurve: Handle<CapFloorTermVolCurve>);
  spreadsVol(): Volatility[];
  atmCapFloorStrikes(): Rate[];
  atmCapFloorPrices(): Real[];
  spreadsVolImplied(): Volatility[];
  performCalculations(): void;
  private _stripper1;
  private _atmCapFloorTermVolCurve;
  private _dc;
  private _nOptionExpiries;
  private _atmCapFloorStrikes;
  private _atmCapFloorPrices;
  private _spreadsVolImplied;
  private _caps;
  private _maxEvaluations;
  private _accuracy;
}

export declare class OptionletVolatilityStructure extends
    VolatilityTermStructure {
  constructor();
  ovsInit1(bdc?: BusinessDayConvention, dc?: DayCounter):
      OptionletVolatilityStructure;
  ovsInit2(
      referenceDate: Date, cal: Calendar, bdc: BusinessDayConvention,
      dc?: DayCounter): OptionletVolatilityStructure;
  ovsInit3(
      settlementDays: Natural, cal: Calendar, bdc: BusinessDayConvention,
      dc?: DayCounter): OptionletVolatilityStructure;
  volatility1(optionTenor: Period, strike: Rate, extrapolate?: boolean):
      Volatility;
  volatility2(optionDate: Date, strike: Rate, extrapolate?: boolean):
      Volatility;
  volatility3(optionTime: Time, strike: Rate, extrapolate?: boolean):
      Volatility;
  blackVariance1(optionTenor: Period, strike: Rate, extrapolate?: boolean):
      Volatility;
  blackVariance2(optionDate: Date, strike: Rate, extrapolate?: boolean):
      Volatility;
  blackVariance3(optionTime: Time, strike: Rate, extrapolate?: boolean):
      Volatility;
  smileSection1(optionTenor: Period, extr?: boolean): SmileSection;
  smileSection2(optionDate: Date, extr?: boolean): SmileSection;
  smileSection3(optionTime: Time, extr?: boolean): SmileSection;
  volatilityType(): VolatilityType;
  displacement(): Real;
  volatilityImpl1(optionDate: Date, strike: Rate): Volatility;
  volatilityImpl2(optionTime: Time, strike: Rate): Volatility;
  smileSectionImpl1(optionDate: Date): SmileSection;
  smileSectionImpl2(optionTime: Time): SmileSection;
}

export declare class SpreadedOptionletVolatility extends
    OptionletVolatilityStructure {}

export declare class StrippedOptionlet extends StrippedOptionletBase {}

export declare class StrippedOptionletAdapter extends
    OptionletVolatilityStructureLazyObject {
  constructor(s: StrippedOptionletBase);
}

export declare class StrippedOptionletBase extends LazyObject {
  optionletStrikes(i: Size): Rate[];
  optionletVolatilities(i: Size): Volatility[];
  optionletFixingDates(): Date[];
  optionletFixingTimes(): Time[];
  optionletMaturities(): Size;
  atmOptionletRates(): Rate[];
  dayCounter(): DayCounter;
  calendar(): Calendar;
  settlementDays(): Natural;
  businessDayConvention(): BusinessDayConvention;
  volatilityType(): VolatilityType;
  displacement(): Real;
}

export declare class CmsMarket extends LazyObject {
  constructor(
      swapLengths: Period[], swapIndexes: SwapIndex[], iborIndex: IborIndex,
      bidAskSpreads: Array<Array<Handle<Quote>>>, pricers: CmsCouponPricer[],
      discountingTS: Handle<YieldTermStructure>);
  update(): void;
  reprice(v: Handle<SwaptionVolatilityStructure>, meanReversion: Real): void;
  swapTenors(): Period[];
  swapLengths(): Period[];
  impliedCmsSpreads(): Matrix;
  spreadErrors(): Matrix;
  browse(): Matrix;
  weightedSpreadError(w: Matrix): Real;
  weightedSpotNpvError(w: Matrix): Real;
  weightedFwdNpvError(w: Matrix): Real;
  weightedSpreadErrors(w: Matrix): Real[];
  weightedSpotNpvErrors(w: Matrix): Real[];
  weightedFwdNpvErrors(w: Matrix): Real[];
  performCalculations(): void;
  private weightedMean;
  private weightedMeans;
  private _swapLengths;
  private _swapIndexes;
  private _iborIndex;
  private _bidAskSpreads;
  private _pricers;
  private _discTS;
  private _nExercise;
  private _nSwapIndexes;
  private _swapTenors;
  private _spotFloatLegNPV;
  private _spotFloatLegBPS;
  private _mktBidSpreads;
  private _mktAskSpreads;
  private _mktSpreads;
  private _mdlSpreads;
  private _errSpreads;
  private _mktSpotCmsLegNPV;
  private _mdlSpotCmsLegNPV;
  private _errSpotCmsLegNPV;
  private _mktFwdCmsLegNPV;
  private _mdlFwdCmsLegNPV;
  private _errFwdCmsLegNPV;
  private _spotSwaps;
  private _fwdSwaps;
}

export declare class CmsMarketCalibration {
  constructor(
      volCube: Handle<SwaptionVolatilityStructure>, cmsMarket: CmsMarket,
      weights: Matrix, calibrationType: CmsMarketCalibration.CalibrationType);
  compute1(
      endCriteria: EndCriteria, method: OptimizationMethod, guess: Real[],
      isMeanReversionFixed: boolean): Real[];
  compute2(
      endCriteria: EndCriteria, method: OptimizationMethod, guess: Matrix,
      isMeanReversionFixed: boolean, meanReversionGuess?: Real): Matrix;
  computeParametric(
      endCriteria: EndCriteria, method: OptimizationMethod, guess: Matrix,
      isMeanReversionFixed: boolean, meanReversionGuess?: Real): Matrix;
  error(): Real;
  endCriteria(): EndCriteria.Type;
  static betaTransformInverse(beta: Real): Real;
  static betaTransformDirect(y: Real): Real;
  static reversionTransformInverse(reversion: Real): Real;
  static reversionTransformDirect(y: Real): Real;
  _volCube: Handle<SwaptionVolatilityStructure>;
  _cmsMarket: CmsMarket;
  _weights: Matrix;
  _calibrationType: CmsMarketCalibration.CalibrationType;
  _sparseSabrParameters: Matrix;
  _denseSabrParameters: Matrix;
  _browseCmsMarket: Matrix;
  private _error;
  private _endCriteria;
}
export declare namespace CmsMarketCalibration {
  enum CalibrationType { OnSpread = 0, OnPrice = 1, OnForwardCmsPrice = 2 }
}

export declare class Gaussian1dSwaptionVolatility extends
    SwaptionVolatilityStructure {
  constructor(
      cal: Calendar, bdc: BusinessDayConvention, indexBase: SwapIndex,
      model: Gaussian1dModel, dc: DayCounter,
      swaptionEngine?: Gaussian1dSwaptionEngine);
  maxDate(): Date;
  minStrike(): Real;
  maxStrike(): Real;
  maxSwapTenor(): Period;
  smileSectionImpl1(d: Date, tenor: Period): SmileSection;
  smileSectionImpl2(optionTime: Time, swapLength: Time): SmileSection;
  volatilityImpl1(d: Date, tenor: Period, strike: Rate): Volatility;
  volatilityImpl2(optionTime: Time, swapLength: Time, strike: Rate): Volatility;
  private _indexBase;
  private _model;
  private _engine;
  private _maxSwapTenor;
}

export declare class SpreadedSwaptionVolatility extends
    SwaptionVolatilityStructure {
  constructor(
      baseVol: Handle<SwaptionVolatilityStructure>, spread: Handle<Quote>);
  dayCounter(): DayCounter;
  maxDate(): Date;
  maxTime(): Time;
  referenceDate(): Date;
  calendar(): Calendar;
  settlementDays(): Natural;
  minStrike(): Rate;
  maxStrike(): Rate;
  maxSwapTenor(): Period;
  volatilityType(): VolatilityType;
  smileSectionImpl1(d: Date, swapT: Period): SmileSection;
  smileSectionImpl2(optionTime: Time, swapLength: Time): SmileSection;
  volatilityImpl1(d: Date, p: Period, strike: Rate): Volatility;
  volatilityImpl2(t: Time, l: Time, strike: Rate): Volatility;
  shiftImpl2(optionTime: Time, swapLength: Time): Real;
  private _baseVol;
  private _spread;
}

export declare class ConstantSwaptionVolatility extends
    SwaptionVolatilityStructure {
  csvInit1(
      settlementDays: Natural, cal: Calendar, bdc: BusinessDayConvention,
      volatility: Handle<Quote>, dc: DayCounter, type?: VolatilityType,
      shift?: Real): ConstantSwaptionVolatility;
  csvInit2(
      referenceDate: Date, cal: Calendar, bdc: BusinessDayConvention,
      volatility: Handle<Quote>, dc: DayCounter, type?: VolatilityType,
      shift?: Real): ConstantSwaptionVolatility;
  csvInit3(
      settlementDays: Natural, cal: Calendar, bdc: BusinessDayConvention,
      volatility: Volatility, dc: DayCounter, type?: VolatilityType,
      shift?: Real): ConstantSwaptionVolatility;
  csvInit4(
      referenceDate: Date, cal: Calendar, bdc: BusinessDayConvention,
      volatility: Volatility, dc: DayCounter, type?: VolatilityType,
      shift?: Real): ConstantSwaptionVolatility;
  maxDate(): Date;
  minStrike(): Real;
  maxStrike(): Real;
  maxSwapTenor(): Period;
  volatilityType(): VolatilityType;
  smileSectionImpl1(optionDate: Date, swapTenor: Period): SmileSection;
  smileSectionImpl2(optionTime: Time, swapLength: Time): SmileSection;
  shiftImpl2(optionTime: Time, swapLength: Time): Real;
  volatilityImpl1(optionDate: Date, swapTenor: Period, strike: Rate):
      Volatility;
  volatilityImpl2(optionTime: Time, swapLength: Time, strike: Rate): Volatility;
  private _volatility;
  private _maxSwapTenor;
  private _volatilityType;
  private _shift;
}

export declare class SwaptionVolatilityCube extends SwaptionVolatilityDiscrete {
  svcInit(
      atmVol: Handle<SwaptionVolatilityStructure>, optionTenors: Period[],
      swapTenors: Period[], strikeSpreads: Spread[],
      volSpreads: Array<Array<Handle<Quote>>>, swapIndexBase: SwapIndex,
      shortSwapIndexBase: SwapIndex,
      vegaWeightedSmileFit: boolean): SwaptionVolatilityCube;
  maxDate(): Date;
  minStrike(): Rate;
  maxStrike(): Rate;
  maxSwapTenor(): Period;
  atmStrike1(optionD: Date, swapTenor: Period): Rate;
  atmStrike2(optionTenor: Period, swapTenor: Period): Rate;
  atmVol(): Handle<SwaptionVolatilityStructure>;
  strikeSpreads(): Spread[];
  volSpreads1(): Array<Array<Handle<Quote>>>;
  swapIndexBase(): SwapIndex;
  shortSwapIndexBase(): SwapIndex;
  vegaWeightedSmileFit(): boolean;
  performCalculations(): void;
  volatilityType(): VolatilityType;
  protected registerWithVolatilitySpread(): void;
  protected requiredNumberOfStrikes(): Size;
  protected shiftImpl(optionTime: Time, swapLength: Time): Real;
  protected _atmVol: Handle<SwaptionVolatilityStructure>;
  protected _nStrikes: Size;
  protected _strikeSpreads: Spread[];
  protected _localStrikes: Rate[];
  protected _localSmile: Volatility[];
  protected _volSpreads: Array<Array<Handle<Quote>>>;
  protected _swapIndexBase: SwapIndex;
  protected _shortSwapIndexBase: SwapIndex;
  protected _vegaWeightedSmileFit: boolean;
}

export declare class SwaptionVolCube1x extends SwaptionVolatilityCube {
  constructor(I: Interpolation, S: SmileSection);
  svc1xInit(
      atmVolStructure: Handle<SwaptionVolatilityStructure>,
      optionTenors: Period[], swapTenors: Period[], strikeSpreads: Spread[],
      volSpreads: Array<Array<Handle<Quote>>>, swapIndexBase: SwapIndex,
      shortSwapIndexBase: SwapIndex, vegaWeightedSmileFit: boolean,
      parametersGuess: Array<Array<Handle<Quote>>>, isParameterFixed: boolean[],
      isAtmCalibrated: boolean, endCriteria?: EndCriteria,
      maxErrorTolerance?: Real, optMethod?: OptimizationMethod,
      errorAccept?: Real, useMaxError?: boolean, maxGuesses?: Size,
      backwardFlat?: boolean, cutoffStrike?: Real): SwaptionVolCube1x;
  I: Interpolation;
  S: SmileSection;
  performCalculations(): void;
  smileSectionImpl(optionTime: Time, swapLength: Time): SmileSection;
  marketVolCube1(i: Size): Matrix;
  sparseSabrParameters(): Matrix;
  denseSabrParameters(): Matrix;
  marketVolCube2(): Matrix;
  volCubeAtmCalibrated(): Matrix;
  sabrCalibrationSection(
      marketVolCube: SwaptionVolCube1x.Cube,
      parametersCube: SwaptionVolCube1x.Cube, swapTenor: Period): void;
  recalibration1(beta: Real, swapTenor: Period): void;
  recalibration2(beta: Real[], swapTenor: Period): void;
  recalibration3(swapLengths: Period[], beta: Real[], swapTenor: Period): void;
  updateAfterRecalibration(): void;
  protected registerWithParametersGuess(): void;
  setParameterGuess(): void;
  protected smileSection(
      optionTime: Time, swapLength: Time,
      sabrParametersCube: SwaptionVolCube1x.Cube): SmileSection;
  protected sabrCalibration(marketVolCube: SwaptionVolCube1x.Cube):
      SwaptionVolCube1x.Cube;
  protected fillVolatilityCube(): void;
  protected createSparseSmiles(): void;
  protected spreadVolInterpolation(atmOptionDate: Date, atmSwapTenor: Period):
      Real[];
  requiredNumberOfStrikes(): Size;
  private _marketVolCube;
  private _volCubeAtmCalibrated;
  private _sparseParameters;
  private _denseParameters;
  private _sparseSmiles;
  private _parametersGuessQuotes;
  private _parametersGuess;
  private _isParameterFixed;
  private _isAtmCalibrated;
  private _endCriteria;
  private _maxErrorTolerance;
  private _optMethod;
  private _errorAccept;
  private _useMaxError;
  private _maxGuesses;
  private _backwardFlat;
  private _cutoffStrike;
  private _privateObserver;
}
export declare namespace SwaptionVolCube1x {
  class Cube implements BinaryFunction<Time, Time, Real[]> {
    constructor(
        optionDates: Date[], swapTenors: Period[], optionTimes: Time[],
        swapLengths: Time[], nLayers: Size, extrapolation?: boolean,
        backwardFlat?: boolean);
    from(o: Cube): void;
    setElement(
        IndexOfLayer: Size, IndexOfRow: Size, IndexOfColumn: Size,
        x: Real): void;
    setPoints(x: Matrix[]): void;
    setPoint(
        optionDate: Date, swapTenor: Period, optionTime: Time, swapLength: Time,
        point: Real[]): void;
    setLayer(i: Size, x: Matrix): void;
    expandLayers(
        i: Size, expandOptionTimes: boolean, j: Size,
        expandSwapLengths: boolean): void;
    optionDates(): Date[];
    swapTenors(): Period[];
    optionTimes(): Time[];
    swapLengths(): Time[];
    points(): Matrix[];
    f(optionTime: Time, swapLength: Time): Real[];
    updateInterpolators(): void;
    browse(): Matrix;
    private _optionTimes;
    private _swapLengths;
    private _optionDates;
    private _swapTenors;
    private _nLayers;
    private _points;
    private _transposedPoints;
    private _extrapolation;
    private _backwardFlat;
    private _interpolators;
  }
  class PrivateObserver extends Observer {
    constructor(v: SwaptionVolCube1x);
    update(): void;
    private _v;
  }
}
export declare namespace SwaptionVolCubeSabrModel {
  type Interpolation = SABRInterpolation;
  type SmileSection = SabrSmileSection;
}
export declare class SwaptionVolCube1 extends SwaptionVolCube1x {
  constructor();
}

export declare class SwaptionVolCube2 extends SwaptionVolatilityCube {
  constructor(
      atmVolStructure: Handle<SwaptionVolatilityStructure>,
      optionTenors: Period[], swapTenors: Period[], strikeSpreads: Spread[],
      volSpreads: Array<Array<Handle<Quote>>>, swapIndexBase: SwapIndex,
      shortSwapIndexBase: SwapIndex, vegaWeightedSmileFit: boolean);
  performCalculations(): void;
  volSpreads2(i: Size): Matrix;
  private _volSpreadsInterpolator;
  private _volSpreadsMatrix;
}

export declare class SwaptionVolatilityDiscrete extends
    SwaptionVolatilityStructureLazyObject {
  svdInit1(
      optionTenors: Period[], swapTenors: Period[], settlementDays: Natural,
      cal: Calendar, bdc: BusinessDayConvention,
      dc: DayCounter): SwaptionVolatilityDiscrete;
  svdInit2(
      optionTenors: Period[], swapTenors: Period[], referenceDate: Date,
      cal: Calendar, bdc: BusinessDayConvention,
      dc: DayCounter): SwaptionVolatilityDiscrete;
  svdInit3(
      optionDates: Date[], swapTenors: Period[], referenceDate: Date,
      cal: Calendar, bdc: BusinessDayConvention,
      dc: DayCounter): SwaptionVolatilityDiscrete;
  optionTenors(): Period[];
  optionDates(): Date[];
  optionTimes(): Time[];
  swapTenors(): Period[];
  swapLengths(): Time[];
  update(): void;
  performCalculations(): void;
  optionDateFromTime(optionTime: Time): Date;
  protected _nOptionTenors: Size;
  protected _optionTenors: Period[];
  protected _optionDates: Date[];
  protected _optionTimes: Time[];
  protected _optionDatesAsReal: Real[];
  protected _optionInterpolator: Interpolation;
  protected _nSwapTenors: Size;
  protected _swapTenors: Period[];
  protected _swapLengths: Time[];
  protected _evaluationDate: Date;
  private checkOptionTenors;
  private checkOptionDates;
  private checkSwapTenors;
  private initializeOptionDatesAndTimes;
  private initializeOptionTimes;
  private initializeSwapLengths;
}

export declare class SwaptionVolatilityMatrix extends
    SwaptionVolatilityDiscrete {
  svmInit1(
      calendar: Calendar, bdc: BusinessDayConvention, optionTenors: Period[],
      swapTenors: Period[], vols: Array<Array<Handle<Quote>>>,
      dayCounter: DayCounter, flatExtrapolation?: boolean,
      type?: VolatilityType, shifts?: Real[][]): SwaptionVolatilityMatrix;
  svmInit2(
      referenceDate: Date, calendar: Calendar, bdc: BusinessDayConvention,
      optionTenors: Period[], swapTenors: Period[],
      vols: Array<Array<Handle<Quote>>>, dayCounter: DayCounter,
      flatExtrapolation?: boolean, type?: VolatilityType,
      shifts?: Real[][]): SwaptionVolatilityMatrix;
  svmInit3(
      calendar: Calendar, bdc: BusinessDayConvention, optionTenors: Period[],
      swapTenors: Period[], vols: Matrix, dayCounter: DayCounter,
      flatExtrapolation?: boolean, type?: VolatilityType,
      shifts?: Matrix): SwaptionVolatilityMatrix;
  svmInit4(
      referenceDate: Date, calendar: Calendar, bdc: BusinessDayConvention,
      optionTenors: Period[], swapTenors: Period[], vols: Matrix,
      dayCounter: DayCounter, flatExtrapolation?: boolean,
      type?: VolatilityType, shifts?: Matrix): SwaptionVolatilityMatrix;
  svmInit5(
      today: Date, optionDates: Date[], swapTenors: Period[], vols: Matrix,
      dayCounter: DayCounter, flatExtrapolation?: boolean,
      type?: VolatilityType, shifts?: Matrix): SwaptionVolatilityMatrix;
  performCalculations(): void;
  maxDate(): Date;
  minStrike(): Rate;
  maxStrike(): Rate;
  maxSwapTenor(): Period;
  locate1(optionDate: Date, swapTenor: Period): [Size, Size];
  locate2(optionTime: Time, swapLength: Time): [Size, Size];
  volatilityType(): VolatilityType;
  smileSectionImpl(optionTime: Time, swapLength: Time): SmileSection;
  volatilityImpl(optionTime: Time, swapLength: Time, strike: Rate): Volatility;
  shiftImpl(optionTime: Time, swapLength: Time): Real;
  private checkInputs;
  private registerWithMarketData;
  private _volHandles;
  private _shiftValues;
  private _volatilities;
  private _shifts;
  private _interpolation;
  private _interpolationShifts;
  private _volatilityType;
}

export declare class SwaptionVolatilityStructure extends
    VolatilityTermStructure {
  volatility1(
      optionTenor: Period, swapTenor: Period, strike: Rate,
      extrapolate?: boolean): Volatility;
  volatility2(
      optionDate: Date, swapTenor: Period, strike: Rate,
      extrapolate?: boolean): Volatility;
  volatility3(
      optionTime: Time, swapTenor: Period, strike: Rate,
      extrapolate?: boolean): Volatility;
  volatility4(
      optionTenor: Period, swapLength: Time, strike: Rate,
      extrapolate?: boolean): Volatility;
  volatility5(
      optionDate: Date, swapLength: Time, strike: Rate,
      extrapolate?: boolean): Volatility;
  volatility6(
      optionTime: Time, swapLength: Time, strike: Rate,
      extrapolate?: boolean): Volatility;
  blackVariance1(
      optionTenor: Period, swapTenor: Period, strike: Rate,
      extrapolate?: boolean): Real;
  blackVariance2(
      optionDate: Date, swapTenor: Period, strike: Rate,
      extrapolate?: boolean): Real;
  blackVariance3(
      optionTime: Time, swapTenor: Period, strike: Rate,
      extrapolate?: boolean): Real;
  blackVariance4(
      optionTenor: Period, swapLength: Time, strike: Rate,
      extrapolate?: boolean): Real;
  blackVariance5(
      optionDate: Date, swapLength: Time, strike: Rate,
      extrapolate?: boolean): Real;
  blackVariance6(
      optionTime: Time, swapLength: Time, strike: Rate,
      extrapolate?: boolean): Real;
  shift1(optionTenor: Period, swapTenor: Period, extrapolate?: boolean): Real;
  shift2(optionDate: Date, swapTenor: Period, extrapolate?: boolean): Real;
  shift3(optionTime: Time, swapTenor: Period, extrapolate?: boolean): Real;
  shift4(optionTenor: Period, swapLength: Time, extrapolate?: boolean): Real;
  shift5(optionDate: Date, swapLength: Time, extrapolate?: boolean): Real;
  shift6(optionTime: Time, swapLength: Time, extrapolate?: boolean): Real;
  smileSection1(optionTenor: Period, swapTenor: Period, extrapolate?: boolean):
      SmileSection;
  smileSection2(optionDate: Date, swapTenor: Period, extrapolate?: boolean):
      SmileSection;
  smileSection3(optionTime: Time, swapTenor: Period, extrapolate?: boolean):
      SmileSection;
  smileSection4(optionTenor: Period, swapLength: Time, extrapolate?: boolean):
      SmileSection;
  smileSection5(optionDate: Date, swapLength: Time, extrapolate?: boolean):
      SmileSection;
  smileSection6(optionTime: Time, swapLength: Time, extrapolate?: boolean):
      SmileSection;
  maxSwapTenor(): Period;
  maxSwapLength(): Time;
  volatilityType(): VolatilityType;
  swapLength1(swapTenor: Period): Time;
  swapLength2(start: Date, end: Date): Time;
  smileSectionImpl1(optionDate: Date, swapTenor: Period): SmileSection;
  smileSectionImpl2(optionTime: Time, swapLength: Time): SmileSection;
  volatilityImpl1(optionDate: Date, swapTenor: Period, strike: Rate):
      Volatility;
  volatilityImpl2(optionTime: Time, swapLength: Time, strike: Rate): Volatility;
  shiftImpl1(optionDate: Date, swapTenor: Period): Real;
  shiftImpl2(optionTime: Time, swapLength: Time): Real;
  checkSwapTenor1(swapTenor: Period, extrapolate: boolean): void;
  checkSwapTenor2(swapLength: Time, extrapolate: boolean): void;
}

export declare class BlackCalibrationHelper extends
    LazyObjectCalibrationHelperBase {
  init(
      volatility: Handle<Quote>, termStructure: Handle<YieldTermStructure>,
      calibrationErrorType?: BlackCalibrationHelper.CalibrationErrorType,
      type?: VolatilityType, shift?: Real): CalibrationHelper;
  performCalculations(): void;
  volatility(): Handle<Quote>;
  volatilityType(): VolatilityType;
  marketValue(): Real;
  modelValue(): Real;
  calibrationError(): Real;
  addTimesTo(times: Time[]): void;
  impliedVolatility(
      targetValue: Real, accuracy: Real, maxEvaluations: Size,
      minVol: Volatility, maxVol: Volatility): Volatility;
  blackPrice(volatility: Volatility): Real;
  setPricingEngine(engine: PricingEngine): void;
  protected _marketValue: Real;
  protected _volatility: Handle<Quote>;
  protected _termStructure: Handle<YieldTermStructure>;
  protected _engine: PricingEngine;
  protected _volatilityType: VolatilityType;
  protected _shift: Real;
  private _calibrationErrorType;
}
export declare namespace BlackCalibrationHelper {
  enum CalibrationErrorType {
    RelativePriceError = 0,
    PriceError = 1,
    ImpliedVolError = 2
  }
  class ImpliedVolatilityHelper implements UnaryFunction<Volatility, Real> {
    constructor(helper: CalibrationHelper, value: Real);
    f(x: Volatility): Real;
    private _helper;
    private _value;
  }
}
export declare type CalibrationHelper = BlackCalibrationHelper;

export declare class CalibrationHelperBase {
  calibrationError(): Real;
}

export declare class AffineModel extends Observable {
  discount(t: Time): DiscountFactor;
  discountBond1(now: Time, maturity: Time, factors: Real[]): Real;
  discountBondOption1(
      type: Option.Type, strike: Real, maturity: Time,
      bondMaturity: Time): Real;
  discountBondOption2(
      type: Option.Type, strike: Real, maturity: Time, bondStart: Time,
      bondMaturity: Time): Real;
}
export declare class TermStructureConsistentModel extends Observable {
  tcmInit(termStructure: Handle<YieldTermStructure>):
      TermStructureConsistentModel;
  termStructure(): Handle<YieldTermStructure>;
  _termStructure: Handle<YieldTermStructure>;
}
export declare class CalibratedModel extends ObserverObservable {
  cmInit(nArguments: Size): CalibratedModel;
  update(): void;
  calibrate1(
      instruments: CalibrationHelperBase[], method: OptimizationMethod,
      endCriteria: EndCriteria, additionalConstraint?: Constraint,
      weights?: Real[], fixParameters?: boolean[]): void;
  calibrate2(
      instruments: BlackCalibrationHelper[], method: OptimizationMethod,
      endCriteria: EndCriteria, additionalConstraint?: Constraint,
      weights?: Real[], fixParameters?: boolean[]): void;
  value1(params: Real[], instruments: CalibrationHelperBase[]): Real;
  value2(params: Real[], instruments: BlackCalibrationHelper[]): Real;
  constraint(): Constraint;
  endCriteria(): EndCriteria.Type;
  problemValues(): Real[];
  params(): Real[];
  setParams(params: Real[]): void;
  functionEvaluation(): Integer;
  generateArguments(): void;
  _arguments: Parameter[];
  _constraint: Constraint;
  _shortRateEndCriteria: EndCriteria.Type;
  _problemValues: Real[];
  _functionEvaluation: Integer;
}
export declare class ShortRateModel extends CalibratedModel {
  srmInit(nArguments: Size): ShortRateModel;
  tree(grid: TimeGrid): Lattice;
}
export declare namespace CalibratedModel {
  class CalibrationFunction extends CostFunction {
    constructor(
        model: CalibratedModel, h: CalibrationHelper[], weights: Real[],
        projection: Projection);
  }
  class PrivateConstraint extends Constraint {
    constructor(args: Parameter[]);
  }
  namespace PrivateConstraint {
    class Impl extends Constraint.Impl {
      constructor(args: Parameter[]);
      test(params: Real[]): boolean;
      upperBound(params: Real[]): Real[];
      lowerBound(params: Real[]): Real[];
      private _arguments;
    }
  }
}

export declare class Parameter implements UnaryFunction<Time, Real> {
  init1(): Parameter;
  init2(size: Size, impl: Parameter.Impl, constraint: Constraint): Parameter;
  params(): Real[];
  setParam(i: Size, x: Real): void;
  testParams(params: Real[]): boolean;
  size(): Size;
  f(t: Time): Real;
  implementation(): Parameter.Impl;
  constraint(): Constraint;
  protected _impl: Parameter.Impl;
  protected _params: Real[];
  protected _constraint: Constraint;
}
export declare namespace Parameter {
  class Impl {
    constructor(...args: any[]);
    value(params: Real[], t: Time): Real;
  }
}
export declare class ConstantParameter extends Parameter {
  cpInit1(constraint: Constraint): ConstantParameter;
  cpInit2(value: Real, constraint: Constraint): ConstantParameter;
}
export declare namespace ConstantParameter {
  class Impl extends Parameter.Impl {
    value(params: Real[], t: Time): Real;
  }
}
export declare class NullParameter extends Parameter {
  constructor();
}
export declare namespace NullParameter {
  class Impl extends Parameter.Impl {
    value(x: Real[], t: Time): Real;
  }
}
export declare class PiecewiseConstantParameter extends Parameter {
  constructor(times: Time[], constraint?: Constraint);
}
export declare namespace PiecewiseConstantParameter {
  class Impl extends Parameter.Impl {
    constructor(times: Time[]);
    value(params: Real[], t: Time): Real;
    private _times;
  }
}
export declare class TermStructureFittingParameter extends Parameter {
  tfpInit1(impl: Parameter.Impl): TermStructureFittingParameter;
  tfpInit2(term: Handle<YieldTermStructure>): TermStructureFittingParameter;
}
export declare namespace TermStructureFittingParameter {
  class NumericalImpl extends Parameter.Impl {
    constructor(termStructure: Handle<YieldTermStructure>);
    set(t: Time, x: Real): void;
    change(x: Real): void;
    reset(): void;
    value(x: Real[], t: Time): Real;
    termStructure(): Handle<YieldTermStructure>;
    private _times;
    private _values;
    private _termStructure;
  }
}

export declare class ConstantEstimator extends VolatilityCompositor {
  constructor(size: Size);
  calculate1(volatilitySeries: TimeSeries<Volatility>): TimeSeries<Volatility>;
  calibrate(v: TimeSeries<Volatility>): void;
  private _size;
}

export declare class Garch11 extends VolatilityCompositor {
  init1(a: Real, b: Real, vl: Real): Garch11;
  init2(qs: TimeSeries<Volatility>, mode?: Garch11.Mode): Garch11;
  alpha(): Real;
  beta(): Real;
  omega(): Real;
  ltVol(): Real;
  logLikelihood(): Real;
  mode(): Garch11.Mode;
  calculate1(quoteSeries: TimeSeries<Volatility>): TimeSeries<Volatility>;
  calibrate1(quoteSeries: TimeSeries<Volatility>): void;
  static calculate2(
      quoteSeries: TimeSeries<Volatility>, alpha: Real, beta: Real,
      omega: Real): TimeSeries<Volatility>;
  calibrate2(
      quoteSeries: TimeSeries<Volatility>, method: OptimizationMethod,
      endCriteria: EndCriteria): void;
  calibrate3(
      quoteSeries: TimeSeries<Volatility>, method: OptimizationMethod,
      endCriteria: EndCriteria, initialGuess: Real[]): void;
  calibrate4(forward: Real[], begin: Size, end: Size): void;
  calibrate5(
      forward: Real[], begin: Size, end: Size, method: OptimizationMethod,
      endCriteria: EndCriteria): void;
  calibrate6(
      forward: Real[], begin: Size, end: Size, method: OptimizationMethod,
      endCriteria: EndCriteria, initialGuess: Real[]): void;
  forecast(r: Real, sigma2: Real): Real;
  static to_r2(input: Real[], begin: Size, end: Size, r2: Volatility[]): Real;
  static calibrate1_r2(
      mode: Garch11.Mode, r2: Volatility[], mean_r2: Real,
      byref: Garch11.byRef): Problem;
  static calibrate2_r2(
      mode: Garch11.Mode, r2: Volatility[], mean_r2: Real,
      method: OptimizationMethod, endCriteria: EndCriteria,
      byref: Garch11.byRef): Problem;
  static calibrate3_r2(
      r2: Volatility[], mean_r2: Real, method: OptimizationMethod,
      endCriteria: EndCriteria, initialGuess: Real[],
      byref: Garch11.byRef): Problem;
  static calibrate4_r2(
      r2: Volatility[], method: OptimizationMethod, endCriteria: EndCriteria,
      initialGuess: Real[], byref: Garch11.byRef): Problem;
  static calibrate5_r2(
      r2: Volatility[], mean_r2: Real, method: OptimizationMethod,
      constraints: Constraint, endCriteria: EndCriteria, initialGuess: Real[],
      byref: Garch11.byRef): Problem;
  static calibrate6_r2(
      r2: Volatility[], method: OptimizationMethod, constraints: Constraint,
      endCriteria: EndCriteria, initialGuess: Real[],
      byref: Garch11.byRef): Problem;
  static costFunction1(
      input: Real[], begin: Size, end: Size, alpha: Real, beta: Real,
      omega: Real): Real;
  private costFunction2;
  private _alpha;
  private _beta;
  private _gamma;
  private _vl;
  private _logLikelihood;
  private _mode;
}
export declare class Garch11Constraint extends Constraint {
  constructor(gammaLower: Real, gammaUpper: Real);
}
export declare class Garch11CostFunction extends CostFunction {
  constructor(r2: Volatility[]);
  value(x: Real[]): Real;
  values(x: Real[]): Real[];
  gradient(grad: Real[], x: Real[]): void;
  valueAndGradient(grad: Real[], x: Real[]): Real;
  private _r2;
}
export declare class FitAcfProblem extends LeastSquareProblem {
  constructor(A2: Real, acf: Real[], idx: Size[]);
  size(): Size;
  targetAndValue(x: Real[], target: Real[], fct2fit: Real[]): void;
  targetValueAndGradient(
      x: Real[], grad_fct2fit: Matrix, target: Real[], fct2fit: Real[]): void;
  private _A2;
  private _acf;
  private _idx;
}
export declare class FitAcfConstraint extends Constraint {
  constructor(gammaLower: Real, gammaUpper: Real);
}
export declare function initialGuess1(
    acf: Real[], mean_r2: Real, byref: Garch11.byRef): Real;
export declare function initialGuess2(
    acf: Real[], mean_r2: Real, byref: Garch11.byRef): Real;
export declare namespace Garch11 {
  enum Mode {
    MomentMatchingGuess = 0,
    GammaGuess = 1,
    BestOfTwo = 2,
    DoubleOptimization = 3
  }
  interface byRef {
    alpha: Real;
    beta: Real;
    omega: Real;
  }
}
export declare namespace Garch11Constraint {
  class Impl extends Constraint.Impl {
    constructor(gammaLower: Real, gammaUpper: Real);
    test(x: Real[]): boolean;
    _gammaLower: Real;
    _gammaUpper: Real;
  }
}
export declare namespace FitAcfConstraint {
  class Impl extends Constraint.Impl {
    constructor(gammaLower: Real, gammaUpper: Real);
    test(x: Real[]): boolean;
    _gammaLower: Real;
    _gammaUpper: Real;
  }
}

export declare class GarmanKlassAbstract extends
    LocalVolatilityEstimator<IntervalPrice> {
  constructor(y: Real);
  calculate1(quoteSeries: TimeSeries<IntervalPrice>): TimeSeries<number>;
  calculatePoint(p: IntervalPrice): Real;
  protected _yearFraction: Real;
}
export declare class GarmanKlassSimpleSigma extends GarmanKlassAbstract {
  constructor(y: Real);
  calculatePoint(p: IntervalPrice): Real;
}
export declare class GarmanKlassOpenClose {
  constructor(
      t: GarmanKlassAbstract, y: Real, marketOpenFraction: Real, a: Real);
  calculate1(quoteSeries: TimeSeries<IntervalPrice>): TimeSeries<number>;
  T: GarmanKlassAbstract;
  protected _yearFraction: Real;
  protected _f: Real;
  protected _a: Real;
}
export declare class GarmanKlassSigma1 extends GarmanKlassOpenClose {
  constructor(y: Real, marketOpenFraction: Real);
}
export declare class ParkinsonSigma extends GarmanKlassAbstract {
  constructor(y: Real);
  calculatePoint(p: IntervalPrice): Real;
}
export declare class GarmanKlassSigma3 extends GarmanKlassOpenClose {
  constructor(y: Real, marketOpenFraction: Real);
}
export declare class GarmanKlassSigma4 extends GarmanKlassAbstract {
  constructor(y: Real);
  calculatePoint(p: IntervalPrice): Real;
}
export declare class GarmanKlassSigma5 extends GarmanKlassAbstract {
  constructor(y: Real);
  calculatePoint(p: IntervalPrice): Real;
}
export declare class GarmanKlassSigma6 extends GarmanKlassOpenClose {
  constructor(y: Real, marketOpenFraction: Real);
}

export declare class SimpleLocalEstimator extends
    LocalVolatilityEstimator<Real> {
  constructor(y: Real);
  calculate1(quoteSeries: TimeSeries<Real>): TimeSeries<number>;
  private _yearFraction;
}

export declare class BatesModel extends HestonModel {
  constructor(process: BatesProcess);
  nu(): Real;
  delta(): Real;
  lambda(): Real;
  generateArguments(): void;
}
export declare class BatesDetJumpModel extends BatesModel {
  constructor(process: BatesProcess, kappaLambda?: Real, thetaLambda?: Real);
  kappaLambda(): Real;
  thetaLambda(): Real;
}
export declare class BatesDoubleExpModel extends HestonModel {
  constructor(
      process: HestonProcess, lambda?: Real, nuUp?: Real, nuDown?: Real,
      p?: Real);
  p(): Real;
  nuDown(): Real;
  nuUp(): Real;
  lambda(): Real;
}
export declare class BatesDoubleExpDetJumpModel extends BatesDoubleExpModel {
  constructor(
      process: HestonProcess, lambda?: Real, nuUp?: Real, nuDown?: Real,
      p?: Real, kappaLambda?: Real, thetaLambda?: Real);
  kappaLambda(): Real;
  thetaLambda(): Real;
}

export declare class HestonModel extends CalibratedModel {
  constructor(process: HestonProcess);
  generateArguments(): void;
  theta(): Real;
  kappa(): Real;
  sigma(): Real;
  rho(): Real;
  v0(): Real;
  process(): HestonProcess;
  protected _process: HestonProcess;
}
export declare namespace HestonModel {
  class FellerConstraint extends Constraint {
    constructor();
  }
  namespace FellerConstraint {
    class Impl extends Constraint.Impl {
      test(params: Real[]): boolean;
    }
  }
}

export declare class HestonModelHelper extends BlackCalibrationHelper {
  hmhInit1(
      maturity: Period, calendar: Calendar, s0: Real, strikePrice: Real,
      volatility: Handle<Quote>, riskFreeRate: Handle<YieldTermStructure>,
      dividendYield: Handle<YieldTermStructure>,
      errorType?: BlackCalibrationHelper.CalibrationErrorType):
      HestonModelHelper;
  hmhInit2(
      maturity: Period, calendar: Calendar, s0: Handle<Quote>,
      strikePrice: Real, volatility: Handle<Quote>,
      riskFreeRate: Handle<YieldTermStructure>,
      dividendYield: Handle<YieldTermStructure>,
      errorType?: BlackCalibrationHelper.CalibrationErrorType):
      HestonModelHelper;
  addTimesTo(): void;
  performCalculations(): void;
  modelValue(): Real;
  blackPrice(volatility: Real): Real;
  maturity(): Time;
  private _maturity;
  private _calendar;
  private _s0;
  private _strikePrice;
  private _dividendYield;
  private _exerciseDate;
  private _tau;
  private _type;
  private _option;
}

export declare class PiecewiseTimeDependentHestonModel extends CalibratedModel {
  constructor(
      riskFreeRate: Handle<YieldTermStructure>,
      dividendYield: Handle<YieldTermStructure>, s0: Handle<Quote>, v0: Real,
      theta: Parameter, kappa: Parameter, sigma: Parameter, rho: Parameter,
      timeGrid: TimeGrid);
  theta(t: Time): Real;
  kappa(t: Time): Real;
  sigma(t: Time): Real;
  rho(t: Time): Real;
  v0(): Real;
  s0(): Real;
  timeGrid(): TimeGrid;
  dividendYield(): Handle<YieldTermStructure>;
  riskFreeRate(): Handle<YieldTermStructure>;
  protected _s0: Handle<Quote>;
  protected _riskFreeRate: Handle<YieldTermStructure>;
  protected _dividendYield: Handle<YieldTermStructure>;
  protected _timeGrid: TimeGrid;
}

export declare class GJRGARCHModel extends CalibratedModel {
  constructor(process: GJRGARCHProcess);
  omega(): Real;
  alpha(): Real;
  beta(): Real;
  gamma(): Real;
  lambda(): Real;
  v0(): Real;
  process(): GJRGARCHProcess;
  generateArguments(): void;
  protected _process: GJRGARCHProcess;
}
export declare namespace GJRGARCHModel {
  class VolatilityConstraint extends Constraint {
    constructor();
  }
  namespace VolatilityConstraint {
    class Impl extends Constraint.Impl {
      test(params: Real[]): boolean;
    }
  }
}

export declare class OneFactorAffineModel extends OneFactorModelAffineModel {
  ofamInit(nArguments: Size): OneFactorAffineModel;
  discountBond1(now: Time, maturity: Time, factors: Real[]): Real;
  discountBond2(now: Time, maturity: Time, rate: Rate): Real;
  discount(t: Time): DiscountFactor;
  A(t: Time, T: Time): Real;
  B(t: Time, T: Time): Real;
}

export declare class OneFactorModel extends ShortRateModel {
  ofmInit(nArguments: Size): OneFactorModel;
  dynamics(): OneFactorModel.ShortRateDynamics;
  tree(grid: TimeGrid): Lattice;
}
export declare namespace OneFactorModel {
  class ShortRateDynamics {
    constructor(process: StochasticProcess1D);
    variable(t: Time, r: Rate): Real;
    shortRate(t: Time, variable: Real): Rate;
    process(): StochasticProcess1D;
    private _process;
  }
  class ShortRateTree extends TreeLattice1D<ShortRateTree> {
    srtInit1(
        tree: TrinomialTree, dynamics: ShortRateDynamics,
        timeGrid: TimeGrid): ShortRateTree;
    srtInit2(
        tree: TrinomialTree, dynamics: ShortRateDynamics,
        theta: TermStructureFittingParameter.NumericalImpl,
        timeGrid: TimeGrid): ShortRateTree;
    size(i: Size): Size;
    discount(i: Size, index: Size): DiscountFactor;
    underlying(i: Size, index: Size): Real;
    descendant(i: Size, index: Size, branch: Size): Size;
    probability(i: Size, index: Size, branch: Size): Real;
    setSpread(spread: Spread): void;
    private _tree;
    private _dynamics;
    private _spread;
  }
  namespace ShortRateTree {
    class Helper implements UnaryFunction<Real, Real> {
      constructor(
          i: Size, discountBondPrice: Real,
          theta: TermStructureFittingParameter.NumericalImpl,
          tree: ShortRateTree);
      f(theta: Real): Real;
      private _size;
      private _i;
      private _statePrices;
      private _discountBondPrice;
      private _theta;
      private _tree;
    }
  }
}

export declare class TwoFactorModel extends ShortRateModel {
  tfmInit(nParams: Size): TwoFactorModel;
  dynamics(): TwoFactorModel.ShortRateDynamics;
  tree(grid: TimeGrid): Lattice;
}
export declare namespace TwoFactorModel {
  class ShortRateDynamics {
    constructor(
        xProcess: StochasticProcess1D, yProcess: StochasticProcess1D,
        correlation: Real);
    shortRate(t: Time, x: Real, y: Real): Rate;
    xProcess(): StochasticProcess1D;
    yProcess(): StochasticProcess1D;
    correlation(): Real;
    process(): StochasticProcess;
    private _xProcess;
    private _yProcess;
    private _correlation;
  }
  class ShortRateTree extends TreeLattice2D<ShortRateTree> {
    srtInit(
        tree1: TrinomialTree, tree2: TrinomialTree,
        dynamics: ShortRateDynamics): ShortRateTree;
    discount(i: Size, index: Size): DiscountFactor;
    private _dynamics;
  }
}

export declare class CapHelper extends BlackCalibrationHelper {
  constructor(
      length: Period, volatility: Handle<Quote>, index: IborIndex,
      fixedLegFrequency: Frequency, fixedLegDayCounter: DayCounter,
      includeFirstSwaplet: boolean, termStructure: Handle<YieldTermStructure>,
      errorType?: BlackCalibrationHelper.CalibrationErrorType);
  addTimesTo(times: Time[]): void;
  modelValue(): Real;
  blackPrice(sigma: Volatility): Real;
  performCalculations(): void;
  private _cap;
  private _length;
  private _index;
  private _fixedLegFrequency;
  private _fixedLegDayCounter;
  private _includeFirstSwaplet;
}

export declare class SwaptionHelper extends BlackCalibrationHelper {
  shInit1(
      maturity: Period, length: Period, volatility: Handle<Quote>,
      index: IborIndex, fixedLegTenor: Period, fixedLegDayCounter: DayCounter,
      floatingLegDayCounter: DayCounter,
      termStructure: Handle<YieldTermStructure>,
      errorType?: BlackCalibrationHelper.CalibrationErrorType, strike?: Real,
      nominal?: Real, type?: VolatilityType, shift?: Real): SwaptionHelper;
  shInit2(
      exerciseDate: Date, length: Period, volatility: Handle<Quote>,
      index: IborIndex, fixedLegTenor: Period, fixedLegDayCounter: DayCounter,
      floatingLegDayCounter: DayCounter,
      termStructure: Handle<YieldTermStructure>,
      errorType?: BlackCalibrationHelper.CalibrationErrorType, strike?: Real,
      nominal?: Real, type?: VolatilityType, shift?: Real): SwaptionHelper;
  shInit3(
      exerciseDate: Date, endDate: Date, volatility: Handle<Quote>,
      index: IborIndex, fixedLegTenor: Period, fixedLegDayCounter: DayCounter,
      floatingLegDayCounter: DayCounter,
      termStructure: Handle<YieldTermStructure>,
      errorType?: BlackCalibrationHelper.CalibrationErrorType, strike?: Real,
      nominal?: Real, type?: VolatilityType, shift?: Real): SwaptionHelper;
  addTimesTo(times: Time[]): void;
  modelValue(): Real;
  blackPrice(sigma: Volatility): Real;
  underlyingSwap(): VanillaSwap;
  swaption(): Swaption;
  performCalculations(): void;
  private _exerciseDate;
  private _endDate;
  private _maturity;
  private _length;
  private _fixedLegTenor;
  private _index;
  private _fixedLegDayCounter;
  private _floatingLegDayCounter;
  private _strike;
  private _nominal;
  private _exerciseRate;
  private _swap;
  private _swaption;
}

export declare class BlackKarasinski extends
    OneFactorModelTermStructureConsistentModel {
  constructor(
      termStructure: Handle<YieldTermStructure>, a?: Real, sigma?: Real);
  dynamics(): OneFactorModel.ShortRateDynamics;
  tree(grid: TimeGrid): Lattice;
  a(): Real;
  sigma(): Real;
  private _a;
  private _sigma;
}
export declare namespace BlackKarasinski {
  class Dynamics extends OneFactorModel.ShortRateDynamics {
    constructor(fitting: Parameter, alpha: Real, sigma: Real);
    variable(t: Time, r: Rate): Real;
    shortRate(t: Time, x: Real): Real;
    private _fitting;
  }
  class Helper implements UnaryFunction<Real, Real> {
    constructor(
        i: Size, xMin: Real, dx: Real, discountBondPrice: Real,
        tree: OneFactorModel.ShortRateTree);
    f(theta: Real): Real;
    private _size;
    private _dt;
    private _xMin;
    private _dx;
    private _statePrices;
    private _discountBondPrice;
  }
}

export declare class CoxIngersollRoss extends OneFactorAffineModel {
  cisrInit(
      r0?: Real, theta?: Real, k?: Real, sigma?: Real,
      withFellerConstraint?: boolean): CoxIngersollRoss;
  discountBondOption1(type: Option.Type, strike: Real, t: Time, s: Time): Real;
  dynamics(): OneFactorModel.ShortRateDynamics;
  tree(grid: TimeGrid): Lattice;
  A(t: Time, T: Time): Real;
  B(t: Time, T: Time): Real;
  theta(): Real;
  k(): Real;
  sigma(): Real;
  x0(): Real;
  _theta: Parameter;
  _k: Parameter;
  _sigma: Parameter;
  _r0: Parameter;
}
export declare namespace CoxIngersollRoss {
  class HelperProcess extends StochasticProcess1D {
    constructor(theta: Real, k: Real, sigma: Real, y0: Real);
    x0(): Real;
    drfit2(t: Time, y: Real): Real;
    diffusion2(t: Time, x: Real): Real;
    private _y0;
    private _theta;
    private _k;
    private _sigma;
  }
  class Dynamics extends OneFactorModel.ShortRateDynamics {
    constructor(theta: Real, k: Real, sigma: Real, x0: Real);
    variable(t: Time, r: Rate): Real;
    shortRate(t: Time, y: Real): Real;
  }
  class VolatilityConstraint extends Constraint {
    constructor(k: Real, theta: Real);
  }
  namespace VolatilityConstraint {
    class Impl extends Constraint.Impl {
      constructor(k: Real, theta: Real);
      test(params: Real[]): boolean;
      _k: Real;
      _theta: Real;
    }
  }
}

export declare class ExtendedCoxIngersollRoss extends
    CoxIngersollRossTermStructureConsistentModel {
  constructor(
      termStructure: Handle<YieldTermStructure>, theta?: Real, k?: Real,
      sigma?: Real, x0?: Real, withFellerConstraint?: boolean);
  tree(grid: TimeGrid): Lattice;
  dynamics(): OneFactorModel.ShortRateDynamics;
  discountBondOption1(type: Option.Type, strike: Real, t: Time, s: Time): Real;
  generateArguments(): void;
  A(t: Time, s: Time): Real;
  private _phi;
}
export declare namespace ExtendedCoxIngersollRoss {
  class Dynamics extends CoxIngersollRoss.Dynamics {
    constructor(phi: Parameter, theta: Real, k: Real, sigma: Real, x0: Real);
    variable(t: Time, r: Rate): Real;
    shortRate(t: Time, y: Real): Real;
    private _phi;
  }
  class FittingParameter extends TermStructureFittingParameter {
    constructor(
        termStructure: Handle<YieldTermStructure>, theta: Real, k: Real,
        sigma: Real, x0: Real);
  }
  namespace FittingParameter {
    class Impl extends Parameter.Impl {
      constructor(
          termStructure: Handle<YieldTermStructure>, theta: Real, k: Real,
          sigma: Real, x0: Real);
      value(x: Real[], t: Time): Real;
      private _termStructure;
      private _theta;
      private _k;
      private _sigma;
      private _x0;
    }
  }
}

export declare class Gaussian1dModel extends
    TermStructureConsistentModelLazyObject {
  g1dmInit(yieldTermStructure: Handle<YieldTermStructure>): Gaussian1dModel;
  stateProcess(): StochasticProcess1D;
  numeraire1(t: Time, y?: Real, yts?: Handle<YieldTermStructure>): Real;
  zerobond1(T: Time, t?: Time, y?: Real, yts?: Handle<YieldTermStructure>):
      Real;
  numeraire2(referenceDate: Date, y?: Real, yts?: Handle<YieldTermStructure>):
      Real;
  zerobond2(
      maturity: Date, referenceDate?: Date, y?: Real,
      yts?: Handle<YieldTermStructure>): Real;
  zerobondOption(
      type: Option.Type, expiry: Date, valueDate: Date, maturity: Date,
      strike: Rate, referenceDate?: Date, y?: Real,
      yts?: Handle<YieldTermStructure>, yStdDevs?: Real, yGridPoints?: Size,
      extrapolatePayoff?: boolean, flatPayoffExtrapolation?: boolean): Real;
  forwardRate(
      fixing: Date, referenceDate?: Date, y?: Real, iborIdx?: IborIndex): Real;
  swapRate(
      fixing: Date, tenor: Period, referenceDate?: Date, y?: Real,
      swapIdx?: SwapIndex): Real;
  swapAnnuity(
      fixing: Date, tenor: Period, referenceDate?: Date, y?: Real,
      swapIdx?: SwapIndex): Real;
  static gaussianPolynomialIntegral(
      a: Real, b: Real, c: Real, d: Real, e: Real, y0: Real, y1: Real): Real;
  static gaussianShiftedPolynomialIntegral(
      a: Real, b: Real, c: Real, d: Real, e: Real, h: Real, x0: Real,
      x1: Real): Real;
  yGrid(stdDevs: Real, gridPoints: Size, T?: Real, t?: Real, y?: Real): Real[];
  numeraireImpl(t: Time, y: Real, yts: Handle<YieldTermStructure>): Real;
  zerobondImpl(T: Time, t: Time, y: Real, yts: Handle<YieldTermStructure>):
      Real;
  performCalculations(): void;
  generateArguments(): void;
  underlyingSwap(index: SwapIndex, expiry: Date, tenor: Period): VanillaSwap;
  _swapCache: Map<Gaussian1dModel.CachedSwapKey, VanillaSwap>;
  _stateProcess: StochasticProcess1D;
  _evaluationDate: Date;
  _enforcesTodaysHistoricFixings: boolean;
}
export declare namespace Gaussian1dModel {
  class CachedSwapKey {
    constructor(index: SwapIndex, fixing: Date, tenor: Period);
    index: SwapIndex;
    fixing: Date;
    tenor: Period;
    equal(o: CachedSwapKey): boolean;
  }
  class CachedSwapKeyHasher {}
}

export declare class Gsr extends Gaussian1dModelCalibratedModel {
  gsrInit1(
      termStructure: Handle<YieldTermStructure>, volstepdates: Date[],
      volatilities: Real[], reversion: Real, T?: Real): Gsr;
  gsrInit2(
      termStructure: Handle<YieldTermStructure>, volstepdates: Date[],
      volatilities: Real[], reversions: Real[], T?: Real): Gsr;
  gsrInit3(
      termStructure: Handle<YieldTermStructure>, volstepdates: Date[],
      volatilities: Array<Handle<Quote>>, reversion: Handle<Quote>,
      T?: Real): Gsr;
  gsrInit4(
      termStructure: Handle<YieldTermStructure>, volstepdates: Date[],
      volatilities: Array<Handle<Quote>>, reversions: Array<Handle<Quote>>,
      T?: Real): Gsr;
  numeraireTime1(): Real;
  numeraireTime2(T: Real): void;
  reversion(): Real[];
  volatility(): Real[];
  FixedReversions(): boolean[];
  FixedVolatilities(): boolean[];
  MoveVolatility(i: Size): boolean[];
  MoveReversion(i: Size): boolean[];
  calibrateVolatilitiesIterative(
      helpers: CalibrationHelper[], method: OptimizationMethod,
      endCriteria: EndCriteria, constraint?: Constraint,
      weights?: Real[]): void;
  calibrateReversionsIterative(
      helpers: CalibrationHelper[], method: OptimizationMethod,
      endCriteria: EndCriteria, constraint?: Constraint,
      weights?: Real[]): void;
  numeraireImpl(t: Time, y: Real, yts: Handle<YieldTermStructure>): Real;
  zerobondImpl(T: Time, t: Time, y: Real, yts: Handle<YieldTermStructure>):
      Real;
  generateArguments(): void;
  update(): void;
  performCalculations(): void;
  updateTimes(): void;
  updateVolatility(): void;
  updateReversion(): void;
  initialize(T: Real): void;
  private _reversion;
  private _sigma;
  private _volatilities;
  private _reversions;
  private _volstepdates;
  private _volsteptimes;
  private _volsteptimesArray;
  private _volatilityObserver;
  private _reversionObserver;
}
export declare namespace Gsr {
  class VolatilityObserver extends Observer {
    constructor(p: Gsr);
    update(): void;
    _p: Gsr;
  }
  class ReversionObserver extends Observer {
    constructor(p: Gsr);
    update(): void;
    _p: Gsr;
  }
}

export declare class HullWhite extends VasicekTermStructureConsistentModel {
  constructor(
      termStructure: Handle<YieldTermStructure>, a?: Real, sigma?: Real);
  tree(grid: TimeGrid): Lattice;
  dynamics(): OneFactorModel.ShortRateDynamics;
  discountBondOption1(
      type: Option.Type, strike: Real, maturity: Time,
      bondMaturity: Time): Real;
  discountBondOption2(
      type: Option.Type, strike: Real, maturity: Time, bondStart: Time,
      bondMaturity: Time): Real;
  static convexityBias(
      futuresPrice: Real, t: Time, T: Time, sigma: Real, a: Real): Rate;
  static FixedReversion(): boolean[];
  generateArguments(): void;
  A(t: Time, T: Time): Real;
  private _phi;
}
export declare namespace HullWhite {
  class Dynamics extends OneFactorModel.ShortRateDynamics {
    constructor(fitting: Parameter, a: Real, sigma: Real);
    variable(t: Time, r: Rate): Real;
    shortRate(t: Time, x: Real): Real;
    private _fitting;
  }
  class FittingParameter extends TermStructureFittingParameter {
    constructor(
        termStructure: Handle<YieldTermStructure>, a: Real, sigma: Real);
  }
  namespace FittingParameter {
    class Impl extends Parameter.Impl {
      constructor(
          termStructure: Handle<YieldTermStructure>, a: Real, sigma: Real);
      value(x: Real[], t: Time): Real;
      private _termStructure;
      private _a;
      private _sigma;
    }
  }
}

export declare class MarkovFunctional extends Gaussian1dModelCalibratedModel {
  mfInit1(
      termStructure: Handle<YieldTermStructure>, reversion: Real,
      volstepdates: Date[], volatilities: Real[],
      swaptionVol: Handle<SwaptionVolatilityStructure>,
      swaptionExpiries: Date[], swaptionTenors: Period[],
      swapIndexBase: SwapIndex,
      modelSettings?: MarkovFunctional.ModelSettings): MarkovFunctional;
  mfInit2(
      termStructure: Handle<YieldTermStructure>, reversion: Real,
      volstepdates: Date[], volatilities: Real[],
      capletVol: Handle<OptionletVolatilityStructure>, capletExpiries: Date[],
      iborIndex: IborIndex,
      modelSettings?: MarkovFunctional.ModelSettings): MarkovFunctional;
  modelSettings(): MarkovFunctional.ModelSettings;
  modelOutputs(): MarkovFunctional.ModelOutputs;
  numeraireDate(): Date;
  numeraireTime(): Time;
  volatility(): Real[];
  calibrate(
      helper: CalibrationHelper[], method: OptimizationMethod,
      endCriteria: EndCriteria, constraint?: Constraint, weights?: Real[],
      fixParameters?: boolean[]): void;
  update(): void;
  arbitrageIndices(): Array<[Size, Size]>;
  forceArbitrageIndices(indices: Array<[Size, Size]>): void;
  numeraireImpl(t: Time, y: Real, yts: Handle<YieldTermStructure>): Real;
  zerobondImpl(T: Time, t: Time, y: Real, yts: Handle<YieldTermStructure>):
      Real;
  generateArguments(): void;
  performCalculations(): void;
  FixedFirstVolatility(): boolean[];
  initialize(): void;
  updateTimes(): void;
  updateTimes1(): void;
  updateTimes2(): void;
  updateSmiles(): void;
  updateNumeraireTabulation(): void;
  makeSwaptionCalibrationPoint(expiry: Date, tenor: Period): void;
  makeCapletCalibrationPoint(expiry: Date): void;
  marketSwapRate(
      expiry: Date, p: MarkovFunctional.CalibrationPoint, digitalPrice: Real,
      guess?: Real, shift?: Real): Real;
  marketDigitalPrice(
      expiry: Date, p: MarkovFunctional.CalibrationPoint, type: Option.Type,
      strike: Real): Real;
  deflatedZerobondArray(T: Time, t: Time, y: Real[]): Real[];
  numeraireArray(t: Time, y: Real[]): Real[];
  zerobondArray(T: Time, t: Time, y: Real[]): Real[];
  deflatedZerobond(T: Time, t?: Time, y?: Real): Real;
  forwardRateInternal(
      fixing: Date, referenceDate?: Date, y?: Real, zeroFixingDays?: boolean,
      iborIdx?: IborIndex): Real;
  swapRateInternal(
      fixing: Date, tenor: Period, referenceDate?: Date, y?: Real,
      zeroFixingDays?: boolean, swapIdx?: SwapIndex): Real;
  swapAnnuityInternal(
      fixing: Date, tenor: Period, referenceDate?: Date, y?: Real,
      zeroFixingDays?: boolean, swapIdx?: SwapIndex): Real;
  capletPriceInternal(
      type: Option.Type, expiry: Date, strike: Rate, referenceDate?: Date,
      y?: Real, zeroFixingDays?: boolean, iborIdx?: IborIndex): Real;
  swaptionPriceInternal(
      type: Option.Type, expiry: Date, tenor: Period, strike: Rate,
      referenceDate?: Date, y?: Real, zeroFixingDays?: boolean,
      swapIdx?: SwapIndex): Real;
  private _modelSettings;
  private _modelOutputs;
  private _capletCalibrated;
  private _discreteNumeraire;
  private _numeraire;
  private _reversion;
  private _sigma;
  private _volstepdates;
  private _volsteptimes;
  private _volsteptimesArray;
  private _volatilities;
  private _numeraireDate;
  private _numeraireTime;
  private _swaptionVol;
  private _capletVol;
  private _swaptionExpiries;
  private _capletExpiries;
  private _swaptionTenors;
  private _swapIndexBase;
  private _iborIndex;
  private _calibrationPoints;
  private _times;
  private _y;
  private _normalIntegralX;
  private _normalIntegralW;
  private _arbitrageIndices;
  private _forcedArbitrageIndices;
}
export declare namespace MarkovFunctional {
  class ModelSettings {
    init1(): ModelSettings;
    init2(
        yGridPoints: Size, yStdDevs: Real, gaussHermitePoints: Size,
        digitalGap: Real, marketRateAccuracy: Real, lowerRateBound: Real,
        upperRateBound: Real, adjustments: Size,
        smileMoneynessCheckpoints: Real[]): ModelSettings;
    validate(): void;
    withYGridPoints(n: Size): ModelSettings;
    withYStdDevs(s: Real): ModelSettings;
    withGaussHermitePoints(n: Size): ModelSettings;
    withDigitalGap(d: Real): ModelSettings;
    withMarketRateAccuracy(a: Real): ModelSettings;
    withUpperRateBound(u: Real): ModelSettings;
    withLowerRateBound(l: Real): ModelSettings;
    withAdjustments(a: Size): ModelSettings;
    addAdjustment(a: Size): ModelSettings;
    removeAdjustment(a: Size): ModelSettings;
    withSmileMoneynessCheckpoints(m: Real[]): ModelSettings;
    _yGridPoints: Size;
    _yStdDevs: Real;
    _gaussHermitePoints: Size;
    _digitalGap: Real;
    _marketRateAccuracy: Real;
    _lowerRateBound: Real;
    _upperRateBound: Real;
    _adjustments: Size;
    _smileMoneynessCheckpoints: Real[];
  }
  namespace ModelSettings {
    enum Adjustments {
      AdjustNone = 0,
      AdjustDigitals = 1,
      AdjustYts = 2,
      ExtrapolatePayoffFlat = 4,
      NoPayoffExtrapolation = 8,
      KahaleSmile = 16,
      SmileExponentialExtrapolation = 32,
      KahaleInterpolation = 64,
      SmileDeleteArbitragePoints = 128,
      SabrSmile = 256
    }
  }
  class CalibrationPoint {
    _isCaplet: boolean;
    _tenor: Period;
    _paymentDates: Date[];
    _yearFractions: Real[];
    _atm: Real;
    _annuity: Real;
    _smileSection: SmileSection;
    _rawSmileSection: SmileSection;
    _minRateDigital: Real;
    _maxRateDigital: Real;
  }
  class ModelOutputs {
    constructor(
        dirty: boolean, settings: ModelSettings, expiries: Date[],
        tenors: Period[], atm: Real[], annuity: Real[],
        adjustmentFactors: Real[], digitalsAdjustmentFactors: Real[],
        messages: string[], smileStrikes: Real[][],
        marketRawCallPremium: Real[][], marketRawPutPremium: Real[][],
        marketCallPremium: Real[][], marketPutPremium: Real[][],
        modelCallPremium: Real[][], modelPutPremium: Real[][],
        marketVega: Real[][], marketZerorate: Real[], modelZerorate: Real[]);
    _dirty: boolean;
    _settings: ModelSettings;
    _expiries: Date[];
    _tenors: Period[];
    _atm: Real[];
    _annuity: Real[];
    _adjustmentFactors: Real[];
    _digitalsAdjustmentFactors: Real[];
    _messages: string[];
    _smileStrikes: Real[][];
    _marketRawCallPremium: Real[][];
    _marketRawPutPremium: Real[][];
    _marketCallPremium: Real[][];
    _marketPutPremium: Real[][];
    _modelCallPremium: Real[][];
    _modelPutPremium: Real[][];
    _marketVega: Real[][];
    _marketZerorate: Real[];
    _modelZerorate: Real[];
  }
  class ZeroHelper implements UnaryFunction<Real, Real> {
    constructor(
        model: MarkovFunctional, expiry: Date, p: CalibrationPoint,
        marketPrice: Real);
    f(strike: Real): Real;
    _model: MarkovFunctional;
    _marketPrice: Real;
    _expiry: Date;
    _p: CalibrationPoint;
  }
}

export declare class Vasicek extends OneFactorAffineModel {
  vInit(r0?: Rate, a?: Real, b?: Real, sigma?: Real, lambda?: Real): Vasicek;
  discountBondOption1(
      type: Option.Type, strike: Real, maturity: Time,
      bondMaturity: Time): Real;
  dynamics(): OneFactorModel.ShortRateDynamics;
  a(): Real;
  b(): Real;
  lambda(): Real;
  sigma(): Real;
  A(t: Time, T: Time): Real;
  B(t: Time, T: Time): Real;
  _r0: Real;
  _a: Parameter;
  _b: Parameter;
  _sigma: Parameter;
  _lambda: Parameter;
}
export declare namespace Vasicek {
  class Dynamics extends OneFactorModel.ShortRateDynamics {
    constructor(a: Real, b: Real, sigma: Real, r0: Real);
    variable(t: Time, r: Rate): Real;
    shortRate(t: Time, x: Real): Real;
    private _b;
  }
}

export declare class G2 extends
    TwoFactorModelAffineModelTermStructureConsistentModel {
  constructor(
      termStructure: Handle<YieldTermStructure>, a?: Real, sigma?: Real,
      b?: Real, eta?: Real, rho?: Real);
  dynamics(): TwoFactorModel.ShortRateDynamics;
  discountBond1(now: Time, maturity: Time, factors: Real[]): Real;
  discountBond2(t: Time, T: Time, x: Real, y: Real): Real;
  discountBondOption1(
      type: Option.Type, strike: Real, maturity: Time,
      bondMaturity: Time): Real;
  swaption(
      args: SwaptionEngine.Arguments, fixedRate: Rate, range: Real,
      intervals: Size): Real;
  discount(t: Time): DiscountFactor;
  a(): Real;
  sigma(): Real;
  b(): Real;
  eta(): Real;
  rho(): Real;
  generateArguments(): void;
  A(t: Time, T: Time): Real;
  B(x: Real, t: Time): Real;
  sigmaP(t: Time, s: Time): Real;
  V(t: Time): Real;
  private _a;
  private _sigma;
  private _b;
  private _eta;
  private _rho;
  private _phi;
}
export declare namespace G2 {
  class Dynamics extends TwoFactorModel.ShortRateDynamics {
    constructor(
        fitting: Parameter, a: Real, sigma: Real, b: Real, eta: Real,
        rho: Real);
    shortRate(t: Time, x: Real, y: Real): Rate;
    private _fitting;
  }
  class FittingParameter extends TermStructureFittingParameter {
    constructor(
        termStructure: Handle<YieldTermStructure>, a: Real, sigma: Real,
        b: Real, eta: Real, rho: Real);
  }
  namespace FittingParameter {
    class Impl extends Parameter.Impl {
      constructor(
          termStructure: Handle<YieldTermStructure>, a: Real, sigma: Real,
          b: Real, eta: Real, rho: Real);
      value(x: Real[], t: Time): Real;
      private _termStructure;
      private _a;
      private _sigma;
      private _b;
      private _eta;
      private _rho;
    }
  }
  class SwaptionPricingFunction implements UnaryFunction<Real, Real> {
    constructor(
        a: Real, sigma: Real, b: Real, eta: Real, rho: Real, w: Real,
        start: Real, payTimes: Time[], fixedRate: Rate, model: G2);
    mux(): Real;
    sigmax(): Real;
    f(x: Real): Real;
    private _a;
    private _sigma;
    private _b;
    private _eta;
    private _rho;
    private _w;
    private _T;
    private _t;
    private _rate;
    private _size;
    private _A;
    private _Ba;
    private _Bb;
    private _mux;
    private _muy;
    private _sigmax;
    private _sigmay;
    private _rhoxy;
  }
  namespace SwaptionPricingFunction {
    class SolvingFunction implements UnaryFunction<Real, Real> {
      constructor(lambda: Real[], Bb: Real[]);
      f(y: Real): Real;
      private _lambda;
      private _Bb;
    }
  }
}

export declare class AccountingEngine {
  constructor(
      evolver: MarketModelEvolver, product: MarketModelMultiProduct,
      initialNumeraireValue: Real);
  multiplePathValues(stats: SequenceStatisticsInc, numberOfPaths: Size): void;
  singlePathValues(values: Real[]): Real;
  private _evolver;
  private _product;
  private _initialNumeraireValue;
  private _numberProducts;
  private _numerairesHeld;
  private _numberCashFlowsThisStep;
  private _cashFlowsGenerated;
  private _discounters;
}

export declare class BrownianGenerator {
  nextStep(x: Real[]): Real;
  nextPath(): Real;
  numberOfFactors(): Size;
  numberOfSteps(): Size;
}
export declare class BrownianGeneratorFactory {
  create(factors: Size, steps: Size): BrownianGenerator;
}

export declare class ConstrainedEvolver extends MarketModelEvolver {
  setConstraintType(startIndexOfSwapRate: Size[], EndIndexOfSwapRate: Size[]):
      void;
  setThisConstraint(rateConstraints: Rate[], isConstraintActive: boolean[]):
      void;
}

export declare class CurveState {
  constructor(rateTimes: Time[]);
  numberOfRates(): Size;
  rateTimes(): Time[];
  rateTaus(): Time[];
  discountRatio(i: Size, j: Size): Real;
  forwardRate(i: Size): Rate;
  coterminalSwapAnnuity(numeraire: Size, i: Size): Rate;
  coterminalSwapRate(i: Size): Rate;
  cmSwapAnnuity(numeraire: Size, i: Size, spanningForwards: Size): Rate;
  cmSwapRate(i: Size, spanningForwards: Size): Rate;
  forwardRates(): Rate[];
  coterminalSwapRates(): Rate[];
  cmSwapRates(spanningForwards: Size): Rate[];
  swapRate(begin: Size, end: Size): Rate;
  clone(): CurveState;
  protected _numberOfRates: Size;
  protected _rateTimes: Time[];
  protected _rateTaus: Time[];
}
export declare function forwardsFromDiscountRatios(
    firstValidIndex: Size, ds: DiscountFactor[], taus: Time[],
    fwds: Rate[]): void;
export declare function coterminalFromDiscountRatios(
    firstValidIndex: Size, discountFactors: DiscountFactor[], taus: Time[],
    cotSwapRates: Rate[], cotSwapAnnuities: Real[]): void;
export declare function constantMaturityFromDiscountRatios(
    spanningForwards: Size, firstValidIndex: Size, ds: DiscountFactor[],
    taus: Time[], constMatSwapRates: Rate[],
    constMatSwapAnnuities: Real[]): void;

export declare class MarketModelDiscounter {
  constructor(paymentTime: Time, rateTimes: Time[]);
  numeraireBonds(curveState: CurveState, numeraire: Size): Real;
  private _before;
  private _beforeWeight;
}

export declare function inner_product(
    input1: Real[], f1: Size, l1: Size, input2: Real[], f2: Size,
    init: Real): Real;

export declare class EvolutionDescription {
  constructor(
      rateTimes: Time[], evolutionTimes?: Time[],
      relevanceRates?: Array<[Size, Size]>);
  rateTimes(): Time[];
  rateTaus(): Time[];
  evolutionTimes(): Time[];
  firstAliveRate(): Size[];
  relevanceRates(): Array<[Size, Size]>;
  numberOfRates(): Size;
  numberOfSteps(): Size;
  private _numberOfRates;
  private _rateTimes;
  private _evolutionTimes;
  private _relevanceRates;
  private _rateTaus;
  private _firstAliveRate;
}
export declare function checkCompatibility(
    evolution: EvolutionDescription, numeraires: Size[]): void;
export declare function isInTerminalMeasure(
    evolution: EvolutionDescription, numeraires: Size[]): boolean;
export declare function isInMoneyMarketPlusMeasure(
    evolution: EvolutionDescription, numeraires: Size[],
    offset?: Size): boolean;
export declare function isInMoneyMarketMeasure(
    evolution: EvolutionDescription, numeraires: Size[]): boolean;
export declare function terminalMeasure(evolution: EvolutionDescription):
    Size[];
export declare function moneyMarketPlusMeasure(
    evolution: EvolutionDescription, offset?: Size): Size[];
export declare function moneyMarketMeasure(evolution: EvolutionDescription):
    Size[];

export declare class MarketModelEvolver {
  numeraires(): Size[];
  startNewPath(): Real;
  advanceStep(): Real;
  currentStep(): Size;
  currentState(): CurveState;
  setInitialState(c: CurveState): void;
}

export declare namespace ForwardForwardMappings {
  function ForwardForwardJacobian(
      cs: CurveState, multiplier: Size, offset: Size): Matrix;
  function YMatrix(
      cs: CurveState, shortDisplacements: Spread[], longDisplacements: Spread[],
      multiplier: Size, offset: Size): Matrix;
  function RestrictCurveState(
      cs: CurveState, multiplier: Size, offset: Size): LMMCurveState;
}

export declare function historicalForwardRatesAnalysis(
    traits: Traits, i: Interpolator, statistics: SequenceStatistics,
    skippedDates: Date[], skippedDatesErrorMessage: string[],
    failedDates: Date[], failedDatesErrorMessage: string[],
    fixingPeriods: Period[], startDate: Date, endDate: Date, step: Period,
    fwdIndex: InterestRateIndex, initialGap: Period, horizon: Period,
    iborIndexes: IborIndex[], swapIndexes: SwapIndex[],
    yieldCurveDayCounter: DayCounter, yieldCurveAccuracy?: Real): void;
export declare class HistoricalForwardRatesAnalysis {
  skippedDates(): Date[];
  skippedDatesErrorMessage(): string[];
  failedDates(): Date[];
  failedDatesErrorMessage(): string[];
  fixingPeriods(): Period[];
}
export declare class HistoricalForwardRatesAnalysisImpl extends
    HistoricalForwardRatesAnalysis {
  constructor(
      traits: Traits, i: Interpolator, stats: SequenceStatistics,
      startDate: Date, endDate: Date, step: Period, fwdIndex: InterestRateIndex,
      initialGap: Period, horizon: Period, iborIndexes: IborIndex[],
      swapIndexes: SwapIndex[], yieldCurveDayCounter: DayCounter,
      yieldCurveAccuracy: Real);
  fixingPeriods(): Period[];
  skippedDates(): Date[];
  skippedDatesErrorMessage(): string[];
  failedDates(): Date[];
  failedDatesErrorMessage(): string[];
  private _stats;
  private _skippedDates;
  private _skippedDatesErrorMessage;
  private _failedDates;
  private _failedDatesErrorMessage;
  private _fixingPeriods;
}

export declare function historicalRatesAnalysis(
    statistics: SequenceStatistics, skippedDates: Date[],
    skippedDatesErrorMessage: string[], startDate: Date, endDate: Date,
    step: Period, indexes: InterestRateIndex[]): void;
export declare class HistoricalRatesAnalysis {
  constructor(
      statistics: SequenceStatistics, startDate: Date, endDate: Date,
      step: Period, indexes: InterestRateIndex[]);
  skippedDates(): Date[];
  skippedDatesErrorMessage(): string[];
  stats(): SequenceStatistics;
  private _stats;
  private _skippedDates;
  private _skippedDatesErrorMessage;
}

export declare class MarketModel {
  initialRates(): Rate[];
  displacements(): Spread[];
  evolution(): EvolutionDescription;
  numberOfRates(): Size;
  numberOfFactors(): Size;
  numberOfSteps(): Size;
  pseudoRoot(i: Size): Matrix;
  covariance(i: Size): Matrix;
  totalCovariance(endIndex: Size): Matrix;
  timeDependentVolatility(i: Size): Volatility[];
  private _covariance;
  private _totalCovariance;
}
export declare class MarketModelFactory extends Observable {
  create(e: EvolutionDescription, numberOfFactors: Size): MarketModel;
}

export declare function rateVolDifferences(
    marketModel1: MarketModel, marketModel2: MarketModel): Volatility[];
export declare function rateInstVolDifferences(
    marketModel1: MarketModel, marketModel2: MarketModel,
    index: Size): Spread[];
export declare function coterminalSwapPseudoRoots(
    piecewiseConstantCorrelation: PiecewiseConstantCorrelation,
    piecewiseConstantVariances: PiecewiseConstantVariance[]): Matrix[];

export declare class MarketModelMultiProduct {
  suggestedNumeraires(): Size[];
  evolution(): EvolutionDescription;
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      cashFlowsGenerated: MarketModelMultiProduct.CashFlow[][]): boolean;
  clone(): MarketModelMultiProduct;
}
export declare namespace MarketModelMultiProduct {
  class CashFlow {
    timeIndex: Size;
    amount: Real;
  }
}

export declare class PathwiseAccountingEngine {
  constructor(
      evolver: LogNormalFwdRateEuler, product: MarketModelPathwiseMultiProduct,
      pseudoRootStructure: MarketModel, initialNumeraireValue: Real);
  multiplePathValues(stats: SequenceStatisticsInc, numberOfPaths: Size): void;
  singlePathValues(values: Real[]): Real;
  private _evolver;
  private _product;
  private _pseudoRootStructure;
  private _initialNumeraireValue;
  private _numberProducts;
  private _numberRates;
  private _numberCashFlowTimes;
  private _numberSteps;
  private _currentForwards;
  private _lastForwards;
  private _doDeflation;
  private _numerairesHeld;
  private _numberCashFlowsThisStep;
  private _cashFlowsGenerated;
  private _discounters;
  private _V;
  private _LIBORRatios;
  private _Discounts;
  private _StepsDiscountsSquared;
  private _LIBORRates;
  private _partials;
  private _deflatorAndDerivatives;
  private _numberCashFlowsThisIndex;
  private _totalCashFlowsThisIndex;
  private _cashFlowIndicesThisStep;
}
export declare class PathwiseVegasAccountingEngine {}
export declare class PathwiseVegasOuterAccountingEngine {
  constructor(
      evolver: LogNormalFwdRateEuler, product: MarketModelPathwiseMultiProduct,
      pseudoRootStructure: MarketModel, VegaBumps: Matrix[][],
      initialNumeraireValue: Real);
  multiplePathValues(means: Real[], errors: Real[], numberOfPaths: Size): void;
}

export declare class MarketModelPathwiseDiscounter {
  constructor(paymentTime: Time, rateTimes: Time[]);
  getFactors(
      LIBORRates: Matrix, Discounts: Matrix, currentStep: Size,
      factors: Real[]): void;
  private _before;
  private _numberRates;
  private _beforeWeight;
  private _postWeight;
  private _taus;
}

export declare class MarketModelPathwiseMultiProduct {
  suggestedNumeraires(): Size[];
  evolution(): EvolutionDescription;
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  alreadyDeflated(): boolean;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      cashFlowsGenerated: MarketModelPathwiseMultiProduct.CashFlow[][]):
      boolean;
  clone(): MarketModelPathwiseMultiProduct;
}
export declare namespace MarketModelPathwiseMultiProduct {
  class CashFlow {
    timeIndex: Size;
    amount: Real[];
  }
}

export declare class PiecewiseConstantCorrelation {
  times(): Time[];
  rateTimes(): Time[];
  correlations(): Matrix[];
  correlation(i: Size): Matrix;
  numberOfRates(): Size;
}

export declare class ProxyGreekEngine {
  constructor(
      evolver: MarketModelEvolver, constrainedEvolvers: ConstrainedEvolver[][],
      diffWeights: Real[][][], startIndexOfConstraint: Size[],
      endIndexOfConstraint: Size[], product: MarketModelMultiProduct,
      initialNumeraireValue: Real);
  multiplePathValues(
      stats: SequenceStatisticsInc, modifiedStats: SequenceStatisticsInc[][],
      numberOfPaths: Size): void;
  singlePathValues(values: Real[], modifiedValues: Real[][][]): void;
  singleEvolverValues(
      evolver: MarketModelEvolver, values: Real[], storeRates?: boolean): void;
  private _originalEvolver;
  private _constrainedEvolvers;
  private _diffWeights;
  private _startIndexOfConstraint;
  private _endIndexOfConstraint;
  private _product;
  private _initialNumeraireValue;
  private _numberProducts;
  private _constraints;
  private _constraintsActive;
  private _numerairesHeld;
  private _numberCashFlowsThisStep;
  private _cashFlowsGenerated;
  private _discounters;
}

export declare class SwapForwardMappings {
  static annuity(
      cs: CurveState, startIndex: Size, endIndex: Size,
      numeraireIndex: Size): Real;
  static swapDerivative(
      cs: CurveState, startIndex: Size, endIndex: Size,
      forwardIndex: Size): Real;
  static coterminalSwapForwardJacobian(cs: CurveState): Matrix;
  static coterminalSwapZedMatrix(cs: CurveState, displacement: Spread): Matrix;
  static coinitialSwapForwardJacobian(cs: CurveState): Matrix;
  static coinitialSwapZedMatrix(cs: CurveState, displacement: Spread): Matrix;
  static cmSwapForwardJacobian(cs: CurveState, spanningForwards: Size): Matrix;
  static cmSwapZedMatrix(
      cs: CurveState, spanningForwards: Size, displacement: Spread): Matrix;
  static swaptionImpliedVolatility(
      volStructure: MarketModel, startIndex: Size, endIndex: Size): Real;
}

export declare function mergeTimes(
    times: Time[][], mergedTimes: Time[], isPresent: boolean[][]): void;
export declare function isInSubset(set: Time[], subset: Time[]): boolean[];
export declare function checkIncreasingTimes(times: Time[]): void;
export declare function checkIncreasingTimesAndCalculateTaus(
    times: Time[], taus: Time[]): void;

export declare class MTBrownianGenerator extends BrownianGenerator {
  constructor(factors: Size, steps: Size, seed: Size);
  nextStep(output: Real[]): Real;
  nextPath(): Real;
  numberOfFactors(): Size;
  numberOfSteps(): Size;
  private _factors;
  private _steps;
  private _lastStep;
  private _generator;
  private _inverseCumulative;
}
export declare class MTBrownianGeneratorFactory extends
    BrownianGeneratorFactory {
  constructor(seed: Size);
  create(factors: Size, steps: Size): BrownianGenerator;
  private _seed;
}

export declare class SobolBrownianGenerator extends BrownianGenerator {
  constructor(
      factors: Size, steps: Size, ordering: SobolBrownianGenerator.Ordering,
      seed: Integer, directionIntegers?: SobolRsg.DirectionIntegers);
}
export declare namespace SobolBrownianGenerator {
  enum Ordering { Factors = 0, Steps = 1, Diagonal = 2 }
}
export declare class SobolBrownianGeneratorFactory extends
    BrownianGeneratorFactory {
  constructor(
      ordering: SobolBrownianGenerator.Ordering, seed?: Integer,
      directionIntegers?: SobolRsg.DirectionIntegers);
}

export declare class BermudanSwaptionExerciseValue extends
    MarketModelExerciseValue {
  constructor(rateTimes: Time[], payoffs: Payoff[]);
  numberOfExercises(): Size;
  evolution(): EvolutionDescription;
  possibleCashFlowTimes(): Time[];
  reset(): void;
  nextStep(state: CurveState): void;
  isExerciseTime(): boolean[];
  value(cs: CurveState): MarketModelMultiProduct.CashFlow;
  clone(): MarketModelExerciseValue;
  private _numberOfExercises;
  private _rateTimes;
  private _payoffs;
  private _evolution;
  private _currentIndex;
  private _cf;
}

export declare function collectNodeData(
    evolver: MarketModelEvolver, product: MarketModelMultiProduct,
    dataProvider: MarketModelNodeDataProvider, rebate: MarketModelExerciseValue,
    control: MarketModelExerciseValue, numberOfPaths: Size,
    collectedData: NodeData[][]): void;

export declare class MarketModelExerciseValue {
  numberOfExercises(): Size;
  evolution(): EvolutionDescription;
  possibleCashFlowTimes(): Time[];
  nextStep(cs: CurveState): void;
  reset(): void;
  isExerciseTime(): boolean[];
  value(cs: CurveState): MarketModelMultiProduct.CashFlow;
  clone(): MarketModelExerciseValue;
}

export declare class LongstaffSchwartzExerciseStrategy extends
    ExerciseStrategy {
  constructor(
      basisSystem: MarketModelBasisSystem, basisCoefficients: Real[][],
      evolution: EvolutionDescription, numeraires: Size[],
      exercise: MarketModelExerciseValue, control: MarketModelExerciseValue);
  exerciseTimes(): Time[];
  relevantTimes(): Time[];
  exercise(currentState: CurveState): boolean;
  nextStep(currentState: CurveState): void;
  reset(): void;
  clone(): ExerciseStrategy;
  private _basisSystem;
  private _basisCoefficients;
  private _exercise;
  private _control;
  private _numeraires;
  private _currentIndex;
  private _principalInNumerairePortfolio;
  private _newPrincipal;
  private _exerciseTimes;
  private _relevantTimes;
  private _isBasisTime;
  private _isRebateTime;
  private _isControlTime;
  private _isExerciseTime;
  private _rebateDiscounters;
  private _controlDiscounters;
  private _basisValues;
  private _exerciseIndex;
}

export declare class MarketModelBasisSystem extends
    MarketModelNodeDataProvider {
  numberOfFunctions(): Size[];
  numberOfData(): Size[];
}

export declare class MarketModelParametricExercise extends
    MarketModelNodeDataProviderParametricExercise {
  numberOfData(): Size[];
  clone(): MarketModelParametricExercise;
}

export declare class MarketModelNodeDataProvider {
  numberOfExercises(): Size;
  numberOfData(): Size[];
  evolution(): EvolutionDescription;
  nextStep(cs: CurveState): void;
  reset(): void;
  isExerciseTime(): boolean[];
  values(cs: CurveState, results: Real[]): void;
}

export declare class NothingExerciseValue extends MarketModelExerciseValue {
  constructor(rateTimes: Time[], isExerciseTime?: boolean[]);
  numberOfExercises(): Size;
  evolution(): EvolutionDescription;
  possibleCashFlowTimes(): Time[];
  reset(): void;
  nextStep(state: CurveState): void;
  isExerciseTime(): boolean[];
  value(cs: CurveState): MarketModelMultiProduct.CashFlow;
  clone(): MarketModelExerciseValue;
  private _numberOfExercises;
  private _rateTimes;
  private _isExerciseTime;
  private _evolution;
  private _currentIndex;
  private _cf;
}

export declare class ParametricExerciseAdapter extends ExerciseStrategy {
  constructor(exercise: MarketModelParametricExercise, parameters: Real[][]);
  exerciseTimes(): Time[];
  relevantTimes(): Time[];
  reset(): void;
  nextStep(currentState: CurveState): void;
  exercise(currentState: CurveState): boolean;
  clone(): ExerciseStrategy;
  private _exercise;
  private _parameters;
  private _exerciseTimes;
  private _currentStep;
  private _currentExercise;
  private _isExerciseTime;
  private _numberOfVariables;
  private _variables;
}

export declare class SwapBasisSystem extends MarketModelBasisSystem {
  constructor(rateTimes: Time[], exerciseTimes: Time[]);
  numberOfExercises(): Size;
  numberOfFunctions(): Size[];
  evolution(): EvolutionDescription;
  nextStep(cs: CurveState): void;
  reset(): void;
  isExerciseTime(): boolean[];
  values(currentState: CurveState, results: Real[]): void;
  clone(): MarketModelBasisSystem;
  private _rateTimes;
  private _exerciseTimes;
  private _currentIndex;
  private _rateIndex;
  private _evolution;
}

export declare class SwapForwardBasisSystem extends MarketModelBasisSystem {
  constructor(rateTimes: Time[], exerciseTimes: Time[]);
  numberOfExercises(): Size;
  numberOfFunctions(): Size[];
  evolution(): EvolutionDescription;
  nextStep(cs: CurveState): void;
  reset(): void;
  isExerciseTime(): boolean[];
  values(currentState: CurveState, results: Real[]): void;
  clone(): MarketModelBasisSystem;
  private _rateTimes;
  private _exerciseTimes;
  private _currentIndex;
  private _rateIndex;
  private _evolution;
}

export declare class SwapRateTrigger extends ExerciseStrategy {
  constructor(rateTimes: Time[], swapTriggers: Rate[], exerciseTimes: Time[]);
  exerciseTimes(): Time[];
  relevantTimes(): Time[];
  reset(): void;
  exercise(currentState: CurveState): boolean;
  nextStep(cs: CurveState): void;
  clone(): ExerciseStrategy;
  private _rateTimes;
  private _swapTriggers;
  private _exerciseTimes;
  private _currentIndex;
  private _rateIndex;
}

export declare class TriggeredSwapExercise extends
    MarketModelParametricExercise {
  constructor(rateTimes: Time[], exerciseTimes: Time[], strikes: Rate[]);
  numberOfExercises(): Size;
  evolution(): EvolutionDescription;
  nextStep(cs: CurveState): void;
  reset(): void;
  isExerciseTime(): boolean[];
  values(state: CurveState, results: Real[]): void;
  numberOfVariables(): Size[];
  numberOfParameters(): Size[];
  exercise(exerciseNumber: Size, parameters: Real[], variables: Real[]):
      boolean;
  guess(exerciseIndex: Size, parameters: Real[]): void;
  _rateTimes: Time[];
  private _exerciseTimes;
  private _strikes;
  private _currentStep;
  private _rateIndex;
  private _evolution;
}

export declare class UpperBoundEngine {
  constructor(
      evolver: MarketModelEvolver, innerEvolvers: MarketModelEvolver[],
      underlying: MarketModelMultiProduct, rebate: MarketModelExerciseValue,
      hedge: MarketModelMultiProduct, hedgeRebate: MarketModelExerciseValue,
      hedgeStrategy: ExerciseStrategy, initialNumeraireValue: Real);
  multiplePathValues(stats: Statistics, outerPaths: Size, innerPaths: Size):
      void;
  singlePathValue(innerPaths: Size): [Real, Real];
  private collectCashFlows;
  private _evolver;
  private _innerEvolvers;
  private _composite;
  private _initialNumeraireValue;
  private _underlyingSize;
  private _rebateSize;
  private _hedgeSize;
  private _hedgeRebateSize;
  private _underlyingOffset;
  private _rebateOffset;
  private _hedgeOffset;
  private _hedgeRebateOffset;
  private _numberOfProducts;
  private _numberOfSteps;
  private _isExerciseTime;
  private _numberCashFlowsThisStep;
  private _cashFlowsGenerated;
  private _discounters;
}

export declare class CotSwapFromFwdCorrelation extends
    PiecewiseConstantCorrelation {
  constructor(
      fwdCorr: PiecewiseConstantCorrelation, curveState: CurveState,
      displacement: Spread);
  times(): Time[];
  rateTimes(): Time[];
  correlations(): Matrix[];
  numberOfRates(): Size;
  private _fwdCorr;
  private _numberOfRates;
  private _swapCorrMatrices;
}

export declare function exponentialCorrelations(
    rateTimes: Time[], longTermCorr?: Real, beta?: Real, gamma?: Real,
    time?: Time): Matrix;
export declare class ExponentialForwardCorrelation extends
    PiecewiseConstantCorrelation {
  constructor(
      rateTimes: Time[], longTermCorr?: Real, beta?: Real, gamma?: Real,
      times?: Time[]);
  times(): Time[];
  rateTimes(): Time[];
  correlations(): Matrix[];
  numberOfRates(): Size;
  private _numberOfRates;
  private _longTermCorr;
  private _beta;
  private _gamma;
  private _rateTimes;
  private _times;
  private _correlations;
}

export declare class TimeHomogeneousForwardCorrelation extends
    PiecewiseConstantCorrelation {
  constructor(fwdCorrelation: Matrix, rateTimes: Time[]);
  times(): Time[];
  rateTimes(): Time[];
  correlations(): Matrix[];
  numberOfRates(): Size;
  static evolvedMatrices(fwdCorrelation: Matrix): Matrix[];
  private _numberOfRates;
  private _fwdCorrelation;
  private _rateTimes;
  private _times;
  private _correlations;
}

export declare class CMSwapCurveState extends CurveState {
  constructor(rateTimes: Time[], spanningForwards: Size);
  setOnCMSwapRates(rates: Rate[], firstValidIndex?: Size): void;
  discountRatio(i: Size, j: Size): Real;
  forwardRate(i: Size): Rate;
  coterminalSwapRate(i: Size): Rate;
  coterminalSwapAnnuity(numeraire: Size, i: Size): Rate;
  cmSwapRate(i: Size, spanningForwards: Size): Rate;
  cmSwapAnnuity(numeraire: Size, i: Size, spanningForwards: Size): Rate;
  forwardRates(): Rate[];
  coterminalSwapRates(): Rate[];
  cmSwapRates(spanningForwards: Size): Rate[];
  clone(): CurveState;
  private _spanningFwds;
  private _first;
  private _discRatios;
  private _forwardRates;
  private _cmSwapRates;
  private _cmSwapAnnuities;
  private _irrCMSwapRates;
  private _irrCMSwapAnnuities;
  private _cotSwapRates;
  private _cotAnnuities;
}

export declare class CoterminalSwapCurveState extends CurveState {
  constructor(rateTimes: Time[]);
  setOnCoterminalSwapRates(rates: Rate[], firstValidIndex?: Size): void;
  discountRatio(i: Size, j: Size): Real;
  forwardRate(i: Size): Rate;
  coterminalSwapRate(i: Size): Rate;
  coterminalSwapAnnuity(numeraire: Size, i: Size): Rate;
  cmSwapRate(i: Size, spanningForwards: Size): Rate;
  cmSwapAnnuity(numeraire: Size, i: Size, spanningForwards: Size): Rate;
  forwardRates(): Rate[];
  coterminalSwapRates(): Rate[];
  cmSwapRates(spanningForwards: Size): Rate[];
  clone(): CurveState;
  private _first;
  private _discRatios;
  private _forwardRates;
  private _cmSwapRates;
  private _cmSwapAnnuities;
  private _cotSwapRates;
  private _cotAnnuities;
}

export declare class LMMCurveState extends CurveState {
  constructor(rateTimes: Time[]);
  setOnForwardRates(rates: Rate[], firstValidIndex?: Size): void;
  setOnDiscountRatios(discRatios: Rate[], firstValidIndex?: Size): void;
  discountRatio(i: Size, j: Size): Real;
  forwardRate(i: Size): Rate;
  coterminalSwapRate(i: Size): Rate;
  coterminalSwapAnnuity(numeraire: Size, i: Size): Rate;
  cmSwapRate(i: Size, spanningForwards: Size): Rate;
  cmSwapAnnuity(numeraire: Size, i: Size, spanningForwards: Size): Rate;
  forwardRates(): Rate[];
  coterminalSwapRates(): Rate[];
  cmSwapRates(spanningForwards: Size): Rate[];
  clone(): CurveState;
  private _first;
  private _discRatios;
  private _forwardRates;
  private _cmSwapRates;
  private _cmSwapAnnuities;
  private _cotSwapRates;
  private _cotAnnuities;
  private _firstCotAnnuityComped;
}

export declare class CMSMMDriftCalculator {
  constructor(
      pseudo: Matrix, displacements: Spread[], taus: Time[], numeraire: Size,
      alive: Size, spanningFwds: Size);
  compute(cs: CMSwapCurveState, drifts: Real[]): void;
  private _numberOfRates;
  private _numberOfFactors;
  private _numeraire;
  private _alive;
  private _displacements;
  private _oneOverTaus;
  _C: Matrix;
  private _pseudo;
  _tmp: Real[];
  private _PjPnWk;
  private _wkaj;
  private _wkajN;
  private _downs;
  private _ups;
  private _spanningFwds;
}

export declare class LMMDriftCalculator {
  constructor(
      pseudo: Matrix, displacements: Spread[], taus: Time[], numeraire: Size,
      alive: Size);
  compute1(cs: LMMCurveState, drifts: Real[]): void;
  compute2(fwds: Rate[], drifts: Real[]): void;
  computePlain1(cs: LMMCurveState, drifts: Real[]): void;
  computePlain2(forwards: Rate[], drifts: Real[]): void;
  computeReduced1(cs: LMMCurveState, drifts: Real[]): void;
  computeReduced2(forwards: Rate[], drifts: Real[]): void;
  private _numberOfRates;
  private _numberOfFactors;
  private _isFullFactor;
  private _numeraire;
  private _alive;
  private _displacements;
  private _oneOverTaus;
  private _C;
  private _pseudo;
  private _tmp;
  private _e;
  private _downs;
  private _ups;
}

export declare class LMMNormalDriftCalculator {
  constructor(pseudo: Matrix, taus: Time[], numeraire: Size, alive: Size);
  compute1(cs: LMMCurveState, drifts: Real[]): void;
  compute2(fwds: Rate[], drifts: Real[]): void;
  computePlain1(cs: LMMCurveState, drifts: Real[]): void;
  computePlain2(forwards: Rate[], drifts: Real[]): void;
  computeReduced1(cs: LMMCurveState, drifts: Real[]): void;
  computeReduced2(forwards: Rate[], drifts: Real[]): void;
  private _numberOfRates;
  private _numberOfFactors;
  private _isFullFactor;
  private _numeraire;
  private _alive;
  private _oneOverTaus;
  private _C;
  private _pseudo;
  private _tmp;
  private _e;
  private _downs;
  private _ups;
}

export declare class SMMDriftCalculator {
  constructor(
      pseudo: Matrix, displacements: Spread[], taus: Time[], numeraire: Size,
      alive: Size);
  compute(cs: CoterminalSwapCurveState, drifts: Real[]): void;
  private _numberOfRates;
  private _numberOfFactors;
  private _numeraire;
  private _alive;
  private _displacements;
  private _oneOverTaus;
  _C: Matrix;
  private _pseudo;
  _tmp: Real[];
  private _wkaj;
  private _wkpj;
  private _wkajshifted;
}

export declare class AbcdVol extends MarketModel {
  constructor(
      a: Real, b: Real, c: Real, d: Real, ks: Real[],
      corr: PiecewiseConstantCorrelation, evolution: EvolutionDescription,
      numberOfFactors: Size, initialRates: Rate[], displacements: Spread[]);
  initialRates(): Rate[];
  displacements(): Spread[];
  evolution(): EvolutionDescription;
  numberOfRates(): Size;
  numberOfFactors(): Size;
  numberOfSteps(): Size;
  pseudoRoot(i: Size): Matrix;
  private _numberOfFactors;
  private _numberOfRates;
  private _numberOfSteps;
  private _initialRates;
  private _displacements;
  private _evolution;
  private _pseudoRoots;
}

export declare class AlphaFinder {
  constructor(parametricform: AlphaForm);
  solve(
      alpha0: Real, stepindex: Integer, rateonevols: Volatility[],
      ratetwohomogeneousvols: Volatility[], correlations: Real[], w0: Real,
      w1: Real, targetVariance: Real, tolerance: Real, alphaMax: Real,
      alphaMin: Real, steps: Integer, byref: byRef,
      ratetwovols: Volatility[]): boolean;
  solveWithMaxHomogeneity(
      alpha0: Real, stepindex: Integer, rateonevols: Volatility[],
      ratetwohomogeneousvols: Volatility[], correlations: Real[], w0: Real,
      w1: Real, targetVariance: Real, tolerance: Real, alphaMax: Real,
      alphaMin: Real, steps: Integer, byref: byRef,
      ratetwovols: Volatility[]): boolean;
  private computeLinearPart;
  private computeQuadraticPart;
  private valueAtTurningPoint;
  private minusValueAtTurningPoint;
  private testIfSolutionExists;
  private finalPart;
  private homogeneityfailure;
  private _parametricform;
  private _stepindex;
  private _rateonevols;
  private _ratetwohomogeneousvols;
  private _putativevols;
  private _correlations;
  private _w0;
  private _w1;
  private _constantPart;
  private _linearPart;
  private _quadraticPart;
  private _totalVar;
  private _targetVariance;
}
interface byRef {
  alpha: Real;
  a: Real;
  b: Real;
}


export declare class AlphaForm implements UnaryFunction<Integer, Real> {
  f(i: Integer): Real;
  setAlpha(alpha: Real): void;
}

export declare class AlphaFormInverseLinear extends AlphaForm {
  constructor(times: Time[], alpha?: Real);
  f(i: Integer): Real;
  setAlpha(alpha: Real): void;
  private _times;
  private _alpha;
}
export declare class AlphaFormLinearHyperbolic extends AlphaForm {
  constructor(times: Time[], alpha?: Real);
  f(i: Integer): Real;
  setAlpha(alpha: Real): void;
  private _times;
  private _alpha;
}

export declare class CTSMMCapletAlphaFormCalibration extends
    CTSMMCapletCalibration {
  constructor(
      evolution: EvolutionDescription, corr: PiecewiseConstantCorrelation,
      displacedSwapVariances: PiecewiseConstantVariance[],
      mktCapletVols: Volatility[], cs: CurveState, displacement: Spread,
      alphaInitial: Real[], alphaMax: Real[], alphaMin: Real[],
      maximizeHomogeneity: boolean, parametricForm?: AlphaForm);
  alpha(): Real[];
  static capletAlphaFormCalibration(
      evolution: EvolutionDescription, corr: PiecewiseConstantCorrelation,
      displacedSwapVariances: PiecewiseConstantVariance[],
      capletVols: Volatility[], cs: CurveState, displacement: Spread,
      alphaInitial: Real[], alphaMax: Real[], alphaMin: Real[],
      maximizeHomogeneity: boolean, parametricForm: AlphaForm,
      numberOfFactors: Size, maxIterations: Integer, tolerance: Real,
      alpha: Real[], a: Real[], b: Real[],
      swapCovariancePseudoRoots: Matrix[]): Natural;
  _calibrationImpl(
      numberOfFactors: Natural, maxIterations: Natural,
      tolerance: Real): Natural;
  private _alphaInitial;
  private _alphaMax;
  private _alphaMin;
  private _maximizeHomogeneity;
  private _parametricForm;
  private _alpha;
  private _a;
  private _b;
}

export declare class CTSMMCapletMaxHomogeneityCalibration extends
    CTSMMCapletCalibration {
  constructor(
      evolution: EvolutionDescription, corr: PiecewiseConstantCorrelation,
      displacedSwapVariances: PiecewiseConstantVariance[],
      mktCapletVols: Volatility[], cs: CurveState, displacement: Spread,
      caplet0Swaption1Priority?: Real);
  static capletMaxHomogeneityCalibration(
      evolution: EvolutionDescription, corr: PiecewiseConstantCorrelation,
      displacedSwapVariances: PiecewiseConstantVariance[],
      capletVols: Volatility[], cs: CurveState, displacement: Spread,
      caplet0Swaption1Priority: Real, numberOfFactors: Size,
      maxIterations: Integer, tolerance: Real, byref: byRef,
      swapCovariancePseudoRoots: Matrix[]): Natural;
  _calibrationImpl(
      numberOfFactors: Natural, maxIterations: Natural,
      tolerance: Real): Natural;
  private _caplet0Swaption1Priority;
  private _totalSwaptionError;
}
interface byRef {
  deformationSize?: Real;
  totalSwaptionError?: Real;
  swaptionError?: Real;
  capletError?: Real;
}

export declare function capletSwaptionPeriodicCalibration(
    evolution: EvolutionDescription, corr: PiecewiseConstantCorrelation,
    displacedSwapVariances: VolatilityInterpolationSpecifier,
    capletVols: Volatility[], cs: CurveState, displacement: Spread,
    caplet0Swaption1Priority: Real, numberOfFactors: Size, period: Size,
    max1dIterations: Size, tolerance1d: Real, maxUnperiodicIterations: Size,
    toleranceUnperiodic: Real, maxPeriodIterations: Size, periodTolerance: Real,
    byref: byRef, swapCovariancePseudoRoots: Matrix[], finalScales: Real[],
    modelSwaptionVolsMatrix: Matrix): Integer;
interface byRef {
  iterationsDone: Size;
  errorImprovement: Real;
}


export declare class CTSMMCapletOriginalCalibration extends
    CTSMMCapletCalibration {
  constructor(
      evolution: EvolutionDescription, corr: PiecewiseConstantCorrelation,
      displacedSwapVariances: PiecewiseConstantVariance[],
      mktCapletVols: Volatility[], cs: CurveState, displacement: Spread,
      alpha: Real[], lowestRoot: boolean, useFullApprox: boolean);
  static calibrationFunction(
      evolution: EvolutionDescription, corr: PiecewiseConstantCorrelation,
      displacedSwapVariances: PiecewiseConstantVariance[],
      capletVols: Volatility[], cs: CurveState, displacement: Spread,
      alpha: Real[], lowestRoot: boolean, useFullAprox: boolean,
      numberOfFactors: Size, swapCovariancePseudoRoots: Matrix[]): Natural;
  _calibrationImpl(
      numberOfFactors: Natural, maxIterations: Natural,
      tolerance: Real): Natural;
  private _alpha;
  private _lowestRoot;
  private _useFullApprox;
}

export declare class CotSwapToFwdAdapter extends MarketModel {
  constructor(ctModel: MarketModel);
  initialRates(): Rate[];
  displacements(): Spread[];
  evolution(): EvolutionDescription;
  numberOfRates(): Size;
  numberOfFactors(): Size;
  numberOfSteps(): Size;
  pseudoRoot(i: Size): Matrix;
  private _coterminalModel;
  private _numberOfFactors;
  private _numberOfRates;
  private _numberOfSteps;
  private _initialRates;
  private _pseudoRoots;
}
export declare class CotSwapToFwdAdapterFactory extends
    MarketModelFactoryObserver {
  constructor(coterminalFactory: MarketModelFactory);
  create(evolution: EvolutionDescription, numberOfFactors: Size): MarketModel;
  update(): void;
  private _coterminalFactory;
}

export declare class CTSMMCapletCalibration {
  constructor(
      evolution: EvolutionDescription, corr: PiecewiseConstantCorrelation,
      displacedSwapVariances: PiecewiseConstantVariance[],
      mktCapletVols: Volatility[], cs: CurveState, displacement: Spread);
  calibrate(
      numberOfFactors: Natural, maxIterations: Natural,
      capletVolTolerance: Real, innerSolvingMaxIterations?: Natural,
      innerSolvingTolerance?: Real): boolean;
  failures(): Natural;
  deformationSize(): Real;
  capletRmsError(): Real;
  capletMaxError(): Real;
  swaptionRmsError(): Real;
  swaptionMaxError(): Real;
  swapPseudoRoots(): Matrix[];
  swapPseudoRoot(i: Size): Matrix;
  mktCapletVols(): Volatility[];
  mdlCapletVols(): Volatility[];
  mktSwaptionVols(): Volatility[];
  mdlSwaptionVols(): Volatility[];
  timeDependentCalibratedSwaptionVols(i: Size): Volatility[];
  timeDependentUnCalibratedSwaptionVols(i: Size): Volatility[];
  static performChecks(
      evolution: EvolutionDescription, corr: PiecewiseConstantCorrelation,
      displacedSwapVariances: PiecewiseConstantVariance[],
      mktCapletVols: Volatility[], cs: CurveState): void;
  curveState(): CurveState;
  displacements(): Spread[];
  _calibrationImpl(
      numberOfFactors: Natural, innerMaxIterations: Natural,
      innerTolerance: Real): Natural;
  protected _evolution: EvolutionDescription;
  protected _corr: PiecewiseConstantCorrelation;
  protected _displacedSwapVariances: PiecewiseConstantVariance[];
  protected _mktCapletVols: Volatility[];
  protected _mdlCapletVols: Volatility[];
  protected _mktSwaptionVols: Volatility[];
  protected _mdlSwaptionVols: Volatility[];
  protected _timeDependentCalibratedSwaptionVols: Volatility[][];
  protected _cs: CurveState;
  protected _displacement: Spread;
  protected _numberOfRates: Size;
  protected _usedCapletVols: Volatility[];
  protected _calibrated: boolean;
  protected _failures: Natural;
  protected _deformationSize: Real;
  protected _capletRmsError: Real;
  protected _capletMaxError: Real;
  protected _swaptionRmsError: Real;
  protected _swaptionMaxError: Real;
  protected _swapCovariancePseudoRoots: Matrix[];
}

export declare class FlatVol extends MarketModel {
  constructor(
      vols: Volatility[], corr: PiecewiseConstantCorrelation,
      evolution: EvolutionDescription, numberOfFactors: Size,
      initialRates: Rate[], displacements: Spread[]);
  initialRates(): Rate[];
  displacements(): Spread[];
  evolution(): EvolutionDescription;
  numberOfRates(): Size;
  numberOfFactors(): Size;
  numberOfSteps(): Size;
  pseudoRoot(i: Size): Matrix;
  private _numberOfFactors;
  private _numberOfRates;
  private _numberOfSteps;
  private _initialRates;
  private _displacements;
  private _evolution;
  private _pseudoRoots;
}
export declare class FlatVolFactory extends MarketModelFactoryObserver {
  constructor(
      longTermCorrelation: Real, beta: Real, times: Time[], vols: Volatility[],
      yieldCurve: Handle<YieldTermStructure>, displacement: Spread);
  create(evolution: EvolutionDescription, numberOfFactors: Size): MarketModel;
  update(): void;
  private _longTermCorrelation;
  private _beta;
  private _times;
  private _vols;
  private _volatility;
  private _yieldCurve;
  private _displacement;
}

export declare class FwdPeriodAdapter extends MarketModel {
  constructor(
      largeModel: MarketModel, period: Size, offset: Size,
      newDisplacements: Spread[]);
  initialRates(): Rate[];
  displacements(): Spread[];
  evolution(): EvolutionDescription;
  numberOfRates(): Size;
  numberOfFactors(): Size;
  numberOfSteps(): Size;
  pseudoRoot(i: Size): Matrix;
  private _evolution;
  private _numberOfFactors;
  private _numberOfRates;
  private _numberOfSteps;
  private _initialRates;
  private _pseudoRoots;
  private _displacements;
}

export declare class FwdToCotSwapAdapter extends MarketModel {
  constructor(fwdModel: MarketModel);
  initialRates(): Rate[];
  displacements(): Spread[];
  evolution(): EvolutionDescription;
  numberOfRates(): Size;
  numberOfFactors(): Size;
  numberOfSteps(): Size;
  pseudoRoot(i: Size): Matrix;
  private _fwdModel;
  private _numberOfFactors;
  private _numberOfRates;
  private _numberOfSteps;
  private _initialRates;
  private _pseudoRoots;
}
export declare class FwdToCotSwapAdapterFactory extends
    MarketModelFactoryObserver {
  constructor(forwardFactory: MarketModelFactory);
  create(evolution: EvolutionDescription, numberOfFactors: Size): MarketModel;
  update(): void;
  private _forwardFactory;
}

export declare class PiecewiseConstantAbcdVariance extends
    PiecewiseConstantVariance {
  constructor(
      a: Real, b: Real, c: Real, d: Real, resetIndex: Size, rateTimes: Time[]);
  variances(): Real[];
  volatilities(): Real[];
  rateTimes(): Time[];
  getABCD(byref: byRef): void;
  private _variances;
  private _volatilities;
  private _rateTimes;
  private _a;
  private _b;
  private _c;
  private _d;
}
interface byRef {
  a: Real;
  b: Real;
  c: Real;
  d: Real;
}


export declare class PiecewiseConstantVariance {
  variances(): Real[];
  volatilities(): Volatility[];
  rateTimes(): Time[];
  variance(i: Size): Real;
  volatility(i: Size): Volatility;
  totalVariance(i: Size): Real;
  totalVolatility(i: Size): Volatility;
}

export declare class PseudoRootFacade extends MarketModel {
  prfInit1(c: CTSMMCapletCalibration): PseudoRootFacade;
  prfInit2(
      covariancePseudoRoots: Matrix[], rateTimes: Rate[], initialRates: Rate[],
      displacements: Spread[]): PseudoRootFacade;
  initialRates(): Rate[];
  displacements(): Spread[];
  evolution(): EvolutionDescription;
  numberOfRates(): Size;
  numberOfFactors(): Size;
  numberOfSteps(): Size;
  pseudoRoot(i: Size): Matrix;
  private _numberOfFactors;
  private _numberOfRates;
  private _numberOfSteps;
  private _initialRates;
  private _displacements;
  private _evolution;
  private _covariancePseudoRoots;
}

export declare class VolatilityInterpolationSpecifier {
  setScalingFactors(scales: Real[]): void;
  setLastCapletVol(vol: Real): void;
  interpolatedVariances(): PiecewiseConstantVariance[];
  originalVariances(): PiecewiseConstantVariance[];
  getPeriod(): Size;
  getOffset(): Size;
  getNoBigRates(): Size;
  getNoSmallRates(): Size;
}

export declare class VolatilityInterpolationSpecifierabcd extends
    VolatilityInterpolationSpecifier {
  constructor(
      period: Size, offset: Size,
      originalVariances: PiecewiseConstantAbcdVariance[],
      timesForSmallRates: Time[], lastCapletVol?: Real);
  setScalingFactors(scales: Real[]): void;
  setLastCapletVol(vol: Real): void;
  interpolatedVariances(): PiecewiseConstantVariance[];
  originalVariances(): PiecewiseConstantVariance[];
  getPeriod(): Size;
  getOffset(): Size;
  getNoBigRates(): Size;
  getNoSmallRates(): Size;
  private recompute;
  private _period;
  private _offset;
  private _interpolatedVariances;
  private _originalVariances;
  private _originalABCDVariances;
  private _originalABCDVariancesScaled;
  private _lastCapletVol;
  private _timesForSmallRates;
  private _scalingFactors;
  private _noBigRates;
  private _noSmallRates;
}

export declare class VolatilityBumpInstrumentJacobian {
  constructor(
      bumps: VegaBumpCollection,
      swaptions: VolatilityBumpInstrumentJacobian.Swaption[],
      caps: VolatilityBumpInstrumentJacobian.Cap[]);
  getInputBumps(): VegaBumpCollection;
  derivativesVolatility(j: Size): Real[];
  onePercentBump(j: Size): Real[];
  getAllOnePercentBumps(): Matrix;
  private _bumps;
  private _swaptions;
  private _caps;
  private _computed;
  private _allComputed;
  private _derivatives;
  private _onePercentBumps;
  private _bumpMatrix;
}
export declare namespace VolatilityBumpInstrumentJacobian {
  class Swaption {
    _startIndex: Size;
    _endIndex: Size;
  }
  class Cap {
    _startIndex: Size;
    _endIndex: Size;
    _strike: Real;
  }
}
export declare class OrthogonalizedBumpFinder {
  constructor(
      bumps: VegaBumpCollection,
      swaptions: VolatilityBumpInstrumentJacobian.Swaption[],
      caps: VolatilityBumpInstrumentJacobian.Cap[], multiplierCutOff: Real,
      tolerance: Real);
  GetVegaBumps(theBumps: Matrix[][]): void;
  private _derivativesProducer;
  private _multiplierCutOff;
  private _tolerance;
}

export declare class RatePseudoRootJacobianNumerical {
  constructor(
      pseudoRoot: Matrix, aliveIndex: Size, numeraire: Size, taus: Time[],
      pseudoBumps: Matrix[], displacements: Spread[]);
  getBumps(
      oldRates: Rate[], oneStepDFs: Real[], newRates: Rate[], gaussians: Real[],
      B: Matrix): void;
  private _pseudoRoot;
  private _aliveIndex;
  private _taus;
  private _pseudoBumped;
  private _displacements;
  private _numberBumps;
  private _driftsComputers;
  private _factors;
  private _drifts;
  private _bumpedRates;
}
export declare class RatePseudoRootJacobian {
  constructor(
      pseudoRoot: Matrix, aliveIndex: Size, numeraire: Size, taus: Time[],
      pseudoBumps: Matrix[], displacements: Spread[]);
  getBumps(
      oldRates: Rate[], discountRatios: Real[], newRates: Rate[],
      gaussians: Real[], B: Matrix): void;
  private _pseudoRoot;
  private _aliveIndex;
  private _taus;
  private _pseudoBumps;
  private _displacements;
  private _numberBumps;
  private _factors;
  private _allDerivatives;
  private _e;
  private _ratios;
}
export declare class RatePseudoRootJacobianAllElements {
  constructor(
      pseudoRoot: Matrix, aliveIndex: Size, numeraire: Size, taus: Time[],
      displacements: Spread[]);
  getBumps(
      oldRates: Rate[], discountRatios: Real[], newRates: Rate[],
      gaussians: Real[], B: Matrix[]): void;
  private _pseudoRoot;
  private _aliveIndex;
  private _taus;
  private _displacements;
  private _factors;
  private _e;
  private _ratios;
}

export declare class SwaptionPseudoDerivative {
  constructor(inputModel: MarketModel, startIndex: Size, endIndex: Size);
  varianceDerivative(i: Size): Matrix;
  volatilityDerivative(i: Size): Matrix;
  impliedVolatility(): Real;
  variance(): Real;
  expiry(): Real;
  private _varianceDerivatives;
  private _volatilityDerivatives;
  private _impliedVolatility;
  private _expiry;
  private _variance;
}
export declare class CapPseudoDerivative {
  constructor(
      inputModel: MarketModel, strike: Real, startIndex: Size, endIndex: Size,
      firstDF: Real);
  volatilityDerivative(i: Size): Matrix;
  priceDerivative(i: Size): Matrix;
  impliedVolatility(): Real;
  private _volatilityDerivatives;
  private _priceDerivatives;
  private _impliedVolatility;
  private _vega;
  private _firstDF;
}

export declare class VegaBumpCluster {
  constructor(
      factorBegin: Size, factorEnd: Size, rateBegin: Size, rateEnd: Size,
      stepBegin: Size, stepEnd: Size);
  doesIntersect(comparee: VegaBumpCluster): boolean;
  isCompatible(volStructure: MarketModel): boolean;
  factorBegin(): Size;
  factorEnd(): Size;
  rateBegin(): Size;
  rateEnd(): Size;
  stepBegin(): Size;
  stepEnd(): Size;
  private _factorBegin;
  private _factorEnd;
  private _rateBegin;
  private _rateEnd;
  private _stepBegin;
  private _stepEnd;
}
export declare class VegaBumpCollection {
  init1(volStructure: MarketModel, factorwiseBumping?: boolean):
      VegaBumpCollection;
  init2(allBumps: VegaBumpCluster[], volStructure: MarketModel):
      VegaBumpCollection;
  numberBumps(): Size;
  associatedModel(): MarketModel;
  allBumps(): VegaBumpCluster[];
  isFull(): boolean;
  isNonOverlapping(): boolean;
  isSensible(): boolean;
  private _allBumps;
  private _associatedVolStructure;
  private _checked;
  private _nonOverlapped;
  private _full;
}

export declare class LogNormalCmSwapRatePc extends MarketModelEvolver {
  constructor(
      spanningForwards: Size, marketModel: MarketModel,
      factory: BrownianGeneratorFactory, numeraires: Size[],
      initialStep?: Size);
  numeraires(): Size[];
  startNewPath(): Real;
  advanceStep(): Real;
  currentStep(): Size;
  currentState(): CurveState;
  setInitialState(cs: CurveState): void;
  private setCMSwapRates;
  private _spanningForwards;
  private _marketModel;
  private _numeraires;
  private _initialStep;
  private _generator;
  private _fixedDrifts;
  private _numberOfRates;
  private _numberOfFactors;
  private _curveState;
  private _currentStep;
  private _swapRates;
  private _displacements;
  private _logSwapRates;
  private _initialLogSwapRates;
  private _drifts1;
  private _drifts2;
  private _initialDrifts;
  private _brownians;
  _correlatedBrownians: Real[];
  private _alive;
  private _calculators;
}

export declare class LogNormalCotSwapRatePc extends MarketModelEvolver {
  constructor(
      marketModel: MarketModel, factory: BrownianGeneratorFactory,
      numeraires: Size[], initialStep?: Size);
  numeraires(): Size[];
  startNewPath(): Real;
  advanceStep(): Real;
  currentStep(): Size;
  currentState(): CurveState;
  setInitialState(cs: CurveState): void;
  private setCoterminalSwapRates;
  private _marketModel;
  private _numeraires;
  private _initialStep;
  private _generator;
  private _fixedDrifts;
  private _numberOfRates;
  private _numberOfFactors;
  private _curveState;
  private _currentStep;
  private _swapRates;
  private _displacements;
  private _logSwapRates;
  private _initialLogSwapRates;
  private _drifts1;
  private _drifts2;
  private _initialDrifts;
  private _brownians;
  _correlatedBrownians: Real[];
  private _alive;
  private _calculators;
}

export declare class LogNormalFwdRateBalland extends MarketModelEvolver {
  constructor(
      marketModel: MarketModel, factory: BrownianGeneratorFactory,
      numeraires: Size[], initialStep?: Size);
  numeraires(): Size[];
  startNewPath(): Real;
  advanceStep(): Real;
  currentStep(): Size;
  currentState(): CurveState;
  setInitialState(cs: CurveState): void;
  private setForwards;
  private _marketModel;
  private _numeraires;
  private _initialStep;
  private _generator;
  private _fixedDrifts;
  private _numberOfRates;
  private _numberOfFactors;
  private _curveState;
  private _currentStep;
  private _forwards;
  private _displacements;
  private _logForwards;
  private _initialLogForwards;
  private _drifts1;
  private _drifts2;
  private _initialDrifts;
  private _brownians;
  _correlatedBrownians: Real[];
  _rateTaus: Time[];
  private _alive;
  private _calculators;
}

export declare class LogNormalFwdRateEuler extends MarketModelEvolver {
  constructor(
      marketModel: MarketModel, factory: BrownianGeneratorFactory,
      numeraires: Size[], initialStep?: Size);
  numeraires(): Size[];
  startNewPath(): Real;
  advanceStep(): Real;
  currentStep(): Size;
  currentState(): CurveState;
  setInitialState(cs: CurveState): void;
  private setForwards;
  private _marketModel;
  private _numeraires;
  private _initialStep;
  private _generator;
  private _fixedDrifts;
  private _numberOfRates;
  private _numberOfFactors;
  private _curveState;
  private _currentStep;
  private _forwards;
  private _displacements;
  private _logForwards;
  private _initialLogForwards;
  private _drifts1;
  private _initialDrifts;
  private _brownians;
  _correlatedBrownians: Real[];
  private _alive;
  private _calculators;
}

export declare class LogNormalFwdRateEulerConstrained extends
    ConstrainedEvolver {
  constructor(
      marketModel: MarketModel, factory: BrownianGeneratorFactory,
      numeraires: Size[], initialStep?: Size);
  setConstraintType1(startIndexOfSwapRate: Size[], endIndexOfSwapRate: Size[]):
      void;
  setConstraintType2(rateConstraints: Rate[], isConstraintActive: boolean[]):
      void;
  numeraires(): Size[];
  startNewPath(): Real;
  advanceStep(): Real;
  currentStep(): Real;
  currentState(): CurveState;
  setInitialState(cs: CurveState): void;
  private setForwards;
  private _marketModel;
  private _numeraires;
  private _initialStep;
  private _generator;
  private _startIndexOfSwapRate;
  private _endIndexOfSwapRate;
  private _rateConstraints;
  private _isConstraintActive;
  private _fixedDrifts;
  private _variances;
  private _covariances;
  private _numberOfRates;
  private _numberOfFactors;
  private _curveState;
  private _currentStep;
  private _forwards;
  private _displacements;
  private _logForwards;
  private _initialLogForwards;
  private _drifts1;
  private _initialDrifts;
  private _brownians;
  private _alive;
  private _calculators;
}

export declare class LogNormalFwdRateiBalland extends MarketModelEvolver {
  constructor(
      marketModel: MarketModel, factory: BrownianGeneratorFactory,
      numeraires: Size[], initialStep?: Size);
  numeraires(): Size[];
  startNewPath(): Real;
  advanceStep(): Real;
  currentStep(): Real;
  currentState(): CurveState;
  setInitialState(cs: CurveState): void;
  private setForwards;
  private _marketModel;
  private _numeraires;
  private _initialStep;
  private _generator;
  private _fixedDrifts;
  private _numberOfRates;
  private _numberOfFactors;
  private _curveState;
  private _currentStep;
  private _forwards;
  private _displacements;
  private _logForwards;
  private _initialLogForwards;
  private _initialDrifts;
  private _brownians;
  private _rateTaus;
  private _alive;
  private _calculators;
}

export declare class LogNormalFwdRateIpc extends MarketModelEvolver {
  constructor(
      marketModel: MarketModel, factory: BrownianGeneratorFactory,
      numeraires: Size[], initialStep?: Size);
  numeraires(): Size[];
  startNewPath(): Real;
  advanceStep(): Real;
  currentStep(): Real;
  currentState(): CurveState;
  setInitialState(cs: CurveState): void;
  private setForwards;
  private _marketModel;
  private _numeraires;
  private _initialStep;
  private _generator;
  private _fixedDrifts;
  private _numberOfRates;
  private _numberOfFactors;
  private _curveState;
  private _currentStep;
  private _forwards;
  private _displacements;
  private _logForwards;
  private _initialLogForwards;
  private _drifts1;
  private _initialDrifts;
  private _g;
  private _brownians;
  private _rateTaus;
  private _alive;
  private _calculators;
}

export declare class LogNormalFwdRatePc extends MarketModelEvolver {
  constructor(
      marketModel: MarketModel, factory: BrownianGeneratorFactory,
      numeraires: Size[], initialStep?: Size);
  numeraires(): Size[];
  startNewPath(): Real;
  advanceStep(): Real;
  currentStep(): Real;
  currentState(): CurveState;
  setInitialState(cs: CurveState): void;
  private setForwards;
  private _marketModel;
  private _numeraires;
  private _initialStep;
  private _generator;
  private _fixedDrifts;
  private _numberOfRates;
  private _numberOfFactors;
  private _curveState;
  private _currentStep;
  private _forwards;
  private _displacements;
  private _logForwards;
  private _initialLogForwards;
  private _drifts1;
  private _drifts2;
  private _initialDrifts;
  private _brownians;
  private _alive;
  private _calculators;
}

export declare class MarketModelVolProcess {
  variatesPerStep(): Size;
  numberSteps(): Size;
  nextPath(): void;
  nextstep(variates: Real[]): Real;
  stepSd(): Real;
  stateVariables(): Real[];
  numberStateVariables(): Size;
}

export declare class NormalFwdRatePc extends MarketModelEvolver {
  constructor(
      marketModel: MarketModel, factory: BrownianGeneratorFactory,
      numeraires: Size[], initialStep?: Size);
  numeraires(): Size[];
  startNewPath(): Real;
  advanceStep(): Real;
  currentStep(): Real;
  currentState(): CurveState;
  setInitialState(cs: CurveState): void;
  private setForwards;
  private _marketModel;
  private _numeraires;
  private _initialStep;
  private _generator;
  private _numberOfRates;
  private _numberOfFactors;
  private _curveState;
  private _currentStep;
  private _forwards;
  private _initialForwards;
  private _drifts1;
  private _drifts2;
  private _initialDrifts;
  private _brownians;
  private _alive;
  private _calculators;
}

export declare class SVDDFwdRatePc extends MarketModelEvolver {
  constructor(
      marketModel: MarketModel, factory: BrownianGeneratorFactory,
      volProcess: MarketModelVolProcess, firstVolatilityFactor: Size,
      volatilityFactorStep: Size, numeraires: Size[], initialStep?: Size);
  numeraires(): Size[];
  startNewPath(): Real;
  advanceStep(): Real;
  currentStep(): Real;
  currentState(): CurveState;
  setInitialState(cs: CurveState): void;
  private setForwards;
  private _marketModel;
  private _numeraires;
  private _initialStep;
  private _generator;
  private _volProcess;
  private _firstVolatilityFactor;
  private _volFactorsPerStep;
  private _fixedDrifts;
  private _isVolVariate;
  private _numberOfRates;
  private _numberOfFactors;
  private _curveState;
  private _currentStep;
  private _forwards;
  private _displacements;
  private _logForwards;
  private _initialLogForwards;
  private _drifts1;
  private _drifts2;
  private _initialDrifts;
  private _allBrownians;
  private _brownians;
  private _volBrownians;
  private _alive;
  private _calculators;
}

export declare class SquareRootAndersen extends MarketModelVolProcess {
  constructor(
      meanLevel: Real, reversionSpeed: Real, volVar: Real, v0: Real,
      evolutionTimes: Real[], numberSubSteps: Size, w1: Real, w2: Real,
      cutPoint?: Real);
  variatesPerStep(): Size;
  numberSteps(): Size;
  nextPath(): void;
  nextstep(variates: Real[]): Real;
  stepSd(): Real;
  stateVariables(): Real[];
  numberStateVariables(): Size;
  private DoOneSubStep;
  private _theta;
  private _k;
  private _epsilon;
  private _v0;
  private _numberSubSteps;
  private _dt;
  private _eMinuskDt;
  private _w1;
  private _w2;
  private _PsiC;
  private _v;
  private _currentStep;
  private _subStep;
  private _vPath;
  private _state;
}

export declare class MarketModelComposite extends MarketModelMultiProduct {
  constructor();
  evolution(): EvolutionDescription;
  suggestedNumeraires(): Size[];
  possibleCashFlowTimes(): Time[];
  reset(): void;
  add(product: MarketModelMultiProduct, multiplier?: Real): void;
  subtract(product: MarketModelMultiProduct, multiplier?: Real): void;
  finalize(): void;
  size(): Size;
  item(i: Size): MarketModelMultiProduct;
  multiplier(i: Size): Real;
  protected _components: MarketModelComposite.SubProduct[];
  protected _rateTimes: Time[];
  protected _evolutionTimes: Time[];
  protected _evolution: EvolutionDescription;
  protected _finalized: boolean;
  protected _currentIndex: Size;
  protected _cashflowTimes: Time[];
  protected _allEvolutionTimes: Time[][];
  protected _isInSubset: boolean[][];
}
export declare namespace MarketModelComposite {
  class SubProduct {
    product: MarketModelMultiProduct;
    multiplier: Real;
    numberOfCashflows: Size[];
    cashflows: MarketModelMultiProduct.CashFlow[][];
    timeIndices: Size[];
    done: boolean;
  }
}

export declare class MultiProductComposite extends MarketModelMultiProduct {
  constructor();
  evolution(): EvolutionDescription;
  suggestedNumeraires(): Size[];
  possibleCashFlowTimes(): Time[];
  add(product: MarketModelMultiProduct, multiplier?: Real): void;
  subtract(product: MarketModelMultiProduct, multiplier?: Real): void;
  finalize(): void;
  reset(): void;
  size(): Size;
  item(i: Size): MarketModelMultiProduct;
  multiplier(i: Size): Real;
  protected _components: MultiProductComposite.SubProduct[];
  protected _rateTimes: Time[];
  protected _evolutionTimes: Time[];
  protected _evolution: EvolutionDescription;
  protected _finalized: boolean;
  protected _currentIndex: Size;
  protected _cashflowTimes: Time[];
  protected _allEvolutionTimes: Time[][];
  protected _isInSubset: boolean[][];
}
export declare namespace MultiProductComposite {
  class SubProduct {
    product: MarketModelMultiProduct;
    multiplier: Real;
    numberOfCashflows: Size[];
    cashflows: MarketModelMultiProduct.CashFlow[][];
    timeIndices: Size[];
    done: boolean;
  }
}

export declare class MultiProductMultiStep extends MarketModelMultiProduct {
  constructor(rateTimes: Time[]);
  suggestedNumeraires(): Size[];
  evolution(): EvolutionDescription;
  protected _rateTimes: Time[];
  protected _evolution: EvolutionDescription;
}

export declare class MultiProductOneStep extends MarketModelMultiProduct {
  constructor(rateTimes: Time[]);
  evolution(): EvolutionDescription;
  suggestedNumeraires(): Size[];
  protected _rateTimes: Time[];
  protected _evolution: EvolutionDescription;
}

export declare class SingleProductComposite extends MarketModelComposite {
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      cashFlowsGenerated: MarketModelMultiProduct.CashFlow[][]): boolean;
  clone(): MarketModelMultiProduct;
}

export declare class CallSpecifiedMultiProduct extends MarketModelMultiProduct {
  constructor(
      underlying: MarketModelMultiProduct, strategy: ExerciseStrategy,
      rebate?: MarketModelMultiProduct);
  suggestedNumeraires(): Size[];
  evolution(): EvolutionDescription;
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      cashFlowsGenerated: MarketModelMultiProduct.CashFlow[][]): boolean;
  clone(): MarketModelMultiProduct;
  underlying(): MarketModelMultiProduct;
  strategy(): ExerciseStrategy;
  rebate(): MarketModelMultiProduct;
  enableCallability(): void;
  disableCallability(): void;
  _underlying: MarketModelMultiProduct;
  _strategy: ExerciseStrategy;
  _rebate: MarketModelMultiProduct;
  private _evolution;
  private _isPresent;
  private _cashFlowTimes;
  private _rebateOffset;
  private _wasCalled;
  private _dummyCashFlowsThisStep;
  private _dummyCashFlowsGenerated;
  private _currentIndex;
  private _callable;
}

export declare class MarketModelCashRebate extends MarketModelMultiProduct {
  constructor(
      evolution: EvolutionDescription, paymentTimes: Time[], amounts: Matrix,
      numberOfProducts: Size);
  suggestedNumeraires(): Size[];
  evolution(): EvolutionDescription;
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      genCashFlows: MarketModelMultiProduct.CashFlow[][]): boolean;
  clone(): MarketModelMultiProduct;
  private _evolution;
  private _paymentTimes;
  private _amounts;
  private _numberOfProducts;
  private _currentIndex;
}

export declare class ExerciseAdapter extends MultiProductMultiStep {
  constructor(exercise: MarketModelExerciseValue, numberOfProducts?: Size);
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  evolution(): EvolutionDescription;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      generatedCashFlows: MarketModelMultiProduct.CashFlow[][]): boolean;
  clone(): MarketModelMultiProduct;
  exerciseValue(): MarketModelExerciseValue;
  private _exercise;
  private _numberOfProducts;
  private _isExerciseTime;
  private _currentIndex;
}

export declare class MultiStepCoinitialSwaps extends MultiProductMultiStep {
  constructor(
      rateTimes: Time[], fixedAccruals: Real[], floatingAccruals: Real[],
      paymentTimes: Time[], fixedRate: Rate);
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      genCashFlows: MarketModelMultiProduct.CashFlow[][]): boolean;
  clone(): MarketModelMultiProduct;
  private _fixedAccruals;
  private _floatingAccruals;
  private _paymentTimes;
  private _fixedRate;
  private _lastIndex;
  private _currentIndex;
}

export declare class MultiStepCoterminalSwaps extends MultiProductMultiStep {
  constructor(
      rateTimes: Time[], fixedAccruals: Real[], floatingAccruals: Real[],
      paymentTimes: Time[], fixedRate: Rate);
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      genCashFlows: MarketModelMultiProduct.CashFlow[][]): boolean;
  clone(): MarketModelMultiProduct;
  private _fixedAccruals;
  private _floatingAccruals;
  private _paymentTimes;
  private _fixedRate;
  private _lastIndex;
  private _currentIndex;
}

export declare class MultiStepCoterminalSwaptions extends
    MultiProductMultiStep {
  constructor(
      rateTimes: Time[], paymentTimes: Time[], payoffs: StrikedTypePayoff[]);
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      genCashFlows: MarketModelMultiProduct.CashFlow[][]): boolean;
  clone(): MarketModelMultiProduct;
  private _paymentTimes;
  private _payoffs;
  private _lastIndex;
  private _currentIndex;
}

export declare class MultiStepForwards extends MultiProductMultiStep {
  constructor(
      rateTimes: Time[], accruals: Real[], paymentTimes: Time[],
      strikes: Rate[]);
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      genCashFlows: MarketModelMultiProduct.CashFlow[][]): boolean;
  clone(): MarketModelMultiProduct;
  private _accruals;
  private _paymentTimes;
  private _strikes;
  private _currentIndex;
}

export declare class MultiStepInverseFloater extends MultiProductMultiStep {
  constructor(
      rateTimes: Time[], fixedAccruals: Real[], floatingAccruals: Real[],
      fixedStrikes: Real[], fixedMultipliers: Real[], floatingSpreads: Real[],
      paymentTimes: Time[], payer?: boolean);
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      genCashFlows: MarketModelMultiProduct.CashFlow[][]): boolean;
  clone(): MarketModelMultiProduct;
  private _fixedAccruals;
  private _floatingAccruals;
  private _fixedStrikes;
  private _fixedMultipliers;
  private _floatingSpreads;
  private _paymentTimes;
  private _multiplier;
  private _lastIndex;
  private _currentIndex;
}

export declare class MultiStepNothing extends MultiProductMultiStep {
  constructor(
      evolution: EvolutionDescription, numberOfProducts?: Size,
      doneIndex?: Size);
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      cs: CurveState, numberCashFlowsThisStep: Size[],
      cf: MarketModelMultiProduct.CashFlow[][]): boolean;
  clone(): MarketModelMultiProduct;
  private _numberOfProducts;
  private _doneIndex;
  private _currentIndex;
}

export declare class MultiStepOptionlets extends MultiProductMultiStep {
  constructor(
      rateTimes: Time[], accruals: Real[], paymentTimes: Time[],
      payoffs: Payoff[]);
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      genCashFlows: MarketModelMultiProduct.CashFlow[][]): boolean;
  clone(): MarketModelMultiProduct;
  private _accruals;
  private _paymentTimes;
  private _payoffs;
  private _currentIndex;
}

export declare class MultiProductPathwiseWrapper extends
    MarketModelMultiProduct {
  constructor(innerProduct: MarketModelPathwiseMultiProduct);
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      cashFlowsGenerated: MarketModelMultiProduct.CashFlow[][]): boolean;
  clone(): MarketModelMultiProduct;
  suggestedNumeraires(): Size[];
  evolution(): EvolutionDescription;
  private _innerProduct;
  private _cashFlowsGenerated;
  private _numberOfProducts;
}

export declare class MultiStepPeriodCapletSwaptions extends
    MultiProductMultiStep {
  constructor(
      rateTimes: Time[], forwardOptionPaymentTimes: Time[],
      swaptionPaymentTimes: Time[], forwardPayOffs: StrikedTypePayoff[],
      swapPayOffs: StrikedTypePayoff[], period: Size, offset: Size);
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      genCashFlows: MarketModelMultiProduct.CashFlow[][]): boolean;
  clone(): MarketModelMultiProduct;
  private _paymentTimes;
  private _forwardOptionPaymentTimes;
  private _swaptionPaymentTimes;
  private _forwardPayOffs;
  private _swapPayOffs;
  private _period;
  private _offset;
  private _numberFRAs;
  private _numberBigFRAs;
  private _currentIndex;
  private _productIndex;
}

export declare class MultiStepRatchet extends MultiProductMultiStep {
  constructor(
      rateTimes: Time[], accruals: Real[], paymentTimes: Time[],
      gearingOfFloor: Real, gearingOfFixing: Real, spreadOfFloor: Rate,
      spreadOfFixing: Rate, initialFloor: Real, payer?: boolean);
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      genCashFlows: MarketModelMultiProduct.CashFlow[][]): boolean;
  clone(): MarketModelMultiProduct;
  private _accruals;
  private _paymentTimes;
  private _gearingOfFloor;
  private _gearingOfFixing;
  private _spreadOfFloor;
  private _spreadOfFixing;
  private _multiplier;
  private _lastIndex;
  private _initialFloor;
  private _floor;
  private _currentIndex;
}

export declare class MultiStepSwap extends MultiProductMultiStep {
  constructor(
      rateTimes: Time[], fixedAccruals: Real[], floatingAccruals: Real[],
      paymentTimes: Time[], fixedRate: Rate, payer?: boolean);
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      genCashFlows: MarketModelMultiProduct.CashFlow[][]): boolean;
  clone(): MarketModelMultiProduct;
  private _fixedAccruals;
  private _floatingAccruals;
  private _paymentTimes;
  private _fixedRate;
  private _multiplier;
  private _lastIndex;
  private _currentIndex;
}

export declare class MultiStepSwaption extends MultiProductMultiStep {
  constructor(
      rateTimes: Time[], startIndex: Size, endIndex: Size,
      payoff: StrikedTypePayoff);
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      genCashFlows: MarketModelMultiProduct.CashFlow[][]): boolean;
  clone(): MarketModelMultiProduct;
  private _startIndex;
  private _endIndex;
  private _payoff;
  private _paymentTimes;
  private _currentIndex;
}

export declare class MultiStepTarn extends MultiProductMultiStep {
  constructor(
      rateTimes: Time[], accruals: Real[], accrualsFloating: Real[],
      paymentTimes: Time[], paymentTimesFloating: Time[], totalCoupon: Real,
      strikes: Real[], multipliers: Real[], floatingSpreads: Real[]);
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      genCashFlows: MarketModelMultiProduct.CashFlow[][]): boolean;
  clone(): MarketModelMultiProduct;
  private _accruals;
  private _accrualsFloating;
  private _paymentTimes;
  private _paymentTimesFloating;
  private _allPaymentTimes;
  private _totalCoupon;
  private _strikes;
  private _multipliers;
  private _floatingSpreads;
  private _lastIndex;
  private _couponPaid;
  private _currentIndex;
}

export declare class OneStepCoinitialSwaps extends MultiProductOneStep {
  constructor(
      rateTimes: Time[], fixedAccruals: Real[], floatingAccruals: Real[],
      paymentTimes: Time[], fixedRate: Real);
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      genCashFlows: MarketModelMultiProduct.CashFlow[][]): boolean;
  clone(): MarketModelMultiProduct;
  private _fixedAccruals;
  private _floatingAccruals;
  private _paymentTimes;
  private _fixedRate;
  private _lastIndex;
}

export declare class OneStepCoterminalSwaps extends MultiProductOneStep {
  constructor(
      rateTimes: Time[], fixedAccruals: Real[], floatingAccruals: Real[],
      paymentTimes: Time[], fixedRate: Real);
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      genCashFlows: MarketModelMultiProduct.CashFlow[][]): boolean;
  clone(): MarketModelMultiProduct;
  private _fixedAccruals;
  private _floatingAccruals;
  private _paymentTimes;
  private _fixedRate;
  private _lastIndex;
}

export declare class OneStepForwards extends MultiProductOneStep {
  constructor(
      rateTimes: Time[], accruals: Real[], paymentTimes: Time[],
      strikes: Rate[]);
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      genCashFlows: MarketModelMultiProduct.CashFlow[][]): boolean;
  clone(): MarketModelMultiProduct;
  private _accruals;
  private _paymentTimes;
  private _strikes;
}

export declare class OneStepOptionlets extends MultiProductOneStep {
  constructor(
      rateTimes: Time[], accruals: Real[], paymentTimes: Time[],
      payoff: Payoff[]);
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      genCashFlows: MarketModelMultiProduct.CashFlow[][]): boolean;
  clone(): MarketModelMultiProduct;
  private _accruals;
  private _paymentTimes;
  private _payoffs;
}

export declare class CallSpecifiedPathwiseMultiProduct extends
    MarketModelPathwiseMultiProduct {
  constructor(
      underlying: MarketModelPathwiseMultiProduct, strategy: ExerciseStrategy,
      rebate?: MarketModelPathwiseMultiProduct);
  suggestedNumeraires(): Size[];
  evolution(): EvolutionDescription;
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      cashFlowsGenerated: MarketModelPathwiseMultiProduct.CashFlow[][]):
      boolean;
  clone(): MarketModelPathwiseMultiProduct;
  alreadyDeflated(): boolean;
  underlying(): MarketModelPathwiseMultiProduct;
  strategy(): ExerciseStrategy;
  rebate(): MarketModelPathwiseMultiProduct;
  enableCallability(): void;
  disableCallability(): void;
  private _underlying;
  private _strategy;
  private _rebate;
  private _evolution;
  private _isPresent;
  private _cashFlowTimes;
  private _rebateOffset;
  private _wasCalled;
  private _dummyCashFlowsThisStep;
  private _dummyCashFlowsGenerated;
  private _currentIndex;
  private _callable;
}

export declare class MarketModelPathwiseMultiCaplet extends
    MarketModelPathwiseMultiProduct {
  constructor(
      rateTimes: Time[], accruals: Real[], paymentTimes: Time[],
      strikes: Rate[]);
  suggestedNumeraires(): Size[];
  evolution(): EvolutionDescription;
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      cashFlowsGenerated: MarketModelPathwiseMultiProduct.CashFlow[][]):
      boolean;
  clone(): MarketModelPathwiseMultiProduct;
  alreadyDeflated(): boolean;
  private _rateTimes;
  private _accruals;
  private _paymentTimes;
  private _strikes;
  private _numberRates;
  private _currentIndex;
  private _evolution;
}
export declare class MarketModelPathwiseMultiDeflatedCaplet extends
    MarketModelPathwiseMultiProduct {
  init1(
      rateTimes: Time[], accruals: Real[], paymentTimes: Time[],
      strikes: Rate[]): MarketModelPathwiseMultiDeflatedCaplet;
  init2(
      rateTimes: Time[], accruals: Real[], paymentTimes: Time[],
      strike: Rate): MarketModelPathwiseMultiDeflatedCaplet;
  suggestedNumeraires(): Size[];
  evolution(): EvolutionDescription;
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      cashFlowsGenerated: MarketModelPathwiseMultiProduct.CashFlow[][]):
      boolean;
  clone(): MarketModelPathwiseMultiProduct;
  alreadyDeflated(): boolean;
  private _rateTimes;
  private _accruals;
  private _paymentTimes;
  private _strikes;
  private _numberRates;
  private _currentIndex;
  private _evolution;
}
export declare class MarketModelPathwiseMultiDeflatedCap extends
    MarketModelPathwiseMultiProduct {
  constructor(
      rateTimes: Time[], accruals: Real[], paymentTimes: Time[], strike: Rate,
      startsAndEnds: Array<[Size, Size]>);
  suggestedNumeraires(): Size[];
  evolution(): EvolutionDescription;
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      cashFlowsGenerated: MarketModelPathwiseMultiProduct.CashFlow[][]):
      boolean;
  clone(): MarketModelPathwiseMultiProduct;
  alreadyDeflated(): boolean;
  private _underlyingCaplets;
  private _numberRates;
  private _startsAndEnds;
  private _innerCashFlowSizes;
  private _innerCashFlowsGenerated;
}

export declare class MarketModelPathwiseCashRebate extends
    MarketModelPathwiseMultiProduct {
  constructor(
      evolution: EvolutionDescription, paymentTimes: Time[], amounts: Matrix,
      numberOfProducts: Size);
  suggestedNumeraires(): Size[];
  evolution(): EvolutionDescription;
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      cashFlowsGenerated: MarketModelPathwiseMultiProduct.CashFlow[][]):
      boolean;
  clone(): MarketModelPathwiseMultiProduct;
  alreadyDeflated(): boolean;
  private _evolution;
  private _paymentTimes;
  private _amounts;
  private _numberOfProducts;
  private _currentIndex;
}

export declare class MarketModelPathwiseInverseFloater extends
    MarketModelPathwiseMultiProduct {
  constructor(
      rateTimes: Time[], fixedAccruals: Real[], floatingAccruals: Real[],
      fixedStrikes: Real[], fixedMultipliers: Real[], floatingSpreads: Real[],
      paymentTimes: Time[], payer?: boolean);
  suggestedNumeraires(): Size[];
  evolution(): EvolutionDescription;
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      cashFlowsGenerated: MarketModelPathwiseMultiProduct.CashFlow[][]):
      boolean;
  clone(): MarketModelPathwiseMultiProduct;
  alreadyDeflated(): boolean;
  private _rateTimes;
  private _fixedAccruals;
  private _floatingAccruals;
  private _fixedStrikes;
  private _fixedMultipliers;
  private _floatingSpreads;
  private _paymentTimes;
  private _multiplier;
  private _lastIndex;
  private _evolution;
  private _currentIndex;
}

export declare class MarketModelPathwiseSwap extends
    MarketModelPathwiseMultiProduct {
  constructor(
      rateTimes: Time[], accruals: Time[], strikes: Time[], multiplier?: Real);
  suggestedNumeraires(): Size[];
  evolution(): EvolutionDescription;
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      cashFlowsGenerated: MarketModelPathwiseMultiProduct.CashFlow[][]):
      boolean;
  clone(): MarketModelPathwiseMultiProduct;
  alreadyDeflated(): boolean;
  private _rateTimes;
  private _accruals;
  private _strikes;
  private _numberRates;
  private _multiplier;
  private _currentIndex;
  private _evolution;
}

export declare class MarketModelPathwiseCoterminalSwaptionsDeflated extends
    MarketModelPathwiseMultiProduct {
  constructor(rateTimes: Time[], strikes: Time[]);
  suggestedNumeraires(): Size[];
  evolution(): EvolutionDescription;
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      cashFlowsGenerated: MarketModelPathwiseMultiProduct.CashFlow[][]):
      boolean;
  clone(): MarketModelPathwiseMultiProduct;
  alreadyDeflated(): boolean;
  private _rateTimes;
  private _strikes;
  private _numberRates;
  private _currentIndex;
  private _evolution;
}
export declare class MarketModelPathwiseCoterminalSwaptionsNumericalDeflated
    extends MarketModelPathwiseMultiProduct {
  constructor(rateTimes: Time[], strikes: Time[], bumpSize: Real);
  suggestedNumeraires(): Size[];
  evolution(): EvolutionDescription;
  possibleCashFlowTimes(): Time[];
  numberOfProducts(): Size;
  maxNumberOfCashFlowsPerProductPerStep(): Size;
  reset(): void;
  nextTimeStep(
      currentState: CurveState, numberCashFlowsThisStep: Size[],
      cashFlowsGenerated: MarketModelPathwiseMultiProduct.CashFlow[][]):
      boolean;
  clone(): MarketModelPathwiseMultiProduct;
  alreadyDeflated(): boolean;
  private _rateTimes;
  private _strikes;
  private _numberRates;
  private _currentIndex;
  private _evolution;
  private _bumpSize;
  private _up;
  private _down;
  private _forwards;
}
